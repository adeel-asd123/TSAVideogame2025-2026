{
    "sourceFile": "main.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 46,
            "patches": [
                {
                    "date": 1762870163588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1762870231706,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -376,9 +376,9 @@\n             'e':\"down\"}\n     def textTypewriteAnimation(self, textPos, text, interval=0.05):\n         textSplit = list(text)\n         textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,1,1,1), align=TextNode.ACenter)\n-        def cleanup():\n+        def cleanup(task):\n             textNode.destroy()\n         async def typewrite():\n             for char in textSplit:\n                 textNode.setText(textNode.getText() + char)\n"
                },
                {
                    "date": 1762871518737,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -375,9 +375,9 @@\n             'space':\"up\",\n             'e':\"down\"}\n     def textTypewriteAnimation(self, textPos, text, interval=0.05):\n         textSplit = list(text)\n-        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,1,1,1), align=TextNode.ACenter)\n+        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(0,0,0,1), align=TextNode.ACenter)\n         def cleanup(task):\n             textNode.destroy()\n         async def typewrite():\n             for char in textSplit:\n"
                },
                {
                    "date": 1762874580107,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -375,9 +375,9 @@\n             'space':\"up\",\n             'e':\"down\"}\n     def textTypewriteAnimation(self, textPos, text, interval=0.05):\n         textSplit = list(text)\n-        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(0,0,0,1), align=TextNode.ACenter)\n+        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ACenter)\n         def cleanup(task):\n             textNode.destroy()\n         async def typewrite():\n             for char in textSplit:\n"
                },
                {
                    "date": 1762874927176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1270,9 +1270,9 @@\n         taskMgr.add(self.Update, \"Update\")        \n         self.accept('mouse1-up', self.MouseUp)\n         Loading_text.destroy() \n \n-        self.textTypewriteAnimation((0,0), 'hello')\n+        self.textTypewriteAnimation((0,0), 'Merwais is very smart and like, hes kinda of a homosexual but like in a cool way you know?')\n     # The Update cycle, this function should be used to update positions and anything that needs to be updated\n     def Update(self, task):\n         camera_forward = self.camera.getQuat(self.render).getForward()\n         camera_up = self.camera.getQuat(self.render).getUp()\n"
                },
                {
                    "date": 1762875024668,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1270,9 +1270,9 @@\n         taskMgr.add(self.Update, \"Update\")        \n         self.accept('mouse1-up', self.MouseUp)\n         Loading_text.destroy() \n \n-        self.textTypewriteAnimation((0,0), 'Merwais is very smart and like, hes kinda of a homosexual but like in a cool way you know?')\n+        self.textTypewriteAnimation((1,0), 'Merwais is very smart and like, hes kinda of a homosexual but like in a cool way you know?')\n     # The Update cycle, this function should be used to update positions and anything that needs to be updated\n     def Update(self, task):\n         camera_forward = self.camera.getQuat(self.render).getForward()\n         camera_up = self.camera.getQuat(self.render).getUp()\n"
                },
                {
                    "date": 1762875317553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -375,9 +375,9 @@\n             'space':\"up\",\n             'e':\"down\"}\n     def textTypewriteAnimation(self, textPos, text, interval=0.05):\n         textSplit = list(text)\n-        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ACenter)\n+        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft)\n         def cleanup(task):\n             textNode.destroy()\n         async def typewrite():\n             for char in textSplit:\n"
                },
                {
                    "date": 1762875374853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1270,9 +1270,9 @@\n         taskMgr.add(self.Update, \"Update\")        \n         self.accept('mouse1-up', self.MouseUp)\n         Loading_text.destroy() \n \n-        self.textTypewriteAnimation((1,0), 'Merwais is very smart and like, hes kinda of a homosexual but like in a cool way you know?')\n+        self.textTypewriteAnimation((-1,0), 'Merwais is very smart and like, hes kinda of a homosexual but like in a cool way you know?')\n     # The Update cycle, this function should be used to update positions and anything that needs to be updated\n     def Update(self, task):\n         camera_forward = self.camera.getQuat(self.render).getForward()\n         camera_up = self.camera.getQuat(self.render).getUp()\n"
                },
                {
                    "date": 1762875531927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -378,9 +378,9 @@\n         textSplit = list(text)\n         textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft)\n         def cleanup(task):\n             textNode.destroy()\n-        async def typewrite():\n+        async def typewrite(task):\n             for char in textSplit:\n                 textNode.setText(textNode.getText() + char)\n                 await Task.pause(interval)\n             return Task.Done\n"
                },
                {
                    "date": 1762875638971,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -378,13 +378,13 @@\n         textSplit = list(text)\n         textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft)\n         def cleanup(task):\n             textNode.destroy()\n-        async def typewrite(task):\n+        async def typewrite():\n             for char in textSplit:\n                 textNode.setText(textNode.getText() + char)\n                 await Task.pause(interval)\n-            return Task.Done\n+            return Task.done\n         taskMgr.add(typewrite(), 'typewriteTask', uponDeath=cleanup)\n     def dayNightCycle(self):\n         steps = {'sunSpeed': 0.0005, 'rotationSpeed': 0.000375}\n         self.cycleOscillation['notQiyamah'] -= steps['rotationSpeed']\n"
                },
                {
                    "date": 1762878691723,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,9 +243,9 @@\n         self.Run = True\n         self._gravity = LVector3(0, 0, -2)\n         self.EnemyCount = 0\n         self.waveCount = 1\n-        self.Font = self.showbase.loader.loadFont('assets/fonts/dimitri.ttf')\n+        self.Font = self.showbase.loader.loadFont('assets/fonts/propaganda.ttf')\n     async def setup(self, modelpath, extraAnims, num, height, health, waves= 5, changePerWave=1):\n         self.waveMethod = AsyncFuture()\n         self.num = num\n         self.Run = True\n@@ -375,9 +375,9 @@\n             'space':\"up\",\n             'e':\"down\"}\n     def textTypewriteAnimation(self, textPos, text, interval=0.05):\n         textSplit = list(text)\n-        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft)\n+        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft, font=self.loader.loadFont('assets/fonts/Micro5-Regular.ttf'))\n         def cleanup(task):\n             textNode.destroy()\n         async def typewrite():\n             for char in textSplit:\n@@ -1376,9 +1376,9 @@\n         taskMgr.add(self.loadScene())\n         \n         #  Tell Panda3d to listen for mouse clicks\n         self.accept('mouse1', self.MouseIn)\n-        self.Font = self.loader.loadFont('assets/fonts/dimitri.ttf')\n+        self.Font = self.loader.loadFont('assets/fonts/propaganda.ttf')\n         self.Font.setPixelsPerUnit(120)\n \n         self.clickSound = self.loader.loadSfx('assets/audio/click.wav')\n \n"
                },
                {
                    "date": 1762878782244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -382,8 +382,9 @@\n         async def typewrite():\n             for char in textSplit:\n                 textNode.setText(textNode.getText() + char)\n                 await Task.pause(interval)\n+            await Task.pause(1)\n             return Task.done\n         taskMgr.add(typewrite(), 'typewriteTask', uponDeath=cleanup)\n     def dayNightCycle(self):\n         steps = {'sunSpeed': 0.0005, 'rotationSpeed': 0.000375}\n@@ -950,9 +951,9 @@\n         self.btnExit.setTransparency(TransparencyAttrib.MAlpha)\n     def MainMenu(self):\n         self.inaMenu = True\n         self.mainMenuBackground = OnscreenImage(image='assets/images/mainMenuBackground.png', pos=(0, 0, 0), scale=(1.5, 1.5, 1.5))\n-        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.3, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n+        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.2, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n         self.titleText.setFont(self.Font)\n         self.btnPlay = DirectButton(\n             frameColor=(0.15, 0.15, 0.15, 1),\n             frameSize=(-0.2, 0.2, -0.03, 0.06),\n"
                },
                {
                    "date": 1762878862871,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -951,9 +951,9 @@\n         self.btnExit.setTransparency(TransparencyAttrib.MAlpha)\n     def MainMenu(self):\n         self.inaMenu = True\n         self.mainMenuBackground = OnscreenImage(image='assets/images/mainMenuBackground.png', pos=(0, 0, 0), scale=(1.5, 1.5, 1.5))\n-        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.2, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n+        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.25, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n         self.titleText.setFont(self.Font)\n         self.btnPlay = DirectButton(\n             frameColor=(0.15, 0.15, 0.15, 1),\n             frameSize=(-0.2, 0.2, -0.03, 0.06),\n"
                },
                {
                    "date": 1762879122170,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,10 +410,10 @@\n         self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                         frameSize=(-1.25, 1.25, -0.15, 0.15),\n                                         pos=(0, 0, -.75))\n         self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n-                                             frameSize=(-.5, .5, -0.1, 0.1),\n-                                             pos=(0, 0, -.8))\n+                                             frameSize=(-.1, .1, -0.1, 0.1),\n+                                             pos=(0, 0, -.75))\n     def exportScene(self):\n         file_name = input(\"Enter file name: \")\n         ss = StringStream()\n         self.render.ls(out=ss)\n"
                },
                {
                    "date": 1762879327326,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,9 +410,9 @@\n         self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                         frameSize=(-1.25, 1.25, -0.15, 0.15),\n                                         pos=(0, 0, -.75))\n         self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n-                                             frameSize=(-.1, .1, -0.1, 0.1),\n+                                             frameSize=(-.15, .15, -0.15, 0.15),\n                                              pos=(0, 0, -.75))\n     def exportScene(self):\n         file_name = input(\"Enter file name: \")\n         ss = StringStream()\n"
                },
                {
                    "date": 1762879350471,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -410,9 +410,9 @@\n         self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                         frameSize=(-1.25, 1.25, -0.15, 0.15),\n                                         pos=(0, 0, -.75))\n         self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n-                                             frameSize=(-.15, .15, -0.15, 0.15),\n+                                             frameSize=(-.125, .125, -0.125, 0.125),\n                                              pos=(0, 0, -.75))\n     def exportScene(self):\n         file_name = input(\"Enter file name: \")\n         ss = StringStream()\n"
                },
                {
                    "date": 1762880463280,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,14 +80,15 @@\n The default view is First Person. I will add a third person view later\n '''\n class CameraControllerBehaviour(DirectObject):\n     _instances = 0\n-    def __init__(self, camera, velocity=9, mouse_sensitivity=0.2, initial_pos=(0, 0, 114), showbase=None):\n+    def __init__(self, camera, velocity=9, mouse_sensitivity=0.2, initial_pos=(0, 0, 0), lockPitch = False, showbase=None):\n         self._camera = camera\n         self._velocity = velocity\n         self._mouse_sensitivity = mouse_sensitivity\n         self._keys = None\n         self._input_state = InputState()\n+        self._lockPitch = lockPitch\n         self._heading = 0.0\n         self._pitch = 0.0\n         self._yaw = 0.0\n         self._roll = 0.0\n@@ -174,10 +175,10 @@\n             self._yaw = self._yaw - (x - prev_x) * self._mouse_sensitivity\n             self._pitch = self._pitch - (y - prev_y) * self._mouse_sensitivity\n         self._prev_mouse = (x, y)\n \n-        # Clamp the pitch to prevent camera flipping over\n-        self._pitch = max(-89, min(89, self._pitch))\n+        # Clamp or lock the pitch to prevent camera flipping over\n+        self._pitch = 0 if self._lockPitch else max(-89, min(89, self._pitch))\n         \n         # Set the camera's orientation\n         self._showbase.camera.setHpr(self._yaw, self._pitch, self._roll)\n         \n@@ -360,8 +361,9 @@\n         self.EnemyDict['collision'] = {}\n         self.EnemyDict['ai_char'] = {}\n         self.EnemyDict['ai_behaviour'] = {}\n         self.EnemyDict['health'] = {}\n+\n class Game(ShowBase):\n     vfs = VirtualFileSystem.getGlobalPtr()\n     inaMenu = True\n     mouse_sensitivity = 0.5\n@@ -1359,9 +1361,9 @@\n         self.cTrav = CollisionTraverser()\n         self.pusher = CollisionHandlerPusher()\n \n         # Camera setup\n-        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, mouse_sensitivity=self.mouse_sensitivity)\n+        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, mouse_sensitivity=self.mouse_sensitivity, lockPitch=True)\n         self.cam_controller.setup(keys=self.keys)\n         self.cam_controller.disable()\n         camera_collision_node = CollisionNode('camera')\n         camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n"
                },
                {
                    "date": 1762882138397,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -80,9 +80,9 @@\n The default view is First Person. I will add a third person view later\n '''\n class CameraControllerBehaviour(DirectObject):\n     _instances = 0\n-    def __init__(self, camera, velocity=9, mouse_sensitivity=0.2, initial_pos=(0, 0, 0), lockPitch = False, showbase=None):\n+    def __init__(self, camera, velocity=9, gravity=-2, mouse_sensitivity=0.2, initial_pos=(0, 0, 0), lockPitch = False, showbase=None):\n         self._camera = camera\n         self._velocity = velocity\n         self._mouse_sensitivity = mouse_sensitivity\n         self._keys = None\n@@ -93,9 +93,9 @@\n         self._yaw = 0.0\n         self._roll = 0.0\n         self._prev_mouse = None\n         self._showbase = base if showbase is None else showbase\n-        self._gravity = LVector3(0, 0, -2)  # Set gravity vector pointing downward\n+        self._gravity = LVector3(0, 0, gravity)  # Set gravity vector pointing downward\n         self._instance = CameraControllerBehaviour._instances\n         CameraControllerBehaviour._instances += 1\n         self._camera.setPos(*initial_pos)\n         # Set the initial position of the camera\n@@ -1361,9 +1361,9 @@\n         self.cTrav = CollisionTraverser()\n         self.pusher = CollisionHandlerPusher()\n \n         # Camera setup\n-        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, mouse_sensitivity=self.mouse_sensitivity, lockPitch=True)\n+        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5, mouse_sensitivity=self.mouse_sensitivity, lockPitch=True)\n         self.cam_controller.setup(keys=self.keys)\n         self.cam_controller.disable()\n         camera_collision_node = CollisionNode('camera')\n         camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n"
                },
                {
                    "date": 1762882285390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1361,9 +1361,10 @@\n         self.cTrav = CollisionTraverser()\n         self.pusher = CollisionHandlerPusher()\n \n         # Camera setup\n-        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5, mouse_sensitivity=self.mouse_sensitivity, lockPitch=True)\n+        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5\n+                                                        , mouse_sensitivity=self.mouse_sensitivity, lockPitch=True)\n         self.cam_controller.setup(keys=self.keys)\n         self.cam_controller.disable()\n         camera_collision_node = CollisionNode('camera')\n         camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n"
                },
                {
                    "date": 1763243489065,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1398 @@\n+# /// script\n+# dependencies = [\n+#    \"panda3d\",\n+# ]\n+# ///\n+\n+'''\n+Game made by: Adeel Siddiqi and\n+This is\n+A game made for TSA Videogame design 2025-2026 \n+'''\n+__author__ = 'Adeel Siddiqi'\n+\n+import os\n+import random\n+from direct.actor.Actor import Actor\n+from direct.showbase.ShowBase import ShowBase\n+from direct.task import Task\n+from direct.showbase.DirectObject import DirectObject\n+from direct.controls.InputState import InputState\n+from direct.particles.ParticleEffect import ParticleEffect\n+import direct.gui.DirectGuiGlobals as DGG\n+from panda3d.ai import AIWorld, AICharacter\n+from panda3d.core import (\n+    PandaSystem,\n+    FrameBufferProperties, \n+    WindowProperties, \n+    GraphicsOutput,\n+    StringStream,\n+    AsyncFuture,\n+    LVecBase3f,\n+    LVecBase4f,\n+    LPoint3f, \n+    NodePath,\n+    TextNode, \n+    CollisionTraverser, \n+    CollisionNode, \n+    CollisionHandlerPusher, \n+    CollisionSphere, \n+    CollisionBox,\n+    LVector3, \n+    CollisionRay, \n+    BitMask32, \n+    CollisionHandlerQueue,\n+    loadPrcFileData,\n+    CollisionTraverser,\n+    BitMask32,\n+    TransparencyAttrib,\n+    CardMaker,\n+    SamplerState,\n+    VirtualFileSystem,\n+    Filename,\n+    DirectionalLight,\n+    AmbientLight,\n+    Camera,\n+    OrthographicLens,\n+    Texture,\n+    Vec3,\n+    Vec4,\n+    Shader,\n+    CollisionHandlerEvent\n+)\n+from direct.gui.DirectGui import (\n+    OnscreenImage,\n+    OnscreenText, \n+    DirectButton,\n+    DirectSlider,\n+    DirectScrolledFrame,\n+    DirectLabel,\n+    DirectFrame,\n+    DirectEntry,\n+    DirectWaitBar\n+)\n+\n+loadPrcFileData('', 'gl-version 4 1')\n+'''\n+The camera controller is a class that handles the movement and rotation of the camera in the game.\n+This is the core of the camera, and it is responsible for handling the input from the user and updating the camera accordingly.\n+The default values are set to 9 for velocity and 0.2 for mouse sensitivity, and the initial position of the camera is set to (-0.5, -12, 7.7).\n+The default view is First Person. I will add a third person view later\n+'''\n+class CameraControllerBehaviour(DirectObject):\n+    _instances = 0\n+    def __init__(self, camera, velocity=9, gravity=-2, mouse_sensitivity=0.2, initial_pos=(0, 0, 0), lockPitch = False, showbase=None):\n+        self._camera = camera\n+        self._velocity = velocity\n+        self._mouse_sensitivity = mouse_sensitivity\n+        self._keys = None\n+        self._input_state = InputState()\n+        self._lockPitch = lockPitch\n+        self._heading = 0.0\n+        self._pitch = 0.0\n+        self._yaw = 0.0\n+        self._roll = 0.0\n+        self._prev_mouse = None\n+        self._showbase = base if showbase is None else showbase\n+        self._gravity = LVector3(0, 0, gravity)  # Set gravity vector pointing downward\n+        self._instance = CameraControllerBehaviour._instances\n+        CameraControllerBehaviour._instances += 1\n+        self._camera.setPos(*initial_pos)\n+        # Set the initial position of the camera\n+\n+    def setup(self, keys={\n+        'w':\"forward\", \n+        's':\"backward\",\n+        'a':\"left\",\n+        'd':\"right\",\n+        'space':\"up\",\n+        'e':\"down\"\n+    }):\n+        self._keys = keys\n+        for key in self._keys:\n+            self._input_state.watchWithModifiers(self._keys[key], key)\n+\n+        self._showbase.disableMouse()\n+\n+        props = WindowProperties()\n+        props.setMouseMode(WindowProperties.MConfined)\n+        props.setCursorHidden(True)\n+\n+        self._showbase.win.requestProperties(props)\n+        \n+        self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n+    \n+    def rewatch(self, keys=None, mouse_sensitivity=.2):\n+        if keys is not None:\n+            self._keys = keys\n+        for key in self._keys:\n+            self._mouse_sensitivity = mouse_sensitivity\n+            self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n+            self._input_state.watchWithModifiers(self._keys[key], key)\n+    \n+    def destroy(self):\n+        self.disable()\n+        self._input_state.delete()\n+\n+        del self\n+\n+    @property\n+    def velocity(self):\n+        return self._velocity\n+\n+    @velocity.setter\n+    def velocity(self, velocity):\n+        self._velocity = velocity\n+    \n+    @property\n+    def mouse_sensitivity(self):\n+        return self._mouse_sensitivity\n+\n+    @mouse_sensitivity.setter\n+    def mouse_sensitivity(self, sensitivity):\n+        self._mouse_sensitivity = sensitivity\n+\n+    def disable(self):\n+        self._showbase.taskMgr.remove(\"UpdateCameraTask\" + str(self._instance))\n+\n+        props = WindowProperties()\n+        props.setCursorHidden(False)\n+\n+        self._showbase.win.requestProperties(props)\n+                \n+    def update(self, task):\n+        dt = globalClock.getDt()\n+        \n+        # Get mouse movement for rotation\n+        md = self._showbase.win.getPointer(0)\n+        x = md.getX()\n+        y = md.getY()\n+        #center_x = self._showbase.win.getXSize() // 2\n+        #center_y = self._showbase.win.getYSize() // 2\n+\n+        if self._prev_mouse is not None:\n+            prev_x, prev_y = self._prev_mouse\n+            self._yaw = self._yaw - (x - prev_x) * self._mouse_sensitivity\n+            self._pitch = self._pitch - (y - prev_y) * self._mouse_sensitivity\n+        self._prev_mouse = (x, y)\n+\n+        # Clamp or lock the pitch to prevent camera flipping over\n+        self._pitch = 0 if self._lockPitch else max(-89, min(89, self._pitch))\n+        \n+        # Set the camera's orientation\n+        self._showbase.camera.setHpr(self._yaw, self._pitch, self._roll)\n+        \n+        # Access the camera's lens and set the focal length\n+        lens = self._showbase.cam.node().getLens()\n+        lens.setFocalLength(0.25)\n+        \n+        # Calculate the position increment\n+        pos_increment = self._velocity * dt\n+        \n+        # Handle keyboard input for movement\n+        if  self._input_state.isSet('forward'):\n+            self._showbase.camera.setY(self._showbase.camera, pos_increment)\n+\n+        if  self._input_state.isSet('backward'):\n+            self._showbase.camera.setY(self._showbase.camera, -pos_increment)\n+\n+        if  self._input_state.isSet('left'):\n+            self._showbase.camera.setX(self._showbase.camera, -pos_increment)\n+\n+        if  self._input_state.isSet('right'):\n+            self._showbase.camera.setX(self._showbase.camera, pos_increment)\n+\n+        if  self._input_state.isSet('up'):\n+            self._showbase.camera.setZ(self._showbase.camera, pos_increment)\n+\n+        if  self._input_state.isSet('down'):\n+            self._showbase.camera.setZ(self._showbase.camera, -pos_increment)\n+        \n+        self.cam_pos = self._showbase.camera.getPos(self._showbase.render)\n+        # Apply gravity to the camera's position\n+        (self.cam_pos) += self._gravity * min(dt, 1/64.0)\n+        \n+        # Update the camera's position\n+        self._showbase.camera.setPos(self.cam_pos)\n+\n+        return Task.cont\n+\n+class EnemyController():\n+    def __init__(self, showbase=None):\n+        self.showbase = base if showbase is None else showbase\n+        self.EnemyModelDict = {}\n+        self.EnemyAIDotDict = {}\n+        self.EnemyCollisionDict = {}\n+        self.EnemyAICharDict = {}\n+        self.EnemyAIBehaviourDict = {}\n+        self.EnemyHealthDict = {}\n+        self.EnemyAnimControlDict = {}\n+        self.EnemyDict = {'model':self.EnemyModelDict,\n+                          'ai_dot':self.EnemyAIDotDict,\n+                          'collision':self.EnemyCollisionDict,\n+                          'ai_char':self.EnemyAICharDict,\n+                          'ai_behaviour':self.EnemyAIBehaviourDict,\n+                          'health':self.EnemyHealthDict,\n+                          }\n+        self.EnemyAIWorld = AIWorld(self.showbase.render)\n+        self.EnemyCollisionHandler = CollisionHandlerEvent()\n+        self.EnemyCollisionHandler.addInPattern('into-camera')\n+        self.showbase.accept(\"into-camera\",self.DamagePlayer)\n+\n+        #Because it will spam message in update\n+        self.Messagesent = False\n+        self.Run = True\n+        self._gravity = LVector3(0, 0, -2)\n+        self.EnemyCount = 0\n+        self.waveCount = 1\n+        self.Font = self.showbase.loader.loadFont('assets/fonts/propaganda.ttf')\n+    async def setup(self, modelpath, extraAnims, num, height, health, waves= 5, changePerWave=1):\n+        self.waveMethod = AsyncFuture()\n+        self.num = num\n+        self.Run = True\n+        # Creating the wave count\n+        self.WaveCounttext = OnscreenText(text=\"Wave: 1\", pos=(0,0.9), scale=0.1)\n+        self.WaveCounttext.setFont(self.Font)\n+        for i in range(waves):\n+            for j in range(self.num):\n+                if self.waveCount > i:\n+                    continue    \n+                if self.Run == False:\n+                    print('Break')\n+                    break\n+                # Set up models and make them loop animations\n+                self.EnemyModelDict['enemy' + str(j)] = Actor(modelpath, extraAnims if extraAnims is not None else None)\n+                self.EnemyModelDict['enemy' + str(j)].loop(self.EnemyModelDict['enemy' + str(j)].getAnimNames()[0])\n+                self.EnemyModelDict['enemy' + str(j)].reparentTo(self.showbase.render)\n+                self.EnemyModelDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n+                \n+                # Set up shaders, pretty custom\n+                game.shader(EnterNode=self.EnemyModelDict['enemy' + str(j)])\n+\n+                # We need to use a place holder model because the model will point at the user, so we just set position of the actual model\n+                self.EnemyAIDotDict['enemy' + str(j)] = self.showbase.loader.loadModel(\"assets/models/aidotupdater.bam\")\n+                self.EnemyAIDotDict['enemy' + str(j)].reparentTo(self.showbase.render)\n+                self.EnemyAIDotDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n+                \n+                # Collision\n+                self.EnemyCollisionDict['enemy' + str(j)] = CollisionNode('enemy' + str(j))\n+                self.EnemyCollisionDict['enemy' + str(j)].addSolid(CollisionBox(LPoint3f(2, 0, 9), 4,3,12))\n+                self.EnemyColliderPath = self.EnemyModelDict['enemy' + str(j)].attachNewNode(self.EnemyCollisionDict['enemy' + str(j)])\n+\n+                # AI\n+                self.EnemyAICharDict['enemy' + str(j)] = AICharacter('enemy' + str(j), self.EnemyAIDotDict['enemy' + str(j)], 100, .05, 5)\n+                self.EnemyAIWorld.addAiChar(self.EnemyAICharDict['enemy' + str(j)])\n+                self.EnemyAIBehaviourDict['enemy' + str(j)] = self.EnemyAICharDict['enemy' + str(j)].getAiBehaviors()\n+                self.EnemyAIBehaviourDict['enemy' + str(j)].pursue(self.showbase.camera)\n+                self.EnemyAIBehaviourDict['enemy' + str(j)].arrival(1)\n+                self.EnemyHealthDict['enemy' + str(j)] = health\n+\n+                # Add collisions\n+                self.showbase.cTrav.addCollider(self.EnemyColliderPath, self.EnemyCollisionHandler)\n+                game.pusher.addCollider(self.EnemyColliderPath, self.EnemyModelDict['enemy' + str(j)])\n+\n+                print(\"Enemy \" + str(j) + \" spawned\")\n+            if self.waveCount > i:\n+                continue\n+            else:\n+                await self.waveMethod\n+                print(\"Wave \" + str(i+2) + \" done\")\n+                self.waveMethod = AsyncFuture()\n+                self.WaveCounttext.setText(\"Wave: \" + str(i+2))\n+                self.waveCount += 1\n+                self.Messagesent = False\n+                self.num += changePerWave\n+        print('Done')\n+    def DamagePlayer(self, collision='nothing'):\n+        for i in range(len(self.EnemyDict['model'])+1):\n+            if 'enemy' + str(i) in str(collision) and 'camera' in str(collision):\n+                Game.PlayerHealth -= 1\n+    def EnemyHit(self, enemy):\n+        self.EnemyDict['health'][enemy.getName()] -= 1\n+        AnimControl = self.EnemyDict['model'][enemy.getName()].getAnimControl('hit')\n+        if AnimControl.isPlaying():\n+            return None\n+        else:\n+            AnimControl.setPlayRate(.5)\n+            self.EnemyDict['ai_behaviour'][enemy.getName()].pauseAi('all')\n+            self.EnemyDict['model'][enemy.getName()].play('hit')\n+    def MainUpdate(self):\n+        self.EnemyAIWorld.update()\n+        for enemy, aidot in zip(self.EnemyDict['model'].values(), self.EnemyDict['ai_dot'].values()):\n+            if not enemy.isEmpty() and not aidot.isEmpty():\n+                dt = globalClock.getDt()\n+                aidotpos = aidot.getPos()\n+                (aidotpos) += self._gravity * min(dt, 1/64.0)\n+                aidot.setPos(aidotpos)\n+                enemy.setH((aidot.getH())-180)\n+                enemy.setPos(aidotpos)\n+        for key in list(self.EnemyDict['health'].keys()):\n+            if self.EnemyDict['health'][key] <= 0:\n+                self.EnemyDict['model'][key].cleanup()\n+                self.EnemyDict['ai_dot'][key].removeNode()\n+                self.EnemyAIWorld.removeAiChar(key)\n+                self.EnemyDict['ai_behaviour'][key].removeAi(key)\n+                del self.EnemyDict['model'][key]\n+                del self.EnemyDict['ai_dot'][key]\n+                del self.EnemyDict['collision'][key]\n+                del self.EnemyDict['ai_char'][key]\n+                del self.EnemyDict['ai_behaviour'][key]\n+                del self.EnemyDict['health'][key]\n+                self.EnemyCount += 1\n+        \n+        if self.EnemyDict['model'] == {} and not self.Messagesent:\n+            self.Messagesent = True\n+            self.waveMethod.set_result(None)\n+        \n+        for enemy in list(self.EnemyDict['model'].values()):\n+            key = list(self.EnemyDict['model'].keys())[list(self.EnemyDict['model'].values()).index(enemy)]\n+            if not enemy.getAnimControl('hit').isPlaying() and self.EnemyDict['ai_behaviour'][key].behaviorStatus('pursue') == 'paused':\n+                self.EnemyDict['ai_behaviour'][key].resumeAi('all')\n+                enemy.loop('Walk')\n+    def destroy(self, KeepAI=False):\n+        self.Run = False\n+        self.WaveCounttext.destroy()\n+        if KeepAI:\n+            for enemy in list(self.EnemyDict['model'].keys()):\n+                self.EnemyAIWorld.removeAiChar(enemy)\n+                self.EnemyDict['ai_behaviour'][enemy].removeAi(enemy)\n+        self.EnemyDict['model'] = {}\n+        self.EnemyDict['ai_dot'] = {}\n+        self.EnemyDict['collision'] = {}\n+        self.EnemyDict['ai_char'] = {}\n+        self.EnemyDict['ai_behaviour'] = {}\n+        self.EnemyDict['health'] = {}\n+\n+class Game(ShowBase):\n+    vfs = VirtualFileSystem.getGlobalPtr()\n+    inaMenu = True\n+    mouse_sensitivity = 0.5\n+    PlayerHealth = 100\n+    sunDirection = -.2\n+    cycleOscillation = {'dawnOrDusk' : 'down', 'notQiyamah': .45}\n+    keys = {'w':\"forward\",\n+            's':\"backward\",\n+            'a':\"left\",\n+            'd':\"right\",\n+#            'space':\"up\",\n+#            'e':\"down\"\n+            }\n+    def textTypewriteAnimation(self, textPos, text, interval=0.05):\n+        textSplit = list(text)\n+        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft, font=self.loader.loadFont('assets/fonts/Micro5-Regular.ttf'))\n+        def cleanup(task):\n+            textNode.destroy()\n+        async def typewrite():\n+            for char in textSplit:\n+                textNode.setText(textNode.getText() + char)\n+                await Task.pause(interval)\n+            await Task.pause(1)\n+            return Task.done\n+        taskMgr.add(typewrite(), 'typewriteTask', uponDeath=cleanup)\n+    def dayNightCycle(self):\n+        steps = {'sunSpeed': 0.0005, 'rotationSpeed': 0.000375}\n+        self.cycleOscillation['notQiyamah'] -= steps['rotationSpeed']\n+        if self.cycleOscillation['dawnOrDusk'] == 'down':\n+            self.sunDirection += steps['sunSpeed']\n+            if self.sunDirection >= .3:\n+                self.cycleOscillation['dawnOrDusk'] = 'up'\n+                print(self.cycleOscillation['notQiyamah'])\n+                self.cycleOscillation['notQiyamah'] = 0.45\n+                steps['rotationSpeed'] = 0.000375\n+                print('switch up')\n+        elif self.cycleOscillation['dawnOrDusk'] == 'up':\n+            self.sunDirection -= steps['sunSpeed']\n+            if self.sunDirection <= -.3:\n+                self.cycleOscillation['dawnOrDusk'] = 'down'\n+                steps['rotationSpeed'] = 0.00017\n+                print(self.cycleOscillation['notQiyamah'])\n+                print('switch down')\n+        for models in self.currentModels:\n+            models.setShaderInput('light0_direction', (self.cycleOscillation['notQiyamah'], self.sunDirection, 0))\n+    def PlayerHUD(self):\n+        self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        frameSize=(-1.25, 1.25, -0.15, 0.15),\n+                                        pos=(0, 0, -.75))\n+        self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n+                                             frameSize=(-.125, .125, -0.125, 0.125),\n+                                             pos=(0, 0, -.75))\n+    def exportScene(self):\n+        file_name = input(\"Enter file name: \")\n+        ss = StringStream()\n+        self.render.ls(out=ss)\n+        with open(f\"scene_graph-{file_name}.txt\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(ss.get_data().decode(\"utf-8\"))\n+    def Death(self):\n+        self.CameraOperator()\n+        def LoadMainMenu(self):\n+            # remove task, reset\n+            self.deathFrame.destroy()\n+            self.btnMainMenu.destroy()\n+            self.PlayerHealth = 100\n+            self.clickSound.play()\n+            taskMgr.remove('Update')\n+            self.SaveProgress(reset=True)\n+            self.HealthBar.destroy()\n+            self.playButtonMethod = AsyncFuture()\n+            self.MainMenu()\n+            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n+            self.cam_controller.setup(keys=self.keys)\n+            self.cam_controller.disable()\n+            self.currentwave = 0\n+            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n+            for child in children_to_remove:\n+                if '__Actor_modelRoot' in child.getChildren():\n+                    child.cleanup()\n+                else:    \n+                    child.removeNode()\n+            taskMgr.add(self.loadScene())\n+        self.deathFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n+                                      frameSize=(-1.4, 1.4, -1, 1), \n+                                      pos=(0, 0, 0), \n+                                      scale=(1, 1, 1), \n+                                      text=\"You died\", \n+                                      text_font=self.Font,\n+                                      text_scale=0.3, \n+                                      text_pos=(0, .75), \n+                                      text_fg=(1, 0, 0, 1), \n+                                      text_align=TextNode.ACenter)\n+        self.btnMainMenu = DirectButton(\n+            parent=self.deathFrame,\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.4, 0.4, -0.08, 0.16),\n+            pos=LPoint3f(0, 0, -0.15),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Exit to Main Menu',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.075, 0.075),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=LoadMainMenu,\n+            extraArgs=[self],\n+        )\n+    def MouseIn(self):\n+#           if not self.inaMenu:\n+#            self.particleEffect.start(self.ak47, self.ak47)\n+        props = self.win.getProperties()\n+        # This is needed to for WebGL. If the window is not in focus, the mouse won't work, so we need to request focus\n+        if not self.inaMenu:\n+            if not props.getForeground() or not props.getCursorHidden() or props.getMouseMode() != WindowProperties.MConfined:\n+                self.win.requestProperties(WindowProperties(foreground=True, mouse_mode=WindowProperties.MConfined, cursor_hidden=True))\n+        \n+        # Create a CollisionRay for the mouse click\n+        ray_node = CollisionNode('click-ray')\n+        ray = CollisionRay()\n+        ray.setOrigin(0, 0, 0)  # Start at the camera\n+        ray.setDirection(0, 1, 0)  # Point forward\n+        ray_node.addSolid(ray)\n+\n+        # Attach the CollisionRay to the camera and set it to the right bitmasks\n+        self.ray_path = self.camera.attachNewNode(ray_node)\n+\n+        # Create a quene to store the collisions and add the CollisionRay to the CollisionTraverser\n+        self.collision_queue = CollisionHandlerQueue()\n+        self.cTrav.addCollider(self.ray_path, self.collision_queue)\n+        taskMgr.add(self.click, \"clickTask\")\n+    def MouseUp(self):\n+        self.particleEffect.disable()\n+        if hasattr(self, 'ray_path'):\n+            self.cTrav.removeCollider(self.ray_path)  # Remove collider from traverser\n+            self.ray_path.removeNode()  # Safely remove the ray\n+            self.collision_queue.clearEntries()\n+    def SaveProgress(self, reset=False):\n+        if reset:\n+            self.save_file = open(\"save.txt\", \"w\")\n+            self.save_file.write('LPoint3f(0, 0, 114)\\n')\n+            self.save_file.write(str(0))\n+            self.save_file.close()\n+        else:\n+            self.save_file = open(\"save.txt\", \"w\")\n+            self.save_file.write(str(self.camera.getPos()) + '\\n')\n+            self.save_file.close()\n+    def CameraOperator(self):\n+        # When this function is called, we check if we are in a menu, if we are then we watch our new keys\n+        # This is critical for one we don't setup the camera again, and two if the player decides to change controls\n+        # And then we switch our bool to false, as we are no longer in a menu, enabling clicking to focus the mouse\n+        if self.inaMenu:\n+            self.cam_controller.rewatch(self.keys, mouse_sensitivity=self.mouse_sensitivity)\n+            self.inaMenu = False\n+        \n+        # If we are not in a menu, then we disable the camera controller\n+        # And set our bool to true, critical because our click function refocuses the window\n+        else:\n+            self.cam_controller.disable()   \n+            self.inaMenu = True\n+        # Using our boolean we pass an if statement to effectively switch when oue mouse focuses on clicks\n+    def TutorialMenu(self):\n+        self.clickSound.play()\n+        self.paused = True\n+        self.currentTime = 0\n+        self.tutorialMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        frameSize=(-1.25, 1.25, -0.9, 0.9),\n+                                        pos=(0, 0, 0)\n+        )\n+        self.tutorialLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        frameSize=(-.3, .3, -0.1, 0.1),\n+                                        pos=(-.8, 0, .65),\n+                                        parent=self.tutorialMainFrame,\n+                                        relief=None,\n+                                        text=\"Tutorial\",\n+                                        text_fg=(0, 0, 0, 1),\n+                                        text_pos=(0, 0),\n+                                        text_scale=0.2,\n+                                        text_font=self.Font,\n+                                        text_align=TextNode.ACenter\n+        )\n+        self.tutorialVideoControlFrame = DirectFrame(parent=self.tutorialMainFrame,\n+                                                    frameColor=(0.3, 0.3, 0.3, 1),\n+                                                    frameSize=(-1, 1, -0.1, 0.1),\n+                                                    pos=(0, 0, -.7)\n+        )\n+        self.tutorialVideo = self.loader.loadTexture(r\"assets/audio/tutorial.mp4\")\n+        self.cm = CardMaker(\"card\")\n+        self.cm.setFrame(-.8, .8, -0.55, 0.55)\n+        self.cm.setUvRange(self.tutorialVideo)\n+        self.card = self.render2d.attachNewNode(self.cm.generate())\n+        self.card.setTexture(self.tutorialVideo)\n+        self.card.setPos(-0, 0, 0)\n+        self.card.reparentTo(self.tutorialMainFrame)\n+        self.tutorialAudio = self.loader.loadSfx(r\"assets/audio/tutorial.mp4\")\n+        self.tutorialVideo.synchronizeTo(self.tutorialAudio)\n+\n+        def PlayblackSliderMethod(self):\n+            self.tutorialAudio.stop()\n+            self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n+            self.currentTime = self.videoPlaybackSlider['value']\n+            self.paused = True\n+        def PausePlayMethod(self):\n+            if self.paused == True:\n+                #When clicked from pause to play\n+                self.paused = False\n+                self.videoPauseButton['image'] = 'assets/images/playIcon.png'\n+            else:\n+                self.paused = True\n+                self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n+            if self.tutorialAudio.status() == self.tutorialAudio.PLAYING:\n+                self.currentTime = self.tutorialAudio.getTime()\n+                self.tutorialAudio.stop()\n+            else:\n+                self.tutorialAudio.setTime(self.currentTime)\n+                self.tutorialAudio.play()\n+        \n+        self.videoPlaybackSlider = DirectSlider(range=(0, self.tutorialVideo.getVideoLength()),\n+                                  value=0, \n+                                  command=PlayblackSliderMethod, \n+                                  frameSize=(-.75, .75, -0.1, 0.1),\n+                                  frameColor=(0.8, 0.8, 0.8, 1),\n+                                  thumb_frameSize=(-.015, .015, -.015, .015),\n+                                  thumb_frameColor=(1, 0, 0, 1),\n+                                  pos=LPoint3f(0, 0, 0),\n+                                  orientation='horizontal', \n+                                  parent=self.tutorialVideoControlFrame,\n+                                  thumb_relief=DGG.FLAT,\n+                                  extraArgs=[self]\n+                                  )\n+        self.videoPauseButton = DirectButton(parent=self.tutorialVideoControlFrame,\n+                                             frameColor=(0.8, 0.8, 0.8, 1),\n+                                             frameSize=(-.05, .05, -0.05, 0.05),\n+                                             pos=LPoint3f(-.9, 0, 0),\n+                                             relief=None,\n+                                             image = 'assets/images/pauseIcon.png',\n+                                             image_pos=(0, 0, 0),\n+                                             image_scale=(0.1, 0.1, 0.1),\n+                                             command=PausePlayMethod,\n+                                             extraArgs=[self]\n+                                             )\n+        self.videoPauseButton.setTransparency(TransparencyAttrib.MAlpha)\n+    def OptionMenu(self):\n+        self.clickSound.play()\n+        self.mouseSettingsOpen = False\n+        self.keyboardSettingsOpen = False\n+        self.audioSettingsOpen = False\n+        self.aboutSettingsOpen = False\n+        \n+        def clear_menu():\n+            if self.mouseSettingsOpen:\n+                self.sensitivityFrame.destroy()\n+                self.sensitivityLabel.destroy()\n+                self.sensitivitySlider.destroy()\n+                self.mouseSettingsOpen = False  \n+            if self.keyboardSettingsOpen:\n+                self.forwardFrame.destroy()\n+                self.backwardFrame.destroy()\n+                self.leftFrame.destroy()\n+                self.rightFrame.destroy()\n+                self.forwardLabel.destroy()\n+                self.backwardLabel.destroy()\n+                self.leftLabel.destroy()\n+                self.rightLabel.destroy()\n+                self.forwardEntry.destroy()\n+                self.backwardEntry.destroy()\n+                self.leftEntry.destroy()\n+                self.rightEntry.destroy()\n+                self.btnSave.destroy()\n+                self.disclamerLabel.destroy()\n+                self.keyboardSettingsOpen = False\n+#            if self.audioSettingsOpen:\n+\n+            if self.aboutSettingsOpen:\n+                self.aboutLabel.destroy()\n+                self.gameAboutLabel.destroy()\n+                self.aboutSettingsOpen = False\n+        self.optionMenuBg = OnscreenImage(image='assets/images/optionMenuBg.png', pos=(0, 0, 0), scale=(.75, .5, 1))\n+        self.optionMenuBg.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.scrolledFrame = DirectScrolledFrame(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-.2, .6, -.8, .7),\n+            pos=LPoint3f(-0.05, 0, 0),\n+            canvasSize=(-.4, .4, -1, 1),\n+            verticalScroll_relief=None,\n+            horizontalScroll_relief=None,\n+        )\n+        self.scrolledFrame.setManageScrollBars()\n+        self.scrolledFrame.verticalScroll['frameSize'] = (-.01, .01, -.01, .01)\n+        self.scrolledFrame.verticalScroll['frameColor'] = (0.4, 0.4, 0.4, 1)\n+        self.scrolledFrame.verticalScroll['thumb_relief'] = DGG.FLAT\n+        self.scrolledFrame.verticalScroll['decButton_relief'] = None\n+        self.scrolledFrame.verticalScroll['incButton_relief'] = None\n+        self.scrolledFrame.horizontalScroll['frameSize'] = None\n+\n+        def MouseSettingMethod(self):\n+            self.sensitivityFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .85),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.sensitivityLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Mouse Sensitivity\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.1, 0, .875), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT\n+                                                )\n+            def changesensitivity():\n+                self.mouse_sensitivity = self.sensitivitySlider['value'] * .2\n+                print(self.sensitivitySlider['value'])      \n+            self.sensitivitySlider = DirectSlider(range=(0,2), \n+                                  value=1, \n+                                  command=changesensitivity, \n+                                  frameSize=(-.25, .25, -0.05, 0.05),\n+                                  frameColor=(0.8, 0.8, 0.8, 1),\n+                                  thumb_frameSize=(-.01, .01, -.01, .01),\n+                                  thumb_frameColor=(0.4, 0.4, 0.4, 1),\n+                                  pos=LPoint3f(-.05, 0, .8),\n+                                  orientation='horizontal', \n+                                  parent=self.scrolledFrame.getCanvas(),\n+                                  thumb_relief=DGG.FLAT\n+                                  )\n+            clear_menu()\n+            self.mouseSettingsOpen = True\n+        def KeyboardSettingMethod(self):\n+            def ForwardKeyMethod(key, self):\n+                self.forwardKey = key\n+            def BackwardKeyMethod(key, self):\n+                self.backwardKey = key\n+            def LeftKeyMethod(key, self):\n+                self.leftKey = key\n+            def RightKeyMethod(key, self):\n+                self.rightKey = key\n+            def SaveMethod(self):\n+                if not hasattr(self, 'forwardKey'):\n+                    self.forwardKey = 'w'\n+                if not hasattr(self, 'backwardKey'):\n+                    self.backwardKey = 's'\n+                if not hasattr(self, 'leftKey'):\n+                    self.leftKey = 'a'\n+                if not hasattr(self, 'rightKey'):\n+                    self.rightKey = 'd'\n+                self.keys = {\n+                    self.forwardKey: \"forward\",\n+                    self.backwardKey: \"backward\",\n+                    self.leftKey: \"left\",\n+                    self.rightKey: \"right\",\n+                    'space': \"up\",\n+                    'e': \"down\"\n+                }\n+            self.forwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Forward\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.2, 0, .875), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.backwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Backward\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.19, 0, .625), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.leftLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Left\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.25, 0, .375), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.rightLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Right\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.24, 0, .125), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.forwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .825),\n+                                                text_pos= (-0.1, -.015),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=ForwardKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='W'\n+                                                )\n+            self.backwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .575),\n+                                                text_pos= (-0.1, -.015),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=BackwardKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='S'\n+                                                )\n+            self.leftEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .325),\n+                                                text_pos= (-0.1, -.015),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=LeftKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='A'\n+                                                )\n+            self.rightEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .075),\n+                                                text_pos= (-0.1, -.015),    \n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=RightKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='D'\n+                                                )\n+            self.forwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .85),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.backwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .6),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.leftFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .35),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.rightFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .1),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.btnSave = DirectButton(\n+                frameColor=(0.2, 0.2, 0.2, 1),\n+                frameSize=(-0.09, 0.09, -0.025, 0.05),\n+                text='Save',\n+                text_scale=0.05,\n+                text_fg=(0.5, 0.5, 0.5, 1),\n+                pos=LPoint3f(-0.25, 0, -0.075),\n+                relief=1,\n+                parent=self.scrolledFrame.getCanvas(),\n+                command=SaveMethod,\n+                extraArgs=[self],\n+                sortOrder=2\n+            )\n+            self.disclamerLabel = DirectLabel(\n+                frameColor=(0.6, 0.6, 0.6, 1),\n+                text=\"*Press enter each key*\",\n+                text_scale=0.05,\n+                pos=LPoint3f(0, 0, -0.2),\n+                parent=self.scrolledFrame.getCanvas(),\n+                relief=None\n+            )\n+            clear_menu()\n+            self.keyboardSettingsOpen = True\n+        def AboutSettingMethod(self):\n+            self.aboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        text=\"About\",\n+                                        text_scale=0.1,\n+                                        pos=LPoint3f(-0.025, 0, 0.85),\n+                                        parent=self.scrolledFrame.getCanvas(),\n+                                        relief=None\n+                                        )\n+            self.gameAboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                            text= \"TSA Videogame Design 2025-2026 \\n '' is a  game developed by \\n  the team 1034-1 for the 2025-2026 \\n  \\\n+                                            Technology Student Association Competition for Video Game Design. \\n this is a  based on the theme of \\n\\\n+                                            We developed this game using \\n the Panda3D game engine \\n differing from Unity and Unreal as \\n it is a purely text edited engine\",\n+                                            text_scale=0.04,\n+                                            pos=LPoint3f(-0.04, 0, 0.3),\n+                                            parent=self.scrolledFrame.getCanvas(),\n+                                            relief=None\n+                                            )\n+            clear_menu()\n+            self.aboutSettingsOpen = True\n+        self.btnMouse = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.13),\n+            pos=LPoint3f(-0.37666, 0, 0.57666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/mouseIcon.png',\n+            image_scale = (.09, .09, .09),\n+            image_pos = (0, 0, 0.03),\n+            image_hpr = (0, 0, 0),\n+            command=MouseSettingMethod,\n+            extraArgs=[self],\n+        )\n+        self.btnMouse.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.btnKeyboard = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.376666, 0, 0.33666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/keyboardIcon.png',\n+            image_scale = (.09, .09, .09),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=KeyboardSettingMethod,\n+            extraArgs=[self],\n+        )\n+        self.btnKeyboard.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.btnAudioSet = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.37666, 0, 0.09666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/audioIcon.png',\n+            image_scale = (.07, .07, .07),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=self.playButtonMethod.set_result,\n+            extraArgs=[None],\n+        )\n+        self.btnAudioSet.setTransparency(TransparencyAttrib.MAlpha)\n+        \n+        self.btnAbout = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.37666, 0, -0.13666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/aboutIcon.png',\n+            image_scale = (.07, .07, .07),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=AboutSettingMethod,\n+            extraArgs=[self],\n+        )\n+        self.btnAbout.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        def close_menu():\n+            self.scrolledFrame.destroy()\n+            self.optionMenuBg.destroy()\n+            self.btnAbout.destroy()\n+            self.btnAudioSet.destroy()\n+            self.btnKeyboard.destroy()\n+            self.btnMouse.destroy()\n+            self.btnExit.destroy()\n+            clear_menu()\n+\n+        self.btnExit = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.5, 0, 0.75),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=None,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/exitIcon.png',\n+            image_scale = (.07, .07, .07),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=close_menu,\n+        )\n+        self.btnExit.setTransparency(TransparencyAttrib.MAlpha)\n+    def MainMenu(self):\n+        self.inaMenu = True\n+        self.mainMenuBackground = OnscreenImage(image='assets/images/mainMenuBackground.png', pos=(0, 0, 0), scale=(1.5, 1.5, 1.5))\n+        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.25, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n+        self.titleText.setFont(self.Font)\n+        self.btnPlay = DirectButton(\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.2, 0.2, -0.03, 0.06),\n+            pos=LPoint3f(0, 0, -0.1),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Play',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.05, 0.05),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=self.playButtonMethod.set_result,\n+            extraArgs=[None],\n+        )\n+\n+        self.btnOption= DirectButton(\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.3, 0.3, -0.03, 0.06),\n+            pos=LPoint3f(-1.2, 0, -0.87),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=None,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/optionIcon.png',\n+            image_scale = (.1, .1, .1),\n+            command=self.OptionMenu,\n+            extraArgs=[],\n+        )\n+        self.btnOption.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.btnTutorial= DirectButton(\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.3, 0.3, -0.03, 0.06),\n+            pos=LPoint3f(1.2, 0, -0.87),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=None,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/tutorialIcon.png',\n+            image_scale = (.1, .1, .1),\n+            command=self.TutorialMenu,\n+            extraArgs=[],\n+        )\n+        self.btnTutorial.setTransparency(TransparencyAttrib.MAlpha)\n+    def PauseMenu(self):\n+        self.clickSound.play()\n+        self.CameraOperator()\n+        def LoadMainMenu(self):\n+            #Keep AI here, dont remove .setup and reenter waves\n+            self.clickSound.play()\n+            taskMgr.remove('Update')\n+            self.SaveProgress()\n+            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n+            self.cam_controller.setup(keys=self.keys)\n+            self.cam_controller.disable()\n+            self.HealthBar.destroy()\n+            self.playButtonMethod = AsyncFuture()\n+            self.MainMenu()\n+            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n+            for child in children_to_remove:\n+                if '__Actor_modelRoot' in child.getName():\n+                    child.cleanup()\n+                else:    \n+                    child.removeNode()\n+            self.pauseFrame.destroy()\n+            self.btnMainMenu.destroy()\n+            self.btnResume.destroy()\n+            taskMgr.add(self.loadScene())\n+        def Resume(self):\n+            self.clickSound.play()\n+            self.pauseFrame.destroy()\n+            self.btnMainMenu.destroy()\n+            self.btnResume.destroy()\n+            self.CameraOperator()\n+        self.pauseFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                    frameSize=(-.5, .5, -0.3, 0.35),\n+                                    pos=LPoint3f(0, 0, 0),\n+                                    hpr=LVecBase3f(0, 0, 0),\n+                                    relief=DGG.FLAT,\n+                                    scale=LVecBase3f(1, 1, 1))\n+        self.btnMainMenu = DirectButton(\n+            parent=self.pauseFrame,\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.4, 0.4, -0.08, 0.16),\n+            pos=LPoint3f(0, 0, -0.15),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Save & Exit',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.1, 0.1),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=LoadMainMenu,\n+            extraArgs=[self],\n+        )\n+        self.btnResume = DirectButton(\n+            parent=self.pauseFrame,\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.4, 0.4, -0.08, 0.16),\n+            pos=LPoint3f(0, 0, 0.15),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Resume',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.1, 0.1),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=Resume,\n+            extraArgs=[self],\n+        )\n+    # This function is called when the mouse is clicked, calling a function based on what is clicked in game\n+    async def click(self, task):\n+        # Perform collision traversal\n+        self.cTrav.traverse(self.render)\n+        \n+        try:\n+            # Process collisions\n+            num_collisions = self.collision_queue.getNumEntries()\n+\n+            if num_collisions > 1:\n+                self.collision_queue.sortEntries()\n+                entry = self.collision_queue.getEntry(1)  # Get the closest collision\n+                hit_node = entry.getIntoNode()\n+                # Check if the hit node is the model that is supposed to be clicked using something like this:\n+#                for enemy in list(self.enemy.EnemyDict['collision'].values()):\n+#                    if hit_node.getName() == enemy.getName():\n+#                        self.enemyController.EnemyHit(enemy)\n+#                        await Task.pause(.2)\n+        except AssertionError as e:\n+            print(\"AssertionError occurred during collision processing.\")\n+            print(e)\n+        except KeyError as e:\n+            print(\"KeyError occurred during collision processing.\")\n+            pass\n+        return Task.cont\n+    \n+    def shader(self, nodes = None, EnterNode = None):\n+        self.currentModels = []\n+        if not hasattr(self, 'Shader_setup'):\n+            self.Shader_setup = None\n+            print(PandaSystem.getPlatform())\n+            if PandaSystem.getPlatform() == 'win_amd64' or PandaSystem.getPlatform() == 'osx_aarch64':\n+                shaders = [f\"{os.path.dirname(__file__)}/assets/shaders/Shader.vert\", f\"{os.path.dirname(__file__)}/assets/shaders/Shader.frag\"]\n+                patchedShaders = []\n+                for file in shaders:    \n+                    with open(file, 'r') as file:\n+                        code = file.read()\n+                        code = code.replace(\"#version 300 es\", \"#version 330\")\n+                        code = \"\\n\".join(\n+                            line for line in code.splitlines()\n+                            if not line.strip().startswith(\"precision\")\n+                        )\n+                        patchedShaders.append(code)\n+                self.Shader = Shader.make(Shader.SL_GLSL, patchedShaders[0], patchedShaders[1])\n+            else:\n+                self.Shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/Shader.vert\", \"assets/shaders/Shader.frag\")\n+            shadow_buffer = self.win.make_texture_buffer(\"ShadowBuffer\", 1024, 1024)\n+            shadow_buffer.set_sort(-100)\n+            shadow_buffer.set_clear_color((1, 1, 1, 1))\n+            self.shadow_map = shadow_buffer.get_texture()\n+            self.shadow_map.set_minfilter(SamplerState.FT_shadow)\n+            self.shadow_map.set_magfilter(SamplerState.FT_shadow)\n+\n+            self.shadow_cam = self.make_camera(shadow_buffer, lens=OrthographicLens())\n+            self.shadow_cam.reparent_to(self.sunLightNP)\n+\n+            shadow_scene = self.render.copy_to(NodePath(\"shadow_scene\"))\n+            shadow_scene.set_shader(Shader.load(Shader.SL_GLSL, \"assets/shaders/shadow_depth.vert\", \"assets/shaders/shadow_depth.frag\"))\n+            self.shadow_cam.node().set_scene(shadow_scene)\n+        if EnterNode == None:\n+            for node in nodes:\n+                self.currentModels.append(node)\n+                node.setShader(self.Shader)\n+                node.setShaderInput(\"shadowMap\", self.shadow_map)\n+                node.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n+                node.setShaderInput(\"diffuseTex\", node.find_texture(\"*\"))\n+                node.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n+                node.setShaderInput(\"light0_color\", Vec3(.5, .75, 0.85))\n+                node.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n+                node.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n+                node.setShaderInput(\"material_shininess\", 10.0)\n+                node.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n+                node.setShaderInput(\"cameraPos\", self.camera.getPos(self.render))\n+\n+        else:\n+            self.currentModels.append(EnterNode)\n+            EnterNode.setShader(self.Shader)\n+            EnterNode.setShaderInput(\"shadowMap\", self.shadow_map)\n+            EnterNode.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n+            EnterNode.setShaderInput(\"diffuseTex\", EnterNode.find_texture(\"*\"))\n+            EnterNode.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n+            EnterNode.setShaderInput(\"light0_color\", Vec3(.75, .75, 0.5))\n+            EnterNode.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n+            EnterNode.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n+            EnterNode.setShaderInput(\"material_shininess\", 15.0)\n+            EnterNode.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n+    # This function loads the models in the background, reducing lag and improving performance\n+    async def loadScene(self):\n+\n+        # in case of death, we need to reload the bool\n+        if hasattr(self, '_player_died'):\n+            delattr(self, '_player_died')  # Remove self._player_died\n+        \n+        if hasattr(self, '_player_won'):\n+            delattr(self, '_player_won')  # Remove self._player_won\n+            \n+        with open(f'{os.path.dirname(__file__)}/save.txt', 'r') as f:\n+            line = f.readline()\n+            line = line.replace('LPoint3f(', '').replace(')', '')\n+            x, y, z = map(float, line.split(','))\n+        \n+\n+        self.camera.setPos(x, y, z)\n+\n+        # Load the models in the background, each time suspending this\n+        # method until they are done\n+        self.worldCollisionModel = await self.loader.loadModel(\"assets/models/worldTriangles.bam\", blocking=False)\n+        self.worldVisibleModel = await self.loader.loadModel(\"assets/models/worldVisible.bam\", blocking=False)\n+\n+        # Create a background for the world\n+        \n+        self.world_bg = await self.loader.loadModel(\"assets/models/skybox.bam\",blocking=False)\n+        self.world_bg.reparent_to(self.render)\n+        self.world_bg.set_scale(2500)\n+\n+        world_bg_texture = self.loader.loadTexture(\"assets/images/world_bg.png\")\n+        world_bg_texture.set_minfilter(SamplerState.FT_linear)\n+        world_bg_texture.set_magfilter(SamplerState.FT_linear)\n+        world_bg_texture.set_wrap_u(SamplerState.WM_repeat)\n+        world_bg_texture.set_wrap_v(SamplerState.WM_mirror)\n+        world_bg_texture.set_anisotropic_degree(200)\n+        self.world_bg.set_texture(world_bg_texture)\n+        world_bg_shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/world_bg.vert.glsl\", \"assets/shaders/world_bg.frag.glsl\")\n+        self.world_bg.set_shader(world_bg_shader) \n+        \n+        # Create a collision node for the world\n+        self.world_collision_node = self.worldCollisionModel.find(\"**/+CollisionNode\")\n+        self.worldCollisionModel.hide()\n+        self.cTrav.addCollider(self.world_collision_node, self.pusher)\n+        self.pusher.addCollider(self.world_collision_node, self.worldCollisionModel)\n+\n+        # Set up Lighting System\n+        self.sunLight = DirectionalLight('directionalLight')\n+        self.sunLight.setShadowCaster(True, 16384, 16384)\n+        self.sunLightNP = self.render.attachNewNode(self.sunLight)\n+        self.sunLightNP.setHpr(45, 45, 0)\n+        self.sunLight.setColor((1.5, 1.5, 1.5, 1))\n+        \n+        self.sunModel = await self.loader.loadModel(\"assets/models/sun.bam\", blocking=False)\n+        self.sunModel.setPos(150, -150, 200)\n+\n+        print(self.sunModel)\n+        ambientLight = AmbientLight('ambientLight')\n+        ambientLight.setColor((0.1, 0.1, 0.1, 1))\n+        ambientLightNP = self.render.attachNewNode(ambientLight)\n+        \n+        # Set the shaders\n+        ''' Most of the time this is very custom. Though there is a pipeline that can be used\n+            Most of this stuff can be recycled\n+        '''\n+        self.shader([self.sunModel, self.worldVisibleModel])\n+        \n+        # Wait for the player to start the game\n+        await self.playButtonMethod\n+        self.clickSound.play()\n+\n+        # Remove the main menu\n+        self.titleText.destroy()\n+        self.btnPlay.destroy()\n+        self.mainMenuBackground.destroy()\n+        self.btnOption.destroy()\n+        self.btnTutorial.destroy()\n+\n+        # Create a loading screen\n+        Loading_text = OnscreenText(\"Loading\")\n+\n+        self.HealthBar = DirectWaitBar(text=\"Hull\", value=100, pos=(-.85, -15, -.7))\n+        self.HealthBar['barColor'] = (0, 2, 0, 2)\n+        self.HealthBar['text_scale'] = .05\n+        self.HealthBar['frameSize'] = (-.35, .35, -.035, .02)\n+        self.HealthBar['barRelief']= DGG.SUNKEN\n+\n+        self.HullBar = DirectWaitBar(text=\"Fuel\", value=100, pos=(-.85, -1, -.8))\n+        self.HullBar['barColor'] = (2, .5, 0, 2)\n+        self.HullBar['text_scale'] = .05\n+        self.HullBar['frameSize'] = (-.35, .35, -.035, .02)\n+        self.HullBar['barRelief']= DGG.SUNKEN\n+\n+        # Reparent the models to the render, making the world, and set the lights\n+        self.worldCollisionModel.reparentTo(self.render)\n+        self.worldVisibleModel.reparentTo(self.render)\n+        self.render.setLight(self.sunLightNP)\n+        self.render.setLight(ambientLightNP)\n+        self.sunModel.reparentTo(self.render)\n+        \n+        # Add HUD\n+        self.PlayerHUD()\n+        \n+        # Add a Pause Menu\n+        pausetext = OnscreenText(\"To Pause press P\", pos=(-1.14, 0.95), scale=0.05, fg=(0, 0, 0, 1), align=TextNode.ACenter)\n+        self.accept('p', self.PauseMenu)\n+\n+        # initialize the camera controller\n+        self.CameraOperator()\n+        \n+        self.particleEffect = ParticleEffect()\n+        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n+        self.particleEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/gunfiring.ptf\")\n+        self.particleEffect.clearShader()\n+        # Start the update cycle\n+        taskMgr.add(self.Update, \"Update\")        \n+        self.accept('mouse1-up', self.MouseUp)\n+        Loading_text.destroy() \n+\n+    # The Update cycle, this function should be used to update positions and anything that needs to be updated\n+    def Update(self, task):\n+        camera_forward = self.camera.getQuat(self.render).getForward()\n+        camera_up = self.camera.getQuat(self.render).getUp()\n+        camera_right = self.camera.getQuat(self.render).getRight()\n+        camera_position = self.camera.getPos(self.render)\n+\n+        self.dayNightCycle()\n+#            ak47_position = (\n+#                camera_position +\n+#                camera_forward * 2.67 -  # Forward by 1.0 units\n+#                camera_up * 1 +       # Downward by 0.5 units\n+#                camera_right * 0.8      # Rightward by 0.3 units\n+#            )\n+#            self.ak47.setPos(ak47_position)\n+#            self.ak47.setHpr(self.camera.getH(), 0, 90)\n+        \n+        self.worldCollisionModel.setPos(0, 0, 0)\n+        \n+        self.HealthBar['value'] = self.PlayerHealth\n+\n+        if self.PlayerHealth < 0 and not hasattr(self, '_player_died'):\n+            self._player_died = None\n+            self.Death()\n+        \n+        if not True:\n+            self._player_won = None\n+            self.CameraOperator()\n+            def LoadMainMenu(self):\n+                self.clickSound.play()\n+                taskMgr.remove('Update')\n+                self.SaveProgress(reset=True)\n+                self.HealthBar.destroy()\n+                self.playButtonMethod = AsyncFuture()\n+                self.MainMenu()\n+                self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n+                self.cam_controller.setup(keys=self.keys)\n+                self.cam_controller.disable()\n+                self.currentwave = 0\n+                children_to_remove = [child for child in self.render.getChildren() if child not in self.camera]\n+                for child in children_to_remove:\n+                    if '__Actor_modelRoot' in child.getChildren():\n+                        child.cleanup()\n+                    else:    \n+                        child.removeNode()\n+                self.winFrame.destroy()\n+                self.btnMainMenu.destroy()\n+                taskMgr.add(self.loadScene())\n+            self.winFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n+                                        frameSize=(-1.4, 1.4, -1., 1), \n+                                        pos=(0, 0, 0), \n+                                        scale=(1, 1, 1), \n+                                        text=\"You Won!\", \n+                                        text_font=self.Font,\n+                                        text_scale=0.5, \n+                                        text_pos=(0, .25), \n+                                        text_fg=(0, 0, 1, 1), \n+                                        text_align=TextNode.ACenter)\n+            self.btnMainMenu = DirectButton(\n+                parent=self.winFrame,\n+                frameColor=(0.15, 0.15, 0.15, 1),\n+                frameSize=(-0.4, 0.4, -0.08, 0.16),\n+                pos=LPoint3f(0, 0, -0.15),\n+                hpr=LVecBase3f(0, 0, 0),\n+                relief=1,\n+                scale=LVecBase3f(1, 1, 1),\n+                text='Exit to Main Menu',\n+                text_align=TextNode.A_center,\n+                text_scale=(0.075, 0.075),\n+                text_pos=(0, 0),\n+                text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+                text_bg=LVecBase4f(0, 0, 0, 0),\n+                command=LoadMainMenu,\n+                extraArgs=[self],\n+            )\n+        return Task.cont\n+    def __init__(self):\n+        super().__init__()\n+        \n+        self.currentwave = 0\n+\n+        # Defining the Traverser, the task that checks for collisions, and the pusher, the task that pushes objects when it collides\n+        # The Traverser reports to the pusher, we also need to tell Panda3d which objects respond to collisions\n+        self.cTrav = CollisionTraverser()\n+        self.pusher = CollisionHandlerPusher()\n+\n+        # Camera setup\n+        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5\n+                                                        ,mouse_sensitivity=self.mouse_sensitivity\n+                                                        ,lockPitch=True)\n+        self.cam_controller.setup(keys=self.keys)\n+        self.cam_controller.disable()\n+        camera_collision_node = CollisionNode('camera')\n+        camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n+        camera_collision_node_path = self.camera.attachNewNode(camera_collision_node)\n+        camera_collision_node_path.setCollideMask(BitMask32.bit(2))\n+  \n+        # Add the collision nodes to the traverser. This is how we tell Panda3d which objects respond to collisions  \n+        self.cTrav.addCollider(camera_collision_node_path, self.pusher) \n+        self.pusher.addCollider(camera_collision_node_path, self.camera)\n+\n+        #   We load the tasks in the background to reduce lag\n+        self.playButtonMethod = AsyncFuture()\n+        taskMgr.add(self.loadScene())\n+        \n+        #  Tell Panda3d to listen for mouse clicks\n+        self.accept('mouse1', self.MouseIn)\n+        self.Font = self.loader.loadFont('assets/fonts/propaganda.ttf')\n+        self.Font.setPixelsPerUnit(120)\n+\n+        self.clickSound = self.loader.loadSfx('assets/audio/click.wav')\n+\n+        self.enableParticles()\n+\n+#        self.messenger.toggleVerbose()\n+        self.accept('x', self.exportScene)\n+\n+        # Open the main menu\n+        self.MainMenu()\n+game = Game()\n+base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763438552378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -473,10 +473,8 @@\n             command=LoadMainMenu,\n             extraArgs=[self],\n         )\n     def MouseIn(self):\n-#           if not self.inaMenu:\n-#            self.particleEffect.start(self.ak47, self.ak47)\n         props = self.win.getProperties()\n         # This is needed to for WebGL. If the window is not in focus, the mouse won't work, so we need to request focus\n         if not self.inaMenu:\n             if not props.getForeground() or not props.getCursorHidden() or props.getMouseMode() != WindowProperties.MConfined:\n@@ -495,14 +493,17 @@\n         # Create a quene to store the collisions and add the CollisionRay to the CollisionTraverser\n         self.collision_queue = CollisionHandlerQueue()\n         self.cTrav.addCollider(self.ray_path, self.collision_queue)\n         taskMgr.add(self.click, \"clickTask\")\n+\n+        self.ballDown = True\n     def MouseUp(self):\n-        self.particleEffect.disable()\n+        taskMgr.remove(\"clickTask\")\n         if hasattr(self, 'ray_path'):\n             self.cTrav.removeCollider(self.ray_path)  # Remove collider from traverser\n             self.ray_path.removeNode()  # Safely remove the ray\n             self.collision_queue.clearEntries()\n+        self.ballDown = False\n     def SaveProgress(self, reset=False):\n         if reset:\n             self.save_file = open(\"save.txt\", \"w\")\n             self.save_file.write('LPoint3f(0, 0, 114)\\n')\n@@ -1074,9 +1075,9 @@\n     # This function is called when the mouse is clicked, calling a function based on what is clicked in game\n     async def click(self, task):\n         # Perform collision traversal\n         self.cTrav.traverse(self.render)\n-        \n+        print(self.ball.getPos())\n         try:\n             # Process collisions\n             num_collisions = self.collision_queue.getNumEntries()\n \n@@ -1095,9 +1096,8 @@\n         except KeyError as e:\n             print(\"KeyError occurred during collision processing.\")\n             pass\n         return Task.cont\n-    \n     def shader(self, nodes = None, EnterNode = None):\n         self.currentModels = []\n         if not hasattr(self, 'Shader_setup'):\n             self.Shader_setup = None\n@@ -1265,12 +1265,19 @@\n \n         # initialize the camera controller\n         self.CameraOperator()\n         \n-        self.particleEffect = ParticleEffect()\n+        self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n-        self.particleEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/gunfiring.ptf\")\n-        self.particleEffect.clearShader()\n+        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n+        self.researchLocationEffect.clearShader()\n+        \n+        self.researchLocationEffect.start(parent=self.render, renderParent=self.render)\n+        self.researchLocationEffect.setPos(0, 0, 250)\n+\n+        self.ball = self.loader.loadModel(\"assets/models/sun.bam\")\n+        self.ball.reparentTo(self.render)\n+        self.ballDown = False\n         # Start the update cycle\n         taskMgr.add(self.Update, \"Update\")        \n         self.accept('mouse1-up', self.MouseUp)\n         Loading_text.destroy() \n@@ -1349,8 +1356,13 @@\n                 text_bg=LVecBase4f(0, 0, 0, 0),\n                 command=LoadMainMenu,\n                 extraArgs=[self],\n             )\n+        if not self.ballDown:\n+            pos = self.camera.getPos(self.render)\n+            forward = self.camera.getQuat(self.render).getForward()\n+            self.ball.setPos(pos + forward * 50)\n+\n         return Task.cont\n     def __init__(self):\n         super().__init__()\n         \n@@ -1363,9 +1375,9 @@\n \n         # Camera setup\n         self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5\n                                                         ,mouse_sensitivity=self.mouse_sensitivity\n-                                                        ,lockPitch=True)\n+                                                        ,lockPitch=False)\n         self.cam_controller.setup(keys=self.keys)\n         self.cam_controller.disable()\n         camera_collision_node = CollisionNode('camera')\n         camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n@@ -1384,9 +1396,9 @@\n         self.accept('mouse1', self.MouseIn)\n         self.Font = self.loader.loadFont('assets/fonts/propaganda.ttf')\n         self.Font.setPixelsPerUnit(120)\n \n-        self.clickSound = self.loader.loadSfx('assets/audio/click.wav')\n+        self.clickSound = self.loader.loadSfx('assets/audio/click.ogg')\n \n         self.enableParticles()\n \n #        self.messenger.toggleVerbose()\n@@ -1394,1402 +1406,5 @@\n \n         # Open the main menu\n         self.MainMenu()\n game = Game()\n-base.run()\n-# /// script\n-# dependencies = [\n-#    \"panda3d\",\n-# ]\n-# ///\n-\n-'''\n-Game made by: Adeel Siddiqi and\n-This is\n-A game made for TSA Videogame design 2025-2026 \n-'''\n-__author__ = 'Adeel Siddiqi'\n-\n-import os\n-import random\n-from direct.actor.Actor import Actor\n-from direct.showbase.ShowBase import ShowBase\n-from direct.task import Task\n-from direct.showbase.DirectObject import DirectObject\n-from direct.controls.InputState import InputState\n-from direct.particles.ParticleEffect import ParticleEffect\n-import direct.gui.DirectGuiGlobals as DGG\n-from panda3d.ai import AIWorld, AICharacter\n-from panda3d.core import (\n-    PandaSystem,\n-    FrameBufferProperties, \n-    WindowProperties, \n-    GraphicsOutput,\n-    StringStream,\n-    AsyncFuture,\n-    LVecBase3f,\n-    LVecBase4f,\n-    LPoint3f, \n-    NodePath,\n-    TextNode, \n-    CollisionTraverser, \n-    CollisionNode, \n-    CollisionHandlerPusher, \n-    CollisionSphere, \n-    CollisionBox,\n-    LVector3, \n-    CollisionRay, \n-    BitMask32, \n-    CollisionHandlerQueue,\n-    loadPrcFileData,\n-    CollisionTraverser,\n-    BitMask32,\n-    TransparencyAttrib,\n-    CardMaker,\n-    SamplerState,\n-    VirtualFileSystem,\n-    Filename,\n-    DirectionalLight,\n-    AmbientLight,\n-    Camera,\n-    OrthographicLens,\n-    Texture,\n-    Vec3,\n-    Vec4,\n-    Shader,\n-    CollisionHandlerEvent\n-)\n-from direct.gui.DirectGui import (\n-    OnscreenImage,\n-    OnscreenText, \n-    DirectButton,\n-    DirectSlider,\n-    DirectScrolledFrame,\n-    DirectLabel,\n-    DirectFrame,\n-    DirectEntry,\n-    DirectWaitBar\n-)\n-\n-loadPrcFileData('', 'gl-version 4 1')\n-'''\n-The camera controller is a class that handles the movement and rotation of the camera in the game.\n-This is the core of the camera, and it is responsible for handling the input from the user and updating the camera accordingly.\n-The default values are set to 9 for velocity and 0.2 for mouse sensitivity, and the initial position of the camera is set to (-0.5, -12, 7.7).\n-The default view is First Person. I will add a third person view later\n-'''\n-class CameraControllerBehaviour(DirectObject):\n-    _instances = 0\n-    def __init__(self, camera, velocity=9, gravity=-2, mouse_sensitivity=0.2, initial_pos=(0, 0, 0), lockPitch = False, showbase=None):\n-        self._camera = camera\n-        self._velocity = velocity\n-        self._mouse_sensitivity = mouse_sensitivity\n-        self._keys = None\n-        self._input_state = InputState()\n-        self._lockPitch = lockPitch\n-        self._heading = 0.0\n-        self._pitch = 0.0\n-        self._yaw = 0.0\n-        self._roll = 0.0\n-        self._prev_mouse = None\n-        self._showbase = base if showbase is None else showbase\n-        self._gravity = LVector3(0, 0, gravity)  # Set gravity vector pointing downward\n-        self._instance = CameraControllerBehaviour._instances\n-        CameraControllerBehaviour._instances += 1\n-        self._camera.setPos(*initial_pos)\n-        # Set the initial position of the camera\n-\n-    def setup(self, keys={\n-        'w':\"forward\", \n-        's':\"backward\",\n-        'a':\"left\",\n-        'd':\"right\",\n-        'space':\"up\",\n-        'e':\"down\"\n-    }):\n-        self._keys = keys\n-        for key in self._keys:\n-            self._input_state.watchWithModifiers(self._keys[key], key)\n-\n-        self._showbase.disableMouse()\n-\n-        props = WindowProperties()\n-        props.setMouseMode(WindowProperties.MConfined)\n-        props.setCursorHidden(True)\n-\n-        self._showbase.win.requestProperties(props)\n-        \n-        self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n-    \n-    def rewatch(self, keys=None, mouse_sensitivity=.2):\n-        if keys is not None:\n-            self._keys = keys\n-        for key in self._keys:\n-            self._mouse_sensitivity = mouse_sensitivity\n-            self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n-            self._input_state.watchWithModifiers(self._keys[key], key)\n-    \n-    def destroy(self):\n-        self.disable()\n-        self._input_state.delete()\n-\n-        del self\n-\n-    @property\n-    def velocity(self):\n-        return self._velocity\n-\n-    @velocity.setter\n-    def velocity(self, velocity):\n-        self._velocity = velocity\n-    \n-    @property\n-    def mouse_sensitivity(self):\n-        return self._mouse_sensitivity\n-\n-    @mouse_sensitivity.setter\n-    def mouse_sensitivity(self, sensitivity):\n-        self._mouse_sensitivity = sensitivity\n-\n-    def disable(self):\n-        self._showbase.taskMgr.remove(\"UpdateCameraTask\" + str(self._instance))\n-\n-        props = WindowProperties()\n-        props.setCursorHidden(False)\n-\n-        self._showbase.win.requestProperties(props)\n-                \n-    def update(self, task):\n-        dt = globalClock.getDt()\n-        \n-        # Get mouse movement for rotation\n-        md = self._showbase.win.getPointer(0)\n-        x = md.getX()\n-        y = md.getY()\n-        #center_x = self._showbase.win.getXSize() // 2\n-        #center_y = self._showbase.win.getYSize() // 2\n-\n-        if self._prev_mouse is not None:\n-            prev_x, prev_y = self._prev_mouse\n-            self._yaw = self._yaw - (x - prev_x) * self._mouse_sensitivity\n-            self._pitch = self._pitch - (y - prev_y) * self._mouse_sensitivity\n-        self._prev_mouse = (x, y)\n-\n-        # Clamp or lock the pitch to prevent camera flipping over\n-        self._pitch = 0 if self._lockPitch else max(-89, min(89, self._pitch))\n-        \n-        # Set the camera's orientation\n-        self._showbase.camera.setHpr(self._yaw, self._pitch, self._roll)\n-        \n-        # Access the camera's lens and set the focal length\n-        lens = self._showbase.cam.node().getLens()\n-        lens.setFocalLength(0.25)\n-        \n-        # Calculate the position increment\n-        pos_increment = self._velocity * dt\n-        \n-        # Handle keyboard input for movement\n-        if  self._input_state.isSet('forward'):\n-            self._showbase.camera.setY(self._showbase.camera, pos_increment)\n-\n-        if  self._input_state.isSet('backward'):\n-            self._showbase.camera.setY(self._showbase.camera, -pos_increment)\n-\n-        if  self._input_state.isSet('left'):\n-            self._showbase.camera.setX(self._showbase.camera, -pos_increment)\n-\n-        if  self._input_state.isSet('right'):\n-            self._showbase.camera.setX(self._showbase.camera, pos_increment)\n-\n-        if  self._input_state.isSet('up'):\n-            self._showbase.camera.setZ(self._showbase.camera, pos_increment)\n-\n-        if  self._input_state.isSet('down'):\n-            self._showbase.camera.setZ(self._showbase.camera, -pos_increment)\n-        \n-        self.cam_pos = self._showbase.camera.getPos(self._showbase.render)\n-        # Apply gravity to the camera's position\n-        (self.cam_pos) += self._gravity * min(dt, 1/64.0)\n-        \n-        # Update the camera's position\n-        self._showbase.camera.setPos(self.cam_pos)\n-\n-        return Task.cont\n-\n-class EnemyController():\n-    def __init__(self, showbase=None):\n-        self.showbase = base if showbase is None else showbase\n-        self.EnemyModelDict = {}\n-        self.EnemyAIDotDict = {}\n-        self.EnemyCollisionDict = {}\n-        self.EnemyAICharDict = {}\n-        self.EnemyAIBehaviourDict = {}\n-        self.EnemyHealthDict = {}\n-        self.EnemyAnimControlDict = {}\n-        self.EnemyDict = {'model':self.EnemyModelDict,\n-                          'ai_dot':self.EnemyAIDotDict,\n-                          'collision':self.EnemyCollisionDict,\n-                          'ai_char':self.EnemyAICharDict,\n-                          'ai_behaviour':self.EnemyAIBehaviourDict,\n-                          'health':self.EnemyHealthDict,\n-                          }\n-        self.EnemyAIWorld = AIWorld(self.showbase.render)\n-        self.EnemyCollisionHandler = CollisionHandlerEvent()\n-        self.EnemyCollisionHandler.addInPattern('into-camera')\n-        self.showbase.accept(\"into-camera\",self.DamagePlayer)\n-\n-        #Because it will spam message in update\n-        self.Messagesent = False\n-        self.Run = True\n-        self._gravity = LVector3(0, 0, -2)\n-        self.EnemyCount = 0\n-        self.waveCount = 1\n-        self.Font = self.showbase.loader.loadFont('assets/fonts/propaganda.ttf')\n-    async def setup(self, modelpath, extraAnims, num, height, health, waves= 5, changePerWave=1):\n-        self.waveMethod = AsyncFuture()\n-        self.num = num\n-        self.Run = True\n-        # Creating the wave count\n-        self.WaveCounttext = OnscreenText(text=\"Wave: 1\", pos=(0,0.9), scale=0.1)\n-        self.WaveCounttext.setFont(self.Font)\n-        for i in range(waves):\n-            for j in range(self.num):\n-                if self.waveCount > i:\n-                    continue    \n-                if self.Run == False:\n-                    print('Break')\n-                    break\n-                # Set up models and make them loop animations\n-                self.EnemyModelDict['enemy' + str(j)] = Actor(modelpath, extraAnims if extraAnims is not None else None)\n-                self.EnemyModelDict['enemy' + str(j)].loop(self.EnemyModelDict['enemy' + str(j)].getAnimNames()[0])\n-                self.EnemyModelDict['enemy' + str(j)].reparentTo(self.showbase.render)\n-                self.EnemyModelDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n-                \n-                # Set up shaders, pretty custom\n-                game.shader(EnterNode=self.EnemyModelDict['enemy' + str(j)])\n-\n-                # We need to use a place holder model because the model will point at the user, so we just set position of the actual model\n-                self.EnemyAIDotDict['enemy' + str(j)] = self.showbase.loader.loadModel(\"assets/models/aidotupdater.bam\")\n-                self.EnemyAIDotDict['enemy' + str(j)].reparentTo(self.showbase.render)\n-                self.EnemyAIDotDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n-                \n-                # Collision\n-                self.EnemyCollisionDict['enemy' + str(j)] = CollisionNode('enemy' + str(j))\n-                self.EnemyCollisionDict['enemy' + str(j)].addSolid(CollisionBox(LPoint3f(2, 0, 9), 4,3,12))\n-                self.EnemyColliderPath = self.EnemyModelDict['enemy' + str(j)].attachNewNode(self.EnemyCollisionDict['enemy' + str(j)])\n-\n-                # AI\n-                self.EnemyAICharDict['enemy' + str(j)] = AICharacter('enemy' + str(j), self.EnemyAIDotDict['enemy' + str(j)], 100, .05, 5)\n-                self.EnemyAIWorld.addAiChar(self.EnemyAICharDict['enemy' + str(j)])\n-                self.EnemyAIBehaviourDict['enemy' + str(j)] = self.EnemyAICharDict['enemy' + str(j)].getAiBehaviors()\n-                self.EnemyAIBehaviourDict['enemy' + str(j)].pursue(self.showbase.camera)\n-                self.EnemyAIBehaviourDict['enemy' + str(j)].arrival(1)\n-                self.EnemyHealthDict['enemy' + str(j)] = health\n-\n-                # Add collisions\n-                self.showbase.cTrav.addCollider(self.EnemyColliderPath, self.EnemyCollisionHandler)\n-                game.pusher.addCollider(self.EnemyColliderPath, self.EnemyModelDict['enemy' + str(j)])\n-\n-                print(\"Enemy \" + str(j) + \" spawned\")\n-            if self.waveCount > i:\n-                continue\n-            else:\n-                await self.waveMethod\n-                print(\"Wave \" + str(i+2) + \" done\")\n-                self.waveMethod = AsyncFuture()\n-                self.WaveCounttext.setText(\"Wave: \" + str(i+2))\n-                self.waveCount += 1\n-                self.Messagesent = False\n-                self.num += changePerWave\n-        print('Done')\n-    def DamagePlayer(self, collision='nothing'):\n-        for i in range(len(self.EnemyDict['model'])+1):\n-            if 'enemy' + str(i) in str(collision) and 'camera' in str(collision):\n-                Game.PlayerHealth -= 1\n-    def EnemyHit(self, enemy):\n-        self.EnemyDict['health'][enemy.getName()] -= 1\n-        AnimControl = self.EnemyDict['model'][enemy.getName()].getAnimControl('hit')\n-        if AnimControl.isPlaying():\n-            return None\n-        else:\n-            AnimControl.setPlayRate(.5)\n-            self.EnemyDict['ai_behaviour'][enemy.getName()].pauseAi('all')\n-            self.EnemyDict['model'][enemy.getName()].play('hit')\n-    def MainUpdate(self):\n-        self.EnemyAIWorld.update()\n-        for enemy, aidot in zip(self.EnemyDict['model'].values(), self.EnemyDict['ai_dot'].values()):\n-            if not enemy.isEmpty() and not aidot.isEmpty():\n-                dt = globalClock.getDt()\n-                aidotpos = aidot.getPos()\n-                (aidotpos) += self._gravity * min(dt, 1/64.0)\n-                aidot.setPos(aidotpos)\n-                enemy.setH((aidot.getH())-180)\n-                enemy.setPos(aidotpos)\n-        for key in list(self.EnemyDict['health'].keys()):\n-            if self.EnemyDict['health'][key] <= 0:\n-                self.EnemyDict['model'][key].cleanup()\n-                self.EnemyDict['ai_dot'][key].removeNode()\n-                self.EnemyAIWorld.removeAiChar(key)\n-                self.EnemyDict['ai_behaviour'][key].removeAi(key)\n-                del self.EnemyDict['model'][key]\n-                del self.EnemyDict['ai_dot'][key]\n-                del self.EnemyDict['collision'][key]\n-                del self.EnemyDict['ai_char'][key]\n-                del self.EnemyDict['ai_behaviour'][key]\n-                del self.EnemyDict['health'][key]\n-                self.EnemyCount += 1\n-        \n-        if self.EnemyDict['model'] == {} and not self.Messagesent:\n-            self.Messagesent = True\n-            self.waveMethod.set_result(None)\n-        \n-        for enemy in list(self.EnemyDict['model'].values()):\n-            key = list(self.EnemyDict['model'].keys())[list(self.EnemyDict['model'].values()).index(enemy)]\n-            if not enemy.getAnimControl('hit').isPlaying() and self.EnemyDict['ai_behaviour'][key].behaviorStatus('pursue') == 'paused':\n-                self.EnemyDict['ai_behaviour'][key].resumeAi('all')\n-                enemy.loop('Walk')\n-    def destroy(self, KeepAI=False):\n-        self.Run = False\n-        self.WaveCounttext.destroy()\n-        if KeepAI:\n-            for enemy in list(self.EnemyDict['model'].keys()):\n-                self.EnemyAIWorld.removeAiChar(enemy)\n-                self.EnemyDict['ai_behaviour'][enemy].removeAi(enemy)\n-        self.EnemyDict['model'] = {}\n-        self.EnemyDict['ai_dot'] = {}\n-        self.EnemyDict['collision'] = {}\n-        self.EnemyDict['ai_char'] = {}\n-        self.EnemyDict['ai_behaviour'] = {}\n-        self.EnemyDict['health'] = {}\n-\n-class Game(ShowBase):\n-    vfs = VirtualFileSystem.getGlobalPtr()\n-    inaMenu = True\n-    mouse_sensitivity = 0.5\n-    PlayerHealth = 100\n-    sunDirection = -.2\n-    cycleOscillation = {'dawnOrDusk' : 'down', 'notQiyamah': .45}\n-    keys = {'w':\"forward\",\n-            's':\"backward\",\n-            'a':\"left\",\n-            'd':\"right\",\n-            'space':\"up\",\n-            'e':\"down\"}\n-    def textTypewriteAnimation(self, textPos, text, interval=0.05):\n-        textSplit = list(text)\n-        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft, font=self.loader.loadFont('assets/fonts/Micro5-Regular.ttf'))\n-        def cleanup(task):\n-            textNode.destroy()\n-        async def typewrite():\n-            for char in textSplit:\n-                textNode.setText(textNode.getText() + char)\n-                await Task.pause(interval)\n-            await Task.pause(1)\n-            return Task.done\n-        taskMgr.add(typewrite(), 'typewriteTask', uponDeath=cleanup)\n-    def dayNightCycle(self):\n-        steps = {'sunSpeed': 0.0005, 'rotationSpeed': 0.000375}\n-        self.cycleOscillation['notQiyamah'] -= steps['rotationSpeed']\n-        if self.cycleOscillation['dawnOrDusk'] == 'down':\n-            self.sunDirection += steps['sunSpeed']\n-            if self.sunDirection >= .3:\n-                self.cycleOscillation['dawnOrDusk'] = 'up'\n-                print(self.cycleOscillation['notQiyamah'])\n-                self.cycleOscillation['notQiyamah'] = 0.45\n-                steps['rotationSpeed'] = 0.000375\n-                print('switch up')\n-        elif self.cycleOscillation['dawnOrDusk'] == 'up':\n-            self.sunDirection -= steps['sunSpeed']\n-            if self.sunDirection <= -.3:\n-                self.cycleOscillation['dawnOrDusk'] = 'down'\n-                steps['rotationSpeed'] = 0.00017\n-                print(self.cycleOscillation['notQiyamah'])\n-                print('switch down')\n-        for models in self.currentModels:\n-            models.setShaderInput('light0_direction', (self.cycleOscillation['notQiyamah'], self.sunDirection, 0))\n-    def PlayerHUD(self):\n-        self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        frameSize=(-1.25, 1.25, -0.15, 0.15),\n-                                        pos=(0, 0, -.75))\n-        self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n-                                             frameSize=(-.125, .125, -0.125, 0.125),\n-                                             pos=(0, 0, -.75))\n-    def exportScene(self):\n-        file_name = input(\"Enter file name: \")\n-        ss = StringStream()\n-        self.render.ls(out=ss)\n-        with open(f\"scene_graph-{file_name}.txt\", \"w\", encoding=\"utf-8\") as f:\n-            f.write(ss.get_data().decode(\"utf-8\"))\n-    def Death(self):\n-        self.CameraOperator()\n-        def LoadMainMenu(self):\n-            # remove task, reset\n-            self.deathFrame.destroy()\n-            self.btnMainMenu.destroy()\n-            self.PlayerHealth = 100\n-            self.clickSound.play()\n-            taskMgr.remove('Update')\n-            self.SaveProgress(reset=True)\n-            self.HealthBar.destroy()\n-            self.playButtonMethod = AsyncFuture()\n-            self.MainMenu()\n-            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n-            self.cam_controller.setup(keys=self.keys)\n-            self.cam_controller.disable()\n-            self.currentwave = 0\n-            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n-            for child in children_to_remove:\n-                if '__Actor_modelRoot' in child.getChildren():\n-                    child.cleanup()\n-                else:    \n-                    child.removeNode()\n-            taskMgr.add(self.loadScene())\n-        self.deathFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n-                                      frameSize=(-1.4, 1.4, -1, 1), \n-                                      pos=(0, 0, 0), \n-                                      scale=(1, 1, 1), \n-                                      text=\"You died\", \n-                                      text_font=self.Font,\n-                                      text_scale=0.3, \n-                                      text_pos=(0, .75), \n-                                      text_fg=(1, 0, 0, 1), \n-                                      text_align=TextNode.ACenter)\n-        self.btnMainMenu = DirectButton(\n-            parent=self.deathFrame,\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.4, 0.4, -0.08, 0.16),\n-            pos=LPoint3f(0, 0, -0.15),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Exit to Main Menu',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.075, 0.075),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=LoadMainMenu,\n-            extraArgs=[self],\n-        )\n-    def MouseIn(self):\n-#           if not self.inaMenu:\n-#            self.particleEffect.start(self.ak47, self.ak47)\n-        props = self.win.getProperties()\n-        # This is needed to for WebGL. If the window is not in focus, the mouse won't work, so we need to request focus\n-        if not self.inaMenu:\n-            if not props.getForeground() or not props.getCursorHidden() or props.getMouseMode() != WindowProperties.MConfined:\n-                self.win.requestProperties(WindowProperties(foreground=True, mouse_mode=WindowProperties.MConfined, cursor_hidden=True))\n-        \n-        # Create a CollisionRay for the mouse click\n-        ray_node = CollisionNode('click-ray')\n-        ray = CollisionRay()\n-        ray.setOrigin(0, 0, 0)  # Start at the camera\n-        ray.setDirection(0, 1, 0)  # Point forward\n-        ray_node.addSolid(ray)\n-\n-        # Attach the CollisionRay to the camera and set it to the right bitmasks\n-        self.ray_path = self.camera.attachNewNode(ray_node)\n-\n-        # Create a quene to store the collisions and add the CollisionRay to the CollisionTraverser\n-        self.collision_queue = CollisionHandlerQueue()\n-        self.cTrav.addCollider(self.ray_path, self.collision_queue)\n-        taskMgr.add(self.click, \"clickTask\")\n-    def MouseUp(self):\n-        self.particleEffect.disable()\n-        if hasattr(self, 'ray_path'):\n-            self.cTrav.removeCollider(self.ray_path)  # Remove collider from traverser\n-            self.ray_path.removeNode()  # Safely remove the ray\n-            self.collision_queue.clearEntries()\n-    def SaveProgress(self, reset=False):\n-        if reset:\n-            self.save_file = open(\"save.txt\", \"w\")\n-            self.save_file.write('LPoint3f(0, 0, 114)\\n')\n-            self.save_file.write(str(0))\n-            self.save_file.close()\n-        else:\n-            self.save_file = open(\"save.txt\", \"w\")\n-            self.save_file.write(str(self.camera.getPos()) + '\\n')\n-            self.save_file.close()\n-    def CameraOperator(self):\n-        # When this function is called, we check if we are in a menu, if we are then we watch our new keys\n-        # This is critical for one we don't setup the camera again, and two if the player decides to change controls\n-        # And then we switch our bool to false, as we are no longer in a menu, enabling clicking to focus the mouse\n-        if self.inaMenu:\n-            self.cam_controller.rewatch(self.keys, mouse_sensitivity=self.mouse_sensitivity)\n-            self.inaMenu = False\n-        \n-        # If we are not in a menu, then we disable the camera controller\n-        # And set our bool to true, critical because our click function refocuses the window\n-        else:\n-            self.cam_controller.disable()   \n-            self.inaMenu = True\n-        # Using our boolean we pass an if statement to effectively switch when oue mouse focuses on clicks\n-    def TutorialMenu(self):\n-        self.clickSound.play()\n-        self.paused = True\n-        self.currentTime = 0\n-        self.tutorialMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        frameSize=(-1.25, 1.25, -0.9, 0.9),\n-                                        pos=(0, 0, 0)\n-        )\n-        self.tutorialLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        frameSize=(-.3, .3, -0.1, 0.1),\n-                                        pos=(-.8, 0, .65),\n-                                        parent=self.tutorialMainFrame,\n-                                        relief=None,\n-                                        text=\"Tutorial\",\n-                                        text_fg=(0, 0, 0, 1),\n-                                        text_pos=(0, 0),\n-                                        text_scale=0.2,\n-                                        text_font=self.Font,\n-                                        text_align=TextNode.ACenter\n-        )\n-        self.tutorialVideoControlFrame = DirectFrame(parent=self.tutorialMainFrame,\n-                                                    frameColor=(0.3, 0.3, 0.3, 1),\n-                                                    frameSize=(-1, 1, -0.1, 0.1),\n-                                                    pos=(0, 0, -.7)\n-        )\n-        self.tutorialVideo = self.loader.loadTexture(r\"assets/audio/tutorial.mp4\")\n-        self.cm = CardMaker(\"card\")\n-        self.cm.setFrame(-.8, .8, -0.55, 0.55)\n-        self.cm.setUvRange(self.tutorialVideo)\n-        self.card = self.render2d.attachNewNode(self.cm.generate())\n-        self.card.setTexture(self.tutorialVideo)\n-        self.card.setPos(-0, 0, 0)\n-        self.card.reparentTo(self.tutorialMainFrame)\n-        self.tutorialAudio = self.loader.loadSfx(r\"assets/audio/tutorial.mp4\")\n-        self.tutorialVideo.synchronizeTo(self.tutorialAudio)\n-\n-        def PlayblackSliderMethod(self):\n-            self.tutorialAudio.stop()\n-            self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n-            self.currentTime = self.videoPlaybackSlider['value']\n-            self.paused = True\n-        def PausePlayMethod(self):\n-            if self.paused == True:\n-                #When clicked from pause to play\n-                self.paused = False\n-                self.videoPauseButton['image'] = 'assets/images/playIcon.png'\n-            else:\n-                self.paused = True\n-                self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n-            if self.tutorialAudio.status() == self.tutorialAudio.PLAYING:\n-                self.currentTime = self.tutorialAudio.getTime()\n-                self.tutorialAudio.stop()\n-            else:\n-                self.tutorialAudio.setTime(self.currentTime)\n-                self.tutorialAudio.play()\n-        \n-        self.videoPlaybackSlider = DirectSlider(range=(0, self.tutorialVideo.getVideoLength()),\n-                                  value=0, \n-                                  command=PlayblackSliderMethod, \n-                                  frameSize=(-.75, .75, -0.1, 0.1),\n-                                  frameColor=(0.8, 0.8, 0.8, 1),\n-                                  thumb_frameSize=(-.015, .015, -.015, .015),\n-                                  thumb_frameColor=(1, 0, 0, 1),\n-                                  pos=LPoint3f(0, 0, 0),\n-                                  orientation='horizontal', \n-                                  parent=self.tutorialVideoControlFrame,\n-                                  thumb_relief=DGG.FLAT,\n-                                  extraArgs=[self]\n-                                  )\n-        self.videoPauseButton = DirectButton(parent=self.tutorialVideoControlFrame,\n-                                             frameColor=(0.8, 0.8, 0.8, 1),\n-                                             frameSize=(-.05, .05, -0.05, 0.05),\n-                                             pos=LPoint3f(-.9, 0, 0),\n-                                             relief=None,\n-                                             image = 'assets/images/pauseIcon.png',\n-                                             image_pos=(0, 0, 0),\n-                                             image_scale=(0.1, 0.1, 0.1),\n-                                             command=PausePlayMethod,\n-                                             extraArgs=[self]\n-                                             )\n-        self.videoPauseButton.setTransparency(TransparencyAttrib.MAlpha)\n-    def OptionMenu(self):\n-        self.clickSound.play()\n-        self.mouseSettingsOpen = False\n-        self.keyboardSettingsOpen = False\n-        self.audioSettingsOpen = False\n-        self.aboutSettingsOpen = False\n-        \n-        def clear_menu():\n-            if self.mouseSettingsOpen:\n-                self.sensitivityFrame.destroy()\n-                self.sensitivityLabel.destroy()\n-                self.sensitivitySlider.destroy()\n-                self.mouseSettingsOpen = False  \n-            if self.keyboardSettingsOpen:\n-                self.forwardFrame.destroy()\n-                self.backwardFrame.destroy()\n-                self.leftFrame.destroy()\n-                self.rightFrame.destroy()\n-                self.forwardLabel.destroy()\n-                self.backwardLabel.destroy()\n-                self.leftLabel.destroy()\n-                self.rightLabel.destroy()\n-                self.forwardEntry.destroy()\n-                self.backwardEntry.destroy()\n-                self.leftEntry.destroy()\n-                self.rightEntry.destroy()\n-                self.btnSave.destroy()\n-                self.disclamerLabel.destroy()\n-                self.keyboardSettingsOpen = False\n-#            if self.audioSettingsOpen:\n-\n-            if self.aboutSettingsOpen:\n-                self.aboutLabel.destroy()\n-                self.gameAboutLabel.destroy()\n-                self.aboutSettingsOpen = False\n-        self.optionMenuBg = OnscreenImage(image='assets/images/optionMenuBg.png', pos=(0, 0, 0), scale=(.75, .5, 1))\n-        self.optionMenuBg.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.scrolledFrame = DirectScrolledFrame(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-.2, .6, -.8, .7),\n-            pos=LPoint3f(-0.05, 0, 0),\n-            canvasSize=(-.4, .4, -1, 1),\n-            verticalScroll_relief=None,\n-            horizontalScroll_relief=None,\n-        )\n-        self.scrolledFrame.setManageScrollBars()\n-        self.scrolledFrame.verticalScroll['frameSize'] = (-.01, .01, -.01, .01)\n-        self.scrolledFrame.verticalScroll['frameColor'] = (0.4, 0.4, 0.4, 1)\n-        self.scrolledFrame.verticalScroll['thumb_relief'] = DGG.FLAT\n-        self.scrolledFrame.verticalScroll['decButton_relief'] = None\n-        self.scrolledFrame.verticalScroll['incButton_relief'] = None\n-        self.scrolledFrame.horizontalScroll['frameSize'] = None\n-\n-        def MouseSettingMethod(self):\n-            self.sensitivityFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .85),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.sensitivityLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Mouse Sensitivity\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.1, 0, .875), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT\n-                                                )\n-            def changesensitivity():\n-                self.mouse_sensitivity = self.sensitivitySlider['value'] * .2\n-                print(self.sensitivitySlider['value'])      \n-            self.sensitivitySlider = DirectSlider(range=(0,2), \n-                                  value=1, \n-                                  command=changesensitivity, \n-                                  frameSize=(-.25, .25, -0.05, 0.05),\n-                                  frameColor=(0.8, 0.8, 0.8, 1),\n-                                  thumb_frameSize=(-.01, .01, -.01, .01),\n-                                  thumb_frameColor=(0.4, 0.4, 0.4, 1),\n-                                  pos=LPoint3f(-.05, 0, .8),\n-                                  orientation='horizontal', \n-                                  parent=self.scrolledFrame.getCanvas(),\n-                                  thumb_relief=DGG.FLAT\n-                                  )\n-            clear_menu()\n-            self.mouseSettingsOpen = True\n-        def KeyboardSettingMethod(self):\n-            def ForwardKeyMethod(key, self):\n-                self.forwardKey = key\n-            def BackwardKeyMethod(key, self):\n-                self.backwardKey = key\n-            def LeftKeyMethod(key, self):\n-                self.leftKey = key\n-            def RightKeyMethod(key, self):\n-                self.rightKey = key\n-            def SaveMethod(self):\n-                if not hasattr(self, 'forwardKey'):\n-                    self.forwardKey = 'w'\n-                if not hasattr(self, 'backwardKey'):\n-                    self.backwardKey = 's'\n-                if not hasattr(self, 'leftKey'):\n-                    self.leftKey = 'a'\n-                if not hasattr(self, 'rightKey'):\n-                    self.rightKey = 'd'\n-                self.keys = {\n-                    self.forwardKey: \"forward\",\n-                    self.backwardKey: \"backward\",\n-                    self.leftKey: \"left\",\n-                    self.rightKey: \"right\",\n-                    'space': \"up\",\n-                    'e': \"down\"\n-                }\n-            self.forwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Forward\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.2, 0, .875), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.backwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Backward\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.19, 0, .625), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.leftLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Left\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.25, 0, .375), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.rightLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Right\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.24, 0, .125), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.forwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .825),\n-                                                text_pos= (-0.1, -.015),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=ForwardKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='W'\n-                                                )\n-            self.backwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .575),\n-                                                text_pos= (-0.1, -.015),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=BackwardKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='S'\n-                                                )\n-            self.leftEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .325),\n-                                                text_pos= (-0.1, -.015),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=LeftKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='A'\n-                                                )\n-            self.rightEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .075),\n-                                                text_pos= (-0.1, -.015),    \n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=RightKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='D'\n-                                                )\n-            self.forwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .85),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.backwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .6),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.leftFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .35),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.rightFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .1),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.btnSave = DirectButton(\n-                frameColor=(0.2, 0.2, 0.2, 1),\n-                frameSize=(-0.09, 0.09, -0.025, 0.05),\n-                text='Save',\n-                text_scale=0.05,\n-                text_fg=(0.5, 0.5, 0.5, 1),\n-                pos=LPoint3f(-0.25, 0, -0.075),\n-                relief=1,\n-                parent=self.scrolledFrame.getCanvas(),\n-                command=SaveMethod,\n-                extraArgs=[self],\n-                sortOrder=2\n-            )\n-            self.disclamerLabel = DirectLabel(\n-                frameColor=(0.6, 0.6, 0.6, 1),\n-                text=\"*Press enter each key*\",\n-                text_scale=0.05,\n-                pos=LPoint3f(0, 0, -0.2),\n-                parent=self.scrolledFrame.getCanvas(),\n-                relief=None\n-            )\n-            clear_menu()\n-            self.keyboardSettingsOpen = True\n-        def AboutSettingMethod(self):\n-            self.aboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        text=\"About\",\n-                                        text_scale=0.1,\n-                                        pos=LPoint3f(-0.025, 0, 0.85),\n-                                        parent=self.scrolledFrame.getCanvas(),\n-                                        relief=None\n-                                        )\n-            self.gameAboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                            text= \"TSA Videogame Design 2025-2026 \\n '' is a  game developed by \\n  the team 1034-1 for the 2025-2026 \\n  \\\n-                                            Technology Student Association Competition for Video Game Design. \\n this is a  based on the theme of \\n\\\n-                                            We developed this game using \\n the Panda3D game engine \\n differing from Unity and Unreal as \\n it is a purely text edited engine\",\n-                                            text_scale=0.04,\n-                                            pos=LPoint3f(-0.04, 0, 0.3),\n-                                            parent=self.scrolledFrame.getCanvas(),\n-                                            relief=None\n-                                            )\n-            clear_menu()\n-            self.aboutSettingsOpen = True\n-        self.btnMouse = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.13),\n-            pos=LPoint3f(-0.37666, 0, 0.57666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/mouseIcon.png',\n-            image_scale = (.09, .09, .09),\n-            image_pos = (0, 0, 0.03),\n-            image_hpr = (0, 0, 0),\n-            command=MouseSettingMethod,\n-            extraArgs=[self],\n-        )\n-        self.btnMouse.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.btnKeyboard = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.376666, 0, 0.33666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/keyboardIcon.png',\n-            image_scale = (.09, .09, .09),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=KeyboardSettingMethod,\n-            extraArgs=[self],\n-        )\n-        self.btnKeyboard.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.btnAudioSet = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.37666, 0, 0.09666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/audioIcon.png',\n-            image_scale = (.07, .07, .07),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=self.playButtonMethod.set_result,\n-            extraArgs=[None],\n-        )\n-        self.btnAudioSet.setTransparency(TransparencyAttrib.MAlpha)\n-        \n-        self.btnAbout = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.37666, 0, -0.13666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/aboutIcon.png',\n-            image_scale = (.07, .07, .07),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=AboutSettingMethod,\n-            extraArgs=[self],\n-        )\n-        self.btnAbout.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        def close_menu():\n-            self.scrolledFrame.destroy()\n-            self.optionMenuBg.destroy()\n-            self.btnAbout.destroy()\n-            self.btnAudioSet.destroy()\n-            self.btnKeyboard.destroy()\n-            self.btnMouse.destroy()\n-            self.btnExit.destroy()\n-            clear_menu()\n-\n-        self.btnExit = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.5, 0, 0.75),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=None,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/exitIcon.png',\n-            image_scale = (.07, .07, .07),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=close_menu,\n-        )\n-        self.btnExit.setTransparency(TransparencyAttrib.MAlpha)\n-    def MainMenu(self):\n-        self.inaMenu = True\n-        self.mainMenuBackground = OnscreenImage(image='assets/images/mainMenuBackground.png', pos=(0, 0, 0), scale=(1.5, 1.5, 1.5))\n-        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.25, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n-        self.titleText.setFont(self.Font)\n-        self.btnPlay = DirectButton(\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.2, 0.2, -0.03, 0.06),\n-            pos=LPoint3f(0, 0, -0.1),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Play',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.05, 0.05),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=self.playButtonMethod.set_result,\n-            extraArgs=[None],\n-        )\n-\n-        self.btnOption= DirectButton(\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.3, 0.3, -0.03, 0.06),\n-            pos=LPoint3f(-1.2, 0, -0.87),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=None,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/optionIcon.png',\n-            image_scale = (.1, .1, .1),\n-            command=self.OptionMenu,\n-            extraArgs=[],\n-        )\n-        self.btnOption.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.btnTutorial= DirectButton(\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.3, 0.3, -0.03, 0.06),\n-            pos=LPoint3f(1.2, 0, -0.87),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=None,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/tutorialIcon.png',\n-            image_scale = (.1, .1, .1),\n-            command=self.TutorialMenu,\n-            extraArgs=[],\n-        )\n-        self.btnTutorial.setTransparency(TransparencyAttrib.MAlpha)\n-    def PauseMenu(self):\n-        self.clickSound.play()\n-        self.CameraOperator()\n-        def LoadMainMenu(self):\n-            #Keep AI here, dont remove .setup and reenter waves\n-            self.clickSound.play()\n-            taskMgr.remove('Update')\n-            self.SaveProgress()\n-            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n-            self.cam_controller.setup(keys=self.keys)\n-            self.cam_controller.disable()\n-            self.HealthBar.destroy()\n-            self.playButtonMethod = AsyncFuture()\n-            self.MainMenu()\n-            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n-            for child in children_to_remove:\n-                if '__Actor_modelRoot' in child.getName():\n-                    child.cleanup()\n-                else:    \n-                    child.removeNode()\n-            self.pauseFrame.destroy()\n-            self.btnMainMenu.destroy()\n-            self.btnResume.destroy()\n-            taskMgr.add(self.loadScene())\n-        def Resume(self):\n-            self.clickSound.play()\n-            self.pauseFrame.destroy()\n-            self.btnMainMenu.destroy()\n-            self.btnResume.destroy()\n-            self.CameraOperator()\n-        self.pauseFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                    frameSize=(-.5, .5, -0.3, 0.35),\n-                                    pos=LPoint3f(0, 0, 0),\n-                                    hpr=LVecBase3f(0, 0, 0),\n-                                    relief=DGG.FLAT,\n-                                    scale=LVecBase3f(1, 1, 1))\n-        self.btnMainMenu = DirectButton(\n-            parent=self.pauseFrame,\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.4, 0.4, -0.08, 0.16),\n-            pos=LPoint3f(0, 0, -0.15),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Save & Exit',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.1, 0.1),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=LoadMainMenu,\n-            extraArgs=[self],\n-        )\n-        self.btnResume = DirectButton(\n-            parent=self.pauseFrame,\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.4, 0.4, -0.08, 0.16),\n-            pos=LPoint3f(0, 0, 0.15),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Resume',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.1, 0.1),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=Resume,\n-            extraArgs=[self],\n-        )\n-    # This function is called when the mouse is clicked, calling a function based on what is clicked in game\n-    async def click(self, task):\n-        # Perform collision traversal\n-        self.cTrav.traverse(self.render)\n-        \n-        try:\n-            # Process collisions\n-            num_collisions = self.collision_queue.getNumEntries()\n-\n-            if num_collisions > 1:\n-                self.collision_queue.sortEntries()\n-                entry = self.collision_queue.getEntry(1)  # Get the closest collision\n-                hit_node = entry.getIntoNode()\n-                # Check if the hit node is the model that is supposed to be clicked using something like this:\n-#                for enemy in list(self.enemy.EnemyDict['collision'].values()):\n-#                    if hit_node.getName() == enemy.getName():\n-#                        self.enemyController.EnemyHit(enemy)\n-#                        await Task.pause(.2)\n-        except AssertionError as e:\n-            print(\"AssertionError occurred during collision processing.\")\n-            print(e)\n-        except KeyError as e:\n-            print(\"KeyError occurred during collision processing.\")\n-            pass\n-        return Task.cont\n-    \n-    def shader(self, nodes = None, EnterNode = None):\n-        self.currentModels = []\n-        if not hasattr(self, 'Shader_setup'):\n-            self.Shader_setup = None\n-            print(PandaSystem.getPlatform())\n-            if PandaSystem.getPlatform() == 'win_amd64' or PandaSystem.getPlatform() == 'osx_aarch64':\n-                shaders = [f\"{os.path.dirname(__file__)}/assets/shaders/Shader.vert\", f\"{os.path.dirname(__file__)}/assets/shaders/Shader.frag\"]\n-                patchedShaders = []\n-                for file in shaders:    \n-                    with open(file, 'r') as file:\n-                        code = file.read()\n-                        code = code.replace(\"#version 300 es\", \"#version 330\")\n-                        code = \"\\n\".join(\n-                            line for line in code.splitlines()\n-                            if not line.strip().startswith(\"precision\")\n-                        )\n-                        patchedShaders.append(code)\n-                self.Shader = Shader.make(Shader.SL_GLSL, patchedShaders[0], patchedShaders[1])\n-            else:\n-                self.Shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/Shader.vert\", \"assets/shaders/Shader.frag\")\n-            shadow_buffer = self.win.make_texture_buffer(\"ShadowBuffer\", 1024, 1024)\n-            shadow_buffer.set_sort(-100)\n-            shadow_buffer.set_clear_color((1, 1, 1, 1))\n-            self.shadow_map = shadow_buffer.get_texture()\n-            self.shadow_map.set_minfilter(SamplerState.FT_shadow)\n-            self.shadow_map.set_magfilter(SamplerState.FT_shadow)\n-\n-            self.shadow_cam = self.make_camera(shadow_buffer, lens=OrthographicLens())\n-            self.shadow_cam.reparent_to(self.sunLightNP)\n-\n-            shadow_scene = self.render.copy_to(NodePath(\"shadow_scene\"))\n-            shadow_scene.set_shader(Shader.load(Shader.SL_GLSL, \"assets/shaders/shadow_depth.vert\", \"assets/shaders/shadow_depth.frag\"))\n-            self.shadow_cam.node().set_scene(shadow_scene)\n-        if EnterNode == None:\n-            for node in nodes:\n-                self.currentModels.append(node)\n-                node.setShader(self.Shader)\n-                node.setShaderInput(\"shadowMap\", self.shadow_map)\n-                node.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n-                node.setShaderInput(\"diffuseTex\", node.find_texture(\"*\"))\n-                node.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n-                node.setShaderInput(\"light0_color\", Vec3(.5, .75, 0.85))\n-                node.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n-                node.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n-                node.setShaderInput(\"material_shininess\", 10.0)\n-                node.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n-                node.setShaderInput(\"cameraPos\", self.camera.getPos(self.render))\n-\n-        else:\n-            self.currentModels.append(EnterNode)\n-            EnterNode.setShader(self.Shader)\n-            EnterNode.setShaderInput(\"shadowMap\", self.shadow_map)\n-            EnterNode.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n-            EnterNode.setShaderInput(\"diffuseTex\", EnterNode.find_texture(\"*\"))\n-            EnterNode.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n-            EnterNode.setShaderInput(\"light0_color\", Vec3(.75, .75, 0.5))\n-            EnterNode.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n-            EnterNode.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n-            EnterNode.setShaderInput(\"material_shininess\", 15.0)\n-            EnterNode.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n-    # This function loads the models in the background, reducing lag and improving performance\n-    async def loadScene(self):\n-\n-        # in case of death, we need to reload the bool\n-        if hasattr(self, '_player_died'):\n-            delattr(self, '_player_died')  # Remove self._player_died\n-        \n-        if hasattr(self, '_player_won'):\n-            delattr(self, '_player_won')  # Remove self._player_won\n-            \n-        with open(f'{os.path.dirname(__file__)}/save.txt', 'r') as f:\n-            line = f.readline()\n-            line = line.replace('LPoint3f(', '').replace(')', '')\n-            x, y, z = map(float, line.split(','))\n-        \n-\n-        self.camera.setPos(x, y, z)\n-\n-        # Load the models in the background, each time suspending this\n-        # method until they are done\n-        self.worldCollisionModel = await self.loader.loadModel(\"assets/models/worldTriangles.bam\", blocking=False)\n-        self.worldVisibleModel = await self.loader.loadModel(\"assets/models/worldVisible.bam\", blocking=False)\n-\n-        # Create a background for the world\n-        \n-        self.world_bg = await self.loader.loadModel(\"assets/models/skybox.bam\",blocking=False)\n-        self.world_bg.reparent_to(self.render)\n-        self.world_bg.set_scale(2500)\n-\n-        world_bg_texture = self.loader.loadTexture(\"assets/images/world_bg.png\")\n-        world_bg_texture.set_minfilter(SamplerState.FT_linear)\n-        world_bg_texture.set_magfilter(SamplerState.FT_linear)\n-        world_bg_texture.set_wrap_u(SamplerState.WM_repeat)\n-        world_bg_texture.set_wrap_v(SamplerState.WM_mirror)\n-        world_bg_texture.set_anisotropic_degree(200)\n-        self.world_bg.set_texture(world_bg_texture)\n-        world_bg_shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/world_bg.vert.glsl\", \"assets/shaders/world_bg.frag.glsl\")\n-        self.world_bg.set_shader(world_bg_shader) \n-        \n-        # Create a collision node for the world\n-        self.world_collision_node = self.worldCollisionModel.find(\"**/+CollisionNode\")\n-        self.worldCollisionModel.hide()\n-        self.cTrav.addCollider(self.world_collision_node, self.pusher)\n-        self.pusher.addCollider(self.world_collision_node, self.worldCollisionModel)\n-\n-        # Set up Lighting System\n-        self.sunLight = DirectionalLight('directionalLight')\n-        self.sunLight.setShadowCaster(True, 16384, 16384)\n-        self.sunLightNP = self.render.attachNewNode(self.sunLight)\n-        self.sunLightNP.setHpr(45, 45, 0)\n-        self.sunLight.setColor((1.5, 1.5, 1.5, 1))\n-        \n-        self.sunModel = await self.loader.loadModel(\"assets/models/sun.bam\", blocking=False)\n-        self.sunModel.setPos(150, -150, 200)\n-\n-        print(self.sunModel)\n-        ambientLight = AmbientLight('ambientLight')\n-        ambientLight.setColor((0.1, 0.1, 0.1, 1))\n-        ambientLightNP = self.render.attachNewNode(ambientLight)\n-        \n-        # Set the shaders\n-        ''' Most of the time this is very custom. Though there is a pipeline that can be used\n-            Most of this stuff can be recycled\n-        '''\n-        self.shader([self.sunModel, self.worldVisibleModel])\n-        \n-        # Wait for the player to start the game\n-        await self.playButtonMethod\n-        self.clickSound.play()\n-\n-        # Remove the main menu\n-        self.titleText.destroy()\n-        self.btnPlay.destroy()\n-        self.mainMenuBackground.destroy()\n-        self.btnOption.destroy()\n-        self.btnTutorial.destroy()\n-\n-        # Create a loading screen\n-        Loading_text = OnscreenText(\"Loading\")\n-\n-        self.HealthBar = DirectWaitBar(text=\"Hull\", value=100, pos=(-.85, -15, -.7))\n-        self.HealthBar['barColor'] = (0, 2, 0, 2)\n-        self.HealthBar['text_scale'] = .05\n-        self.HealthBar['frameSize'] = (-.35, .35, -.035, .02)\n-        self.HealthBar['barRelief']= DGG.SUNKEN\n-\n-        self.HullBar = DirectWaitBar(text=\"Fuel\", value=100, pos=(-.85, -1, -.8))\n-        self.HullBar['barColor'] = (2, .5, 0, 2)\n-        self.HullBar['text_scale'] = .05\n-        self.HullBar['frameSize'] = (-.35, .35, -.035, .02)\n-        self.HullBar['barRelief']= DGG.SUNKEN\n-\n-        # Reparent the models to the render, making the world, and set the lights\n-        self.worldCollisionModel.reparentTo(self.render)\n-        self.worldVisibleModel.reparentTo(self.render)\n-        self.render.setLight(self.sunLightNP)\n-        self.render.setLight(ambientLightNP)\n-        self.sunModel.reparentTo(self.render)\n-        \n-        # Add HUD\n-        self.PlayerHUD()\n-        \n-        # Add a Pause Menu\n-        pausetext = OnscreenText(\"To Pause press P\", pos=(-1.14, 0.95), scale=0.05, fg=(0, 0, 0, 1), align=TextNode.ACenter)\n-        self.accept('p', self.PauseMenu)\n-\n-        # initialize the camera controller\n-        self.CameraOperator()\n-        \n-        self.particleEffect = ParticleEffect()\n-        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n-        self.particleEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/gunfiring.ptf\")\n-        self.particleEffect.clearShader()\n-        # Start the update cycle\n-        taskMgr.add(self.Update, \"Update\")        \n-        self.accept('mouse1-up', self.MouseUp)\n-        Loading_text.destroy() \n-\n-        self.textTypewriteAnimation((-1,0), 'Merwais is very smart and like, hes kinda of a homosexual but like in a cool way you know?')\n-    # The Update cycle, this function should be used to update positions and anything that needs to be updated\n-    def Update(self, task):\n-        camera_forward = self.camera.getQuat(self.render).getForward()\n-        camera_up = self.camera.getQuat(self.render).getUp()\n-        camera_right = self.camera.getQuat(self.render).getRight()\n-        camera_position = self.camera.getPos(self.render)\n-\n-        self.dayNightCycle()\n-#            ak47_position = (\n-#                camera_position +\n-#                camera_forward * 2.67 -  # Forward by 1.0 units\n-#                camera_up * 1 +       # Downward by 0.5 units\n-#                camera_right * 0.8      # Rightward by 0.3 units\n-#            )\n-#            self.ak47.setPos(ak47_position)\n-#            self.ak47.setHpr(self.camera.getH(), 0, 90)\n-        \n-        self.worldCollisionModel.setPos(0, 0, 0)\n-        \n-        self.HealthBar['value'] = self.PlayerHealth\n-\n-        if self.PlayerHealth < 0 and not hasattr(self, '_player_died'):\n-            self._player_died = None\n-            self.Death()\n-        \n-        if not True:\n-            self._player_won = None\n-            self.CameraOperator()\n-            def LoadMainMenu(self):\n-                self.clickSound.play()\n-                taskMgr.remove('Update')\n-                self.SaveProgress(reset=True)\n-                self.HealthBar.destroy()\n-                self.playButtonMethod = AsyncFuture()\n-                self.MainMenu()\n-                self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n-                self.cam_controller.setup(keys=self.keys)\n-                self.cam_controller.disable()\n-                self.currentwave = 0\n-                children_to_remove = [child for child in self.render.getChildren() if child not in self.camera]\n-                for child in children_to_remove:\n-                    if '__Actor_modelRoot' in child.getChildren():\n-                        child.cleanup()\n-                    else:    \n-                        child.removeNode()\n-                self.winFrame.destroy()\n-                self.btnMainMenu.destroy()\n-                taskMgr.add(self.loadScene())\n-            self.winFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n-                                        frameSize=(-1.4, 1.4, -1., 1), \n-                                        pos=(0, 0, 0), \n-                                        scale=(1, 1, 1), \n-                                        text=\"You Won!\", \n-                                        text_font=self.Font,\n-                                        text_scale=0.5, \n-                                        text_pos=(0, .25), \n-                                        text_fg=(0, 0, 1, 1), \n-                                        text_align=TextNode.ACenter)\n-            self.btnMainMenu = DirectButton(\n-                parent=self.winFrame,\n-                frameColor=(0.15, 0.15, 0.15, 1),\n-                frameSize=(-0.4, 0.4, -0.08, 0.16),\n-                pos=LPoint3f(0, 0, -0.15),\n-                hpr=LVecBase3f(0, 0, 0),\n-                relief=1,\n-                scale=LVecBase3f(1, 1, 1),\n-                text='Exit to Main Menu',\n-                text_align=TextNode.A_center,\n-                text_scale=(0.075, 0.075),\n-                text_pos=(0, 0),\n-                text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-                text_bg=LVecBase4f(0, 0, 0, 0),\n-                command=LoadMainMenu,\n-                extraArgs=[self],\n-            )\n-        return Task.cont\n-    def __init__(self):\n-        super().__init__()\n-\n-        self.currentwave = 0\n-\n-        # Defining the Traverser, the task that checks for collisions, and the pusher, the task that pushes objects when it collides\n-        # The Traverser reports to the pusher, we also need to tell Panda3d which objects respond to collisions\n-        self.cTrav = CollisionTraverser()\n-        self.pusher = CollisionHandlerPusher()\n-\n-        # Camera setup\n-        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5\n-                                                        , mouse_sensitivity=self.mouse_sensitivity, lockPitch=True)\n-        self.cam_controller.setup(keys=self.keys)\n-        self.cam_controller.disable()\n-        camera_collision_node = CollisionNode('camera')\n-        camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n-        camera_collision_node_path = self.camera.attachNewNode(camera_collision_node)\n-        camera_collision_node_path.setCollideMask(BitMask32.bit(2))\n-  \n-        # Add the collision nodes to the traverser. This is how we tell Panda3d which objects respond to collisions  \n-        self.cTrav.addCollider(camera_collision_node_path, self.pusher) \n-        self.pusher.addCollider(camera_collision_node_path, self.camera)\n-\n-        #   We load the tasks in the background to reduce lag\n-        self.playButtonMethod = AsyncFuture()\n-        taskMgr.add(self.loadScene())\n-        \n-        #  Tell Panda3d to listen for mouse clicks\n-        self.accept('mouse1', self.MouseIn)\n-        self.Font = self.loader.loadFont('assets/fonts/propaganda.ttf')\n-        self.Font.setPixelsPerUnit(120)\n-\n-        self.clickSound = self.loader.loadSfx('assets/audio/click.wav')\n-\n-        self.enableParticles()\n-\n-#        self.messenger.toggleVerbose()\n-        self.accept('x', self.exportScene)\n-\n-        # Open the main menu\n-        self.MainMenu()\n-game = Game()\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763566250294,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -70,9 +70,8 @@\n     DirectFrame,\n     DirectEntry,\n     DirectWaitBar\n )\n-\n loadPrcFileData('', 'gl-version 4 1')\n '''\n The camera controller is a class that handles the movement and rotation of the camera in the game.\n This is the core of the camera, and it is responsible for handling the input from the user and updating the camera accordingly.\n@@ -1234,8 +1233,9 @@\n         self.btnOption.destroy()\n         self.btnTutorial.destroy()\n \n         # Create a loading screen\n+        print(\"Loading Screen\")\n         Loading_text = OnscreenText(\"Loading\")\n \n         self.HealthBar = DirectWaitBar(text=\"Hull\", value=100, pos=(-.85, -15, -.7))\n         self.HealthBar['barColor'] = (0, 2, 0, 2)\n@@ -1265,15 +1265,12 @@\n \n         # initialize the camera controller\n         self.CameraOperator()\n         \n-        self.researchLocationEffect = ParticleEffect()\n-        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n-        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n-        self.researchLocationEffect.clearShader()\n         \n-        self.researchLocationEffect.start(parent=self.render, renderParent=self.render)\n-        self.researchLocationEffect.setPos(0, 0, 250)\n+        \n+#        self.researchLocationEffect.start(parent=self.render, renderParent=self.render)\n+#        self.researchLocationEffect.setPos(0, 0, 250)\n \n         self.ball = self.loader.loadModel(\"assets/models/sun.bam\")\n         self.ball.reparentTo(self.render)\n         self.ballDown = False\n@@ -1403,8 +1400,38 @@\n \n #        self.messenger.toggleVerbose()\n         self.accept('x', self.exportScene)\n \n+        self.Plot = Plot\n+\n         # Open the main menu\n         self.MainMenu()\n+class Plot(Game):\n+    async def plotLine(self):\n+        self.researchNode = self.loader.loadModel(\"assets/models/researchModel.bam\")\n+        self.researchNode.setPos(0, 0, 250)\n+        self.researchLocationEffect = ParticleEffect()\n+        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n+        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n+        self.researchLocationEffect.clearShader()\n+        self.researchLocationEffect.setPos(0, 0, 250)\n+        await self.plotAsync\n+        print('very cool')\n+    async def conditionBasedAdvancer(self):\n+        for i in range(self.eventCounter):\n+            if self.plotCondition[i]:\n+                self.eventAdvanceFunc['finish']()\n+                await self.advanceAsync\n+    def __init__(self):\n+        super().__init__()\n+        self.plotAsync = AsyncFuture()\n+        self.advanceAsync = AsyncFuture()\n+        self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n+        self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n+        self.plotCondition = [True if self.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == self.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n+        self.eventCounter = len(self.plotCondition)\n+        self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n+        taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n+        taskMgr.add(self.plotLine, \"PlotLine\")\n+\n game = Game()\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763566302903,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1406,8 +1406,9 @@\n         # Open the main menu\n         self.MainMenu()\n class Plot(Game):\n     async def plotLine(self):\n+        print('loading plot line')\n         self.researchNode = self.loader.loadModel(\"assets/models/researchModel.bam\")\n         self.researchNode.setPos(0, 0, 250)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n"
                },
                {
                    "date": 1763566415264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1400,9 +1400,9 @@\n \n #        self.messenger.toggleVerbose()\n         self.accept('x', self.exportScene)\n \n-        self.Plot = Plot\n+        self.Plot = Plot()\n \n         # Open the main menu\n         self.MainMenu()\n class Plot(Game):\n"
                },
                {
                    "date": 1763566595659,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1404,12 +1404,12 @@\n         self.Plot = Plot()\n \n         # Open the main menu\n         self.MainMenu()\n-class Plot(Game):\n+class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n-        self.researchNode = self.loader.loadModel(\"assets/models/researchModel.bam\")\n+        self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n         self.researchNode.setPos(0, 0, 250)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n         self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n@@ -1422,14 +1422,13 @@\n             if self.plotCondition[i]:\n                 self.eventAdvanceFunc['finish']()\n                 await self.advanceAsync\n     def __init__(self):\n-        super().__init__()\n         self.plotAsync = AsyncFuture()\n         self.advanceAsync = AsyncFuture()\n         self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n         self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n-        self.plotCondition = [True if self.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == self.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n+        self.plotCondition = [True if game.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == game.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n         self.eventCounter = len(self.plotCondition)\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n"
                },
                {
                    "date": 1763566627423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1404,8 +1404,9 @@\n         self.Plot = Plot()\n \n         # Open the main menu\n         self.MainMenu()\n+game = Game()\n class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n         self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n@@ -1432,6 +1433,6 @@\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n-game = Game()\n+\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763566664006,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1404,9 +1404,9 @@\n         self.Plot = Plot()\n \n         # Open the main menu\n         self.MainMenu()\n-game = Game()\n+game = None\n class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n         self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n@@ -1433,6 +1433,7 @@\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n+game = Game()\n \n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763566899897,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1359,9 +1359,9 @@\n             forward = self.camera.getQuat(self.render).getForward()\n             self.ball.setPos(pos + forward * 50)\n \n         return Task.cont\n-    def __init__(self):\n+    def __init__(self, Plot: 'Plot'):\n         super().__init__()\n         \n         self.currentwave = 0\n \n@@ -1400,13 +1400,13 @@\n \n #        self.messenger.toggleVerbose()\n         self.accept('x', self.exportScene)\n \n-        self.Plot = Plot()\n+        self.Plot = Plot\n \n         # Open the main menu\n         self.MainMenu()\n-game = None\n+\n class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n         self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n@@ -1433,7 +1433,6 @@\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n-game = Game()\n \n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763566945112,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1404,9 +1404,9 @@\n         self.Plot = Plot\n \n         # Open the main menu\n         self.MainMenu()\n-\n+game = Game()\n class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n         self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n"
                },
                {
                    "date": 1763566962564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1404,9 +1404,8 @@\n         self.Plot = Plot\n \n         # Open the main menu\n         self.MainMenu()\n-game = Game()\n class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n         self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n@@ -1433,6 +1432,6 @@\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n-\n+game = Game(Plot)\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763567052054,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1429,8 +1429,9 @@\n         self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n         self.plotCondition = [True if game.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == game.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n         self.eventCounter = len(self.plotCondition)\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n+        print('Initializing plot line')\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n game = Game(Plot)\n"
                },
                {
                    "date": 1763567078699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1433,6 +1433,6 @@\n         print('Initializing plot line')\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n-game = Game(Plot)\n+game = Game(Plot())\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763567200111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1404,8 +1404,10 @@\n         self.Plot = Plot\n \n         # Open the main menu\n         self.MainMenu()\n+game = Game(Plot())\n+\n class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n         self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n@@ -1433,6 +1435,5 @@\n         print('Initializing plot line')\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n-game = Game(Plot())\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763567744497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1400,13 +1400,12 @@\n \n #        self.messenger.toggleVerbose()\n         self.accept('x', self.exportScene)\n \n-        self.Plot = Plot\n+        self.Plot = Plot()\n \n         # Open the main menu\n         self.MainMenu()\n-game = Game(Plot())\n \n class Plot():\n     async def plotLine(self):\n         print('loading plot line')\n@@ -1435,5 +1434,6 @@\n         print('Initializing plot line')\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n+game = Game(Plot)\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763567775111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1434,6 +1434,6 @@\n         print('Initializing plot line')\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n-game = Game(Plot)\n+game = Game()\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763568097872,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -361,8 +361,38 @@\n         self.EnemyDict['ai_char'] = {}\n         self.EnemyDict['ai_behaviour'] = {}\n         self.EnemyDict['health'] = {}\n \n+class Plot():\n+    async def plotLine(self):\n+        print('loading plot line')\n+        self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n+        self.researchNode.setPos(0, 0, 250)\n+        self.researchLocationEffect = ParticleEffect()\n+        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n+        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n+        self.researchLocationEffect.clearShader()\n+        self.researchLocationEffect.setPos(0, 0, 250)\n+        await self.plotAsync\n+        print('very cool')\n+    async def conditionBasedAdvancer(self):\n+        for i in range(self.eventCounter):\n+            if self.plotCondition[i]:\n+                self.eventAdvanceFunc['finish']()\n+                await self.advanceAsync\n+    def __init__(self):\n+        self.plotAsync = AsyncFuture()\n+        self.advanceAsync = AsyncFuture()\n+        self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n+        self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n+        self.plotCondition = [True if game.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == game.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n+        self.eventCounter = len(self.plotCondition)\n+        self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n+        print('Initializing plot line')\n+        taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n+        taskMgr.add(self.plotLine, \"PlotLine\")\n+\n+\n class Game(ShowBase):\n     vfs = VirtualFileSystem.getGlobalPtr()\n     inaMenu = True\n     mouse_sensitivity = 0.5\n@@ -1405,35 +1435,6 @@\n \n         # Open the main menu\n         self.MainMenu()\n \n-class Plot():\n-    async def plotLine(self):\n-        print('loading plot line')\n-        self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n-        self.researchNode.setPos(0, 0, 250)\n-        self.researchLocationEffect = ParticleEffect()\n-        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n-        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n-        self.researchLocationEffect.clearShader()\n-        self.researchLocationEffect.setPos(0, 0, 250)\n-        await self.plotAsync\n-        print('very cool')\n-    async def conditionBasedAdvancer(self):\n-        for i in range(self.eventCounter):\n-            if self.plotCondition[i]:\n-                self.eventAdvanceFunc['finish']()\n-                await self.advanceAsync\n-    def __init__(self):\n-        self.plotAsync = AsyncFuture()\n-        self.advanceAsync = AsyncFuture()\n-        self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n-        self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n-        self.plotCondition = [True if game.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == game.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n-        self.eventCounter = len(self.plotCondition)\n-        self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n-        print('Initializing plot line')\n-        taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n-        taskMgr.add(self.plotLine, \"PlotLine\")\n-\n-game = Game()\n+game = Game(Plot)\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763568269583,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -361,38 +361,8 @@\n         self.EnemyDict['ai_char'] = {}\n         self.EnemyDict['ai_behaviour'] = {}\n         self.EnemyDict['health'] = {}\n \n-class Plot():\n-    async def plotLine(self):\n-        print('loading plot line')\n-        self.researchNode = game.loader.loadModel(\"assets/models/researchModel.bam\")\n-        self.researchNode.setPos(0, 0, 250)\n-        self.researchLocationEffect = ParticleEffect()\n-        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n-        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n-        self.researchLocationEffect.clearShader()\n-        self.researchLocationEffect.setPos(0, 0, 250)\n-        await self.plotAsync\n-        print('very cool')\n-    async def conditionBasedAdvancer(self):\n-        for i in range(self.eventCounter):\n-            if self.plotCondition[i]:\n-                self.eventAdvanceFunc['finish']()\n-                await self.advanceAsync\n-    def __init__(self):\n-        self.plotAsync = AsyncFuture()\n-        self.advanceAsync = AsyncFuture()\n-        self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n-        self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n-        self.plotCondition = [True if game.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == game.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n-        self.eventCounter = len(self.plotCondition)\n-        self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n-        print('Initializing plot line')\n-        taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n-        taskMgr.add(self.plotLine, \"PlotLine\")\n-\n-\n class Game(ShowBase):\n     vfs = VirtualFileSystem.getGlobalPtr()\n     inaMenu = True\n     mouse_sensitivity = 0.5\n@@ -1430,11 +1400,40 @@\n \n #        self.messenger.toggleVerbose()\n         self.accept('x', self.exportScene)\n \n-        self.Plot = Plot()\n+        self.Plot = Plot(self)\n \n         # Open the main menu\n         self.MainMenu()\n \n+class Plot():\n+    async def plotLine(self):\n+        print('loading plot line')\n+        self.researchNode = gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n+        self.researchNode.setPos(0, 0, 250)\n+        self.researchLocationEffect = ParticleEffect()\n+        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n+        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n+        self.researchLocationEffect.clearShader()\n+        self.researchLocationEffect.setPos(0, 0, 250)\n+        await self.plotAsync\n+        print('very cool')\n+    async def conditionBasedAdvancer(self):\n+        for i in range(self.eventCounter):\n+            if self.plotCondition[i]:\n+                self.eventAdvanceFunc['finish']()\n+                await self.advanceAsync\n+    def __init__(self, gameInstance):\n+        self.plotAsync = AsyncFuture()\n+        self.advanceAsync = AsyncFuture()\n+        self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n+        self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n+        self.plotCondition = [True if gameInstance.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == gameInstance.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n+        self.eventCounter = len(self.plotCondition)\n+        self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n+        print('Initializing plot line')\n+        taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n+        taskMgr.add(self.plotLine, \"PlotLine\")\n+\n game = Game(Plot)\n base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763571039622,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1427,9 +1427,9 @@\n         self.plotAsync = AsyncFuture()\n         self.advanceAsync = AsyncFuture()\n         self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n         self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n-        self.plotCondition = [True if gameInstance.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == gameInstance.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n+        self.plotCondition = [True if hasattr(gameInstance, 'collision_queue') and gameInstance.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == gameInstance.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n         self.eventCounter = len(self.plotCondition)\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n         print('Initializing plot line')\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n"
                },
                {
                    "date": 1763571071289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1406,9 +1406,9 @@\n         # Open the main menu\n         self.MainMenu()\n \n class Plot():\n-    async def plotLine(self):\n+    async def plotLine(self, task):\n         print('loading plot line')\n         self.researchNode = gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n         self.researchNode.setPos(0, 0, 250)\n         self.researchLocationEffect = ParticleEffect()\n@@ -1417,9 +1417,9 @@\n         self.researchLocationEffect.clearShader()\n         self.researchLocationEffect.setPos(0, 0, 250)\n         await self.plotAsync\n         print('very cool')\n-    async def conditionBasedAdvancer(self):\n+    async def conditionBasedAdvancer(self, task):\n         for i in range(self.eventCounter):\n             if self.plotCondition[i]:\n                 self.eventAdvanceFunc['finish']()\n                 await self.advanceAsync\n"
                },
                {
                    "date": 1763571205191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1408,9 +1408,9 @@\n \n class Plot():\n     async def plotLine(self, task):\n         print('loading plot line')\n-        self.researchNode = gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n+        self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n         self.researchNode.setPos(0, 0, 250)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n         self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n@@ -1423,13 +1423,14 @@\n             if self.plotCondition[i]:\n                 self.eventAdvanceFunc['finish']()\n                 await self.advanceAsync\n     def __init__(self, gameInstance):\n+        self.gameInstance = gameInstance\n         self.plotAsync = AsyncFuture()\n         self.advanceAsync = AsyncFuture()\n         self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n         self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n-        self.plotCondition = [True if hasattr(gameInstance, 'collision_queue') and gameInstance.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == gameInstance.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n+        self.plotCondition = [True if hasattr(self.gameInstance, 'collision_queue') and self.gameInstance.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == gameInstance.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n         self.eventCounter = len(self.plotCondition)\n         self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n         print('Initializing plot line')\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n"
                },
                {
                    "date": 1763571627616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1410,13 +1410,14 @@\n     async def plotLine(self, task):\n         print('loading plot line')\n         self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n         self.researchNode.setPos(0, 0, 250)\n+        self.researchNode.reparentTo(self.gameInstance.render)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n         self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n         self.researchLocationEffect.clearShader()\n-        self.researchLocationEffect.setPos(0, 0, 250)\n+        self.researchLocationEffect.start(self.researchNode, self.researchNode)\n         await self.plotAsync\n         print('very cool')\n     async def conditionBasedAdvancer(self, task):\n         for i in range(self.eventCounter):\n"
                },
                {
                    "date": 1763576228801,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1409,9 +1409,9 @@\n class Plot():\n     async def plotLine(self, task):\n         print('loading plot line')\n         self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n-        self.researchNode.setPos(0, 0, 250)\n+        self.researchNode.setPos(0, 0, 250).setHpr(90,0,0)\n         self.researchNode.reparentTo(self.gameInstance.render)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n         self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n"
                },
                {
                    "date": 1763576273033,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1409,9 +1409,10 @@\n class Plot():\n     async def plotLine(self, task):\n         print('loading plot line')\n         self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n-        self.researchNode.setPos(0, 0, 250).setHpr(90,0,0)\n+        self.researchNode.setPos(0, 0, 250)\n+        self.researchNode.setHpr(90,0,0)\n         self.researchNode.reparentTo(self.gameInstance.render)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n         self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n"
                },
                {
                    "date": 1763582900063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1409,10 +1409,9 @@\n class Plot():\n     async def plotLine(self, task):\n         print('loading plot line')\n         self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n-        self.researchNode.setPos(0, 0, 250)\n-        self.researchNode.setHpr(90,0,0)\n+        self.researchNode.setPosHpr(0, 0, 250, 0, 90, 0)\n         self.researchNode.reparentTo(self.gameInstance.render)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n         self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n"
                },
                {
                    "date": 1763583682847,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1234,9 +1234,9 @@\n         self.btnTutorial.destroy()\n \n         # Create a loading screen\n         print(\"Loading Screen\")\n-        Loading_text = OnscreenText(\"Loading\")\n+        Loading_text = OnscreenText(\"Loading\", scale=2, parent=self.a2dTopCenter, pos=(0, 0), fg=(1, 1, 1, 1), align=TextNode.ACenter)\n \n         self.HealthBar = DirectWaitBar(text=\"Hull\", value=100, pos=(-.85, -15, -.7))\n         self.HealthBar['barColor'] = (0, 2, 0, 2)\n         self.HealthBar['text_scale'] = .05\n@@ -1410,9 +1410,12 @@\n     async def plotLine(self, task):\n         print('loading plot line')\n         self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n         self.researchNode.setPosHpr(0, 0, 250, 0, 90, 0)\n+        self.researchCollisionNode = self.researchNode.find(\"**/+CollisionNode\")\n         self.researchNode.reparentTo(self.gameInstance.render)\n+        self.gameInstance.cTrav.addCollider(self.researchCollisionNode, self.gameInstance.pusher)\n+        self.gameInstance.pusher.addCollider(self.researchCollisionNode, self.researchNode)\n         self.researchLocationEffect = ParticleEffect()\n         os.chdir(os.path.abspath(os.path.dirname(__file__)))\n         self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n         self.researchLocationEffect.clearShader()\n"
                },
                {
                    "date": 1763583838122,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1444 @@\n+# /// script\n+# dependencies = [\n+#    \"panda3d\",\n+# ]\n+# ///\n+\n+'''\n+Game made by: Adeel Siddiqi and\n+This is\n+A game made for TSA Videogame design 2025-2026 \n+'''\n+__author__ = 'Adeel Siddiqi'\n+\n+import os\n+import random\n+from direct.actor.Actor import Actor\n+from direct.showbase.ShowBase import ShowBase\n+from direct.task import Task\n+from direct.showbase.DirectObject import DirectObject\n+from direct.controls.InputState import InputState\n+from direct.particles.ParticleEffect import ParticleEffect\n+import direct.gui.DirectGuiGlobals as DGG\n+from panda3d.ai import AIWorld, AICharacter\n+from panda3d.core import (\n+    PandaSystem,\n+    FrameBufferProperties, \n+    WindowProperties, \n+    GraphicsOutput,\n+    StringStream,\n+    AsyncFuture,\n+    LVecBase3f,\n+    LVecBase4f,\n+    LPoint3f, \n+    NodePath,\n+    TextNode, \n+    CollisionTraverser, \n+    CollisionNode, \n+    CollisionHandlerPusher, \n+    CollisionSphere, \n+    CollisionBox,\n+    LVector3, \n+    CollisionRay, \n+    BitMask32, \n+    CollisionHandlerQueue,\n+    loadPrcFileData,\n+    CollisionTraverser,\n+    BitMask32,\n+    TransparencyAttrib,\n+    CardMaker,\n+    SamplerState,\n+    VirtualFileSystem,\n+    Filename,\n+    DirectionalLight,\n+    AmbientLight,\n+    Camera,\n+    OrthographicLens,\n+    Texture,\n+    Vec3,\n+    Vec4,\n+    Shader,\n+    CollisionHandlerEvent\n+)\n+from direct.gui.DirectGui import (\n+    OnscreenImage,\n+    OnscreenText, \n+    DirectButton,\n+    DirectSlider,\n+    DirectScrolledFrame,\n+    DirectLabel,\n+    DirectFrame,\n+    DirectEntry,\n+    DirectWaitBar\n+)\n+loadPrcFileData('', 'gl-version 4 1')\n+'''\n+The camera controller is a class that handles the movement and rotation of the camera in the game.\n+This is the core of the camera, and it is responsible for handling the input from the user and updating the camera accordingly.\n+The default values are set to 9 for velocity and 0.2 for mouse sensitivity, and the initial position of the camera is set to (-0.5, -12, 7.7).\n+The default view is First Person. I will add a third person view later\n+'''\n+class CameraControllerBehaviour(DirectObject):\n+    _instances = 0\n+    def __init__(self, camera, velocity=9, gravity=-2, mouse_sensitivity=0.2, initial_pos=(0, 0, 0), lockPitch = False, showbase=None):\n+        self._camera = camera\n+        self._velocity = velocity\n+        self._mouse_sensitivity = mouse_sensitivity\n+        self._keys = None\n+        self._input_state = InputState()\n+        self._lockPitch = lockPitch\n+        self._heading = 0.0\n+        self._pitch = 0.0\n+        self._yaw = 0.0\n+        self._roll = 0.0\n+        self._prev_mouse = None\n+        self._showbase = base if showbase is None else showbase\n+        self._gravity = LVector3(0, 0, gravity)  # Set gravity vector pointing downward\n+        self._instance = CameraControllerBehaviour._instances\n+        CameraControllerBehaviour._instances += 1\n+        self._camera.setPos(*initial_pos)\n+        # Set the initial position of the camera\n+\n+    def setup(self, keys={\n+        'w':\"forward\", \n+        's':\"backward\",\n+        'a':\"left\",\n+        'd':\"right\",\n+        'space':\"up\",\n+        'e':\"down\"\n+    }):\n+        self._keys = keys\n+        for key in self._keys:\n+            self._input_state.watchWithModifiers(self._keys[key], key)\n+\n+        self._showbase.disableMouse()\n+\n+        props = WindowProperties()\n+        props.setMouseMode(WindowProperties.MConfined)\n+        props.setCursorHidden(True)\n+\n+        self._showbase.win.requestProperties(props)\n+        \n+        self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n+    \n+    def rewatch(self, keys=None, mouse_sensitivity=.2):\n+        if keys is not None:\n+            self._keys = keys\n+        for key in self._keys:\n+            self._mouse_sensitivity = mouse_sensitivity\n+            self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n+            self._input_state.watchWithModifiers(self._keys[key], key)\n+    \n+    def destroy(self):\n+        self.disable()\n+        self._input_state.delete()\n+\n+        del self\n+\n+    @property\n+    def velocity(self):\n+        return self._velocity\n+\n+    @velocity.setter\n+    def velocity(self, velocity):\n+        self._velocity = velocity\n+    \n+    @property\n+    def mouse_sensitivity(self):\n+        return self._mouse_sensitivity\n+\n+    @mouse_sensitivity.setter\n+    def mouse_sensitivity(self, sensitivity):\n+        self._mouse_sensitivity = sensitivity\n+\n+    def disable(self):\n+        self._showbase.taskMgr.remove(\"UpdateCameraTask\" + str(self._instance))\n+\n+        props = WindowProperties()\n+        props.setCursorHidden(False)\n+\n+        self._showbase.win.requestProperties(props)\n+                \n+    def update(self, task):\n+        dt = globalClock.getDt()\n+        \n+        # Get mouse movement for rotation\n+        md = self._showbase.win.getPointer(0)\n+        x = md.getX()\n+        y = md.getY()\n+        #center_x = self._showbase.win.getXSize() // 2\n+        #center_y = self._showbase.win.getYSize() // 2\n+\n+        if self._prev_mouse is not None:\n+            prev_x, prev_y = self._prev_mouse\n+            self._yaw = self._yaw - (x - prev_x) * self._mouse_sensitivity\n+            self._pitch = self._pitch - (y - prev_y) * self._mouse_sensitivity\n+        self._prev_mouse = (x, y)\n+\n+        # Clamp or lock the pitch to prevent camera flipping over\n+        self._pitch = 0 if self._lockPitch else max(-89, min(89, self._pitch))\n+        \n+        # Set the camera's orientation\n+        self._showbase.camera.setHpr(self._yaw, self._pitch, self._roll)\n+        \n+        # Access the camera's lens and set the focal length\n+        lens = self._showbase.cam.node().getLens()\n+        lens.setFocalLength(0.25)\n+        \n+        # Calculate the position increment\n+        pos_increment = self._velocity * dt\n+        \n+        # Handle keyboard input for movement\n+        if  self._input_state.isSet('forward'):\n+            self._showbase.camera.setY(self._showbase.camera, pos_increment)\n+\n+        if  self._input_state.isSet('backward'):\n+            self._showbase.camera.setY(self._showbase.camera, -pos_increment)\n+\n+        if  self._input_state.isSet('left'):\n+            self._showbase.camera.setX(self._showbase.camera, -pos_increment)\n+\n+        if  self._input_state.isSet('right'):\n+            self._showbase.camera.setX(self._showbase.camera, pos_increment)\n+\n+        if  self._input_state.isSet('up'):\n+            self._showbase.camera.setZ(self._showbase.camera, pos_increment)\n+\n+        if  self._input_state.isSet('down'):\n+            self._showbase.camera.setZ(self._showbase.camera, -pos_increment)\n+        \n+        self.cam_pos = self._showbase.camera.getPos(self._showbase.render)\n+        # Apply gravity to the camera's position\n+        (self.cam_pos) += self._gravity * min(dt, 1/64.0)\n+        \n+        # Update the camera's position\n+        self._showbase.camera.setPos(self.cam_pos)\n+\n+        return Task.cont\n+\n+class EnemyController():\n+    def __init__(self, showbase=None):\n+        self.showbase = base if showbase is None else showbase\n+        self.EnemyModelDict = {}\n+        self.EnemyAIDotDict = {}\n+        self.EnemyCollisionDict = {}\n+        self.EnemyAICharDict = {}\n+        self.EnemyAIBehaviourDict = {}\n+        self.EnemyHealthDict = {}\n+        self.EnemyAnimControlDict = {}\n+        self.EnemyDict = {'model':self.EnemyModelDict,\n+                          'ai_dot':self.EnemyAIDotDict,\n+                          'collision':self.EnemyCollisionDict,\n+                          'ai_char':self.EnemyAICharDict,\n+                          'ai_behaviour':self.EnemyAIBehaviourDict,\n+                          'health':self.EnemyHealthDict,\n+                          }\n+        self.EnemyAIWorld = AIWorld(self.showbase.render)\n+        self.EnemyCollisionHandler = CollisionHandlerEvent()\n+        self.EnemyCollisionHandler.addInPattern('into-camera')\n+        self.showbase.accept(\"into-camera\",self.DamagePlayer)\n+\n+        #Because it will spam message in update\n+        self.Messagesent = False\n+        self.Run = True\n+        self._gravity = LVector3(0, 0, -2)\n+        self.EnemyCount = 0\n+        self.waveCount = 1\n+        self.Font = self.showbase.loader.loadFont('assets/fonts/propaganda.ttf')\n+    async def setup(self, modelpath, extraAnims, num, height, health, waves= 5, changePerWave=1):\n+        self.waveMethod = AsyncFuture()\n+        self.num = num\n+        self.Run = True\n+        # Creating the wave count\n+        self.WaveCounttext = OnscreenText(text=\"Wave: 1\", pos=(0,0.9), scale=0.1)\n+        self.WaveCounttext.setFont(self.Font)\n+        for i in range(waves):\n+            for j in range(self.num):\n+                if self.waveCount > i:\n+                    continue    \n+                if self.Run == False:\n+                    print('Break')\n+                    break\n+                # Set up models and make them loop animations\n+                self.EnemyModelDict['enemy' + str(j)] = Actor(modelpath, extraAnims if extraAnims is not None else None)\n+                self.EnemyModelDict['enemy' + str(j)].loop(self.EnemyModelDict['enemy' + str(j)].getAnimNames()[0])\n+                self.EnemyModelDict['enemy' + str(j)].reparentTo(self.showbase.render)\n+                self.EnemyModelDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n+                \n+                # Set up shaders, pretty custom\n+                game.shader(EnterNode=self.EnemyModelDict['enemy' + str(j)])\n+\n+                # We need to use a place holder model because the model will point at the user, so we just set position of the actual model\n+                self.EnemyAIDotDict['enemy' + str(j)] = self.showbase.loader.loadModel(\"assets/models/aidotupdater.bam\")\n+                self.EnemyAIDotDict['enemy' + str(j)].reparentTo(self.showbase.render)\n+                self.EnemyAIDotDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n+                \n+                # Collision\n+                self.EnemyCollisionDict['enemy' + str(j)] = CollisionNode('enemy' + str(j))\n+                self.EnemyCollisionDict['enemy' + str(j)].addSolid(CollisionBox(LPoint3f(2, 0, 9), 4,3,12))\n+                self.EnemyColliderPath = self.EnemyModelDict['enemy' + str(j)].attachNewNode(self.EnemyCollisionDict['enemy' + str(j)])\n+\n+                # AI\n+                self.EnemyAICharDict['enemy' + str(j)] = AICharacter('enemy' + str(j), self.EnemyAIDotDict['enemy' + str(j)], 100, .05, 5)\n+                self.EnemyAIWorld.addAiChar(self.EnemyAICharDict['enemy' + str(j)])\n+                self.EnemyAIBehaviourDict['enemy' + str(j)] = self.EnemyAICharDict['enemy' + str(j)].getAiBehaviors()\n+                self.EnemyAIBehaviourDict['enemy' + str(j)].pursue(self.showbase.camera)\n+                self.EnemyAIBehaviourDict['enemy' + str(j)].arrival(1)\n+                self.EnemyHealthDict['enemy' + str(j)] = health\n+\n+                # Add collisions\n+                self.showbase.cTrav.addCollider(self.EnemyColliderPath, self.EnemyCollisionHandler)\n+                game.pusher.addCollider(self.EnemyColliderPath, self.EnemyModelDict['enemy' + str(j)])\n+\n+                print(\"Enemy \" + str(j) + \" spawned\")\n+            if self.waveCount > i:\n+                continue\n+            else:\n+                await self.waveMethod\n+                print(\"Wave \" + str(i+2) + \" done\")\n+                self.waveMethod = AsyncFuture()\n+                self.WaveCounttext.setText(\"Wave: \" + str(i+2))\n+                self.waveCount += 1\n+                self.Messagesent = False\n+                self.num += changePerWave\n+        print('Done')\n+    def DamagePlayer(self, collision='nothing'):\n+        for i in range(len(self.EnemyDict['model'])+1):\n+            if 'enemy' + str(i) in str(collision) and 'camera' in str(collision):\n+                Game.PlayerHealth -= 1\n+    def EnemyHit(self, enemy):\n+        self.EnemyDict['health'][enemy.getName()] -= 1\n+        AnimControl = self.EnemyDict['model'][enemy.getName()].getAnimControl('hit')\n+        if AnimControl.isPlaying():\n+            return None\n+        else:\n+            AnimControl.setPlayRate(.5)\n+            self.EnemyDict['ai_behaviour'][enemy.getName()].pauseAi('all')\n+            self.EnemyDict['model'][enemy.getName()].play('hit')\n+    def MainUpdate(self):\n+        self.EnemyAIWorld.update()\n+        for enemy, aidot in zip(self.EnemyDict['model'].values(), self.EnemyDict['ai_dot'].values()):\n+            if not enemy.isEmpty() and not aidot.isEmpty():\n+                dt = globalClock.getDt()\n+                aidotpos = aidot.getPos()\n+                (aidotpos) += self._gravity * min(dt, 1/64.0)\n+                aidot.setPos(aidotpos)\n+                enemy.setH((aidot.getH())-180)\n+                enemy.setPos(aidotpos)\n+        for key in list(self.EnemyDict['health'].keys()):\n+            if self.EnemyDict['health'][key] <= 0:\n+                self.EnemyDict['model'][key].cleanup()\n+                self.EnemyDict['ai_dot'][key].removeNode()\n+                self.EnemyAIWorld.removeAiChar(key)\n+                self.EnemyDict['ai_behaviour'][key].removeAi(key)\n+                del self.EnemyDict['model'][key]\n+                del self.EnemyDict['ai_dot'][key]\n+                del self.EnemyDict['collision'][key]\n+                del self.EnemyDict['ai_char'][key]\n+                del self.EnemyDict['ai_behaviour'][key]\n+                del self.EnemyDict['health'][key]\n+                self.EnemyCount += 1\n+        \n+        if self.EnemyDict['model'] == {} and not self.Messagesent:\n+            self.Messagesent = True\n+            self.waveMethod.set_result(None)\n+        \n+        for enemy in list(self.EnemyDict['model'].values()):\n+            key = list(self.EnemyDict['model'].keys())[list(self.EnemyDict['model'].values()).index(enemy)]\n+            if not enemy.getAnimControl('hit').isPlaying() and self.EnemyDict['ai_behaviour'][key].behaviorStatus('pursue') == 'paused':\n+                self.EnemyDict['ai_behaviour'][key].resumeAi('all')\n+                enemy.loop('Walk')\n+    def destroy(self, KeepAI=False):\n+        self.Run = False\n+        self.WaveCounttext.destroy()\n+        if KeepAI:\n+            for enemy in list(self.EnemyDict['model'].keys()):\n+                self.EnemyAIWorld.removeAiChar(enemy)\n+                self.EnemyDict['ai_behaviour'][enemy].removeAi(enemy)\n+        self.EnemyDict['model'] = {}\n+        self.EnemyDict['ai_dot'] = {}\n+        self.EnemyDict['collision'] = {}\n+        self.EnemyDict['ai_char'] = {}\n+        self.EnemyDict['ai_behaviour'] = {}\n+        self.EnemyDict['health'] = {}\n+\n+class Game(ShowBase):\n+    vfs = VirtualFileSystem.getGlobalPtr()\n+    inaMenu = True\n+    mouse_sensitivity = 0.5\n+    PlayerHealth = 100\n+    sunDirection = -.2\n+    cycleOscillation = {'dawnOrDusk' : 'down', 'notQiyamah': .45}\n+    keys = {'w':\"forward\",\n+            's':\"backward\",\n+            'a':\"left\",\n+            'd':\"right\",\n+#            'space':\"up\",\n+#            'e':\"down\"\n+            }\n+    def textTypewriteAnimation(self, textPos, text, interval=0.05):\n+        textSplit = list(text)\n+        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft, font=self.loader.loadFont('assets/fonts/Micro5-Regular.ttf'))\n+        def cleanup(task):\n+            textNode.destroy()\n+        async def typewrite():\n+            for char in textSplit:\n+                textNode.setText(textNode.getText() + char)\n+                await Task.pause(interval)\n+            await Task.pause(1)\n+            return Task.done\n+        taskMgr.add(typewrite(), 'typewriteTask', uponDeath=cleanup)\n+    def dayNightCycle(self):\n+        steps = {'sunSpeed': 0.0005, 'rotationSpeed': 0.000375}\n+        self.cycleOscillation['notQiyamah'] -= steps['rotationSpeed']\n+        if self.cycleOscillation['dawnOrDusk'] == 'down':\n+            self.sunDirection += steps['sunSpeed']\n+            if self.sunDirection >= .3:\n+                self.cycleOscillation['dawnOrDusk'] = 'up'\n+                print(self.cycleOscillation['notQiyamah'])\n+                self.cycleOscillation['notQiyamah'] = 0.45\n+                steps['rotationSpeed'] = 0.000375\n+                print('switch up')\n+        elif self.cycleOscillation['dawnOrDusk'] == 'up':\n+            self.sunDirection -= steps['sunSpeed']\n+            if self.sunDirection <= -.3:\n+                self.cycleOscillation['dawnOrDusk'] = 'down'\n+                steps['rotationSpeed'] = 0.00017\n+                print(self.cycleOscillation['notQiyamah'])\n+                print('switch down')\n+        for models in self.currentModels:\n+            models.setShaderInput('light0_direction', (self.cycleOscillation['notQiyamah'], self.sunDirection, 0))\n+    def PlayerHUD(self):\n+        self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        frameSize=(-1.25, 1.25, -0.15, 0.15),\n+                                        pos=(0, 0, -.75))\n+        self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n+                                             frameSize=(-.125, .125, -0.125, 0.125),\n+                                             pos=(0, 0, -.75))\n+    def exportScene(self):\n+        file_name = input(\"Enter file name: \")\n+        ss = StringStream()\n+        self.render.ls(out=ss)\n+        with open(f\"scene_graph-{file_name}.txt\", \"w\", encoding=\"utf-8\") as f:\n+            f.write(ss.get_data().decode(\"utf-8\"))\n+    def Death(self):\n+        self.CameraOperator()\n+        def LoadMainMenu(self):\n+            # remove task, reset\n+            self.deathFrame.destroy()\n+            self.btnMainMenu.destroy()\n+            self.PlayerHealth = 100\n+            self.clickSound.play()\n+            taskMgr.remove('Update')\n+            self.SaveProgress(reset=True)\n+            self.HealthBar.destroy()\n+            self.playButtonMethod = AsyncFuture()\n+            self.MainMenu()\n+            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n+            self.cam_controller.setup(keys=self.keys)\n+            self.cam_controller.disable()\n+            self.currentwave = 0\n+            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n+            for child in children_to_remove:\n+                if '__Actor_modelRoot' in child.getChildren():\n+                    child.cleanup()\n+                else:    \n+                    child.removeNode()\n+            taskMgr.add(self.loadScene())\n+        self.deathFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n+                                      frameSize=(-1.4, 1.4, -1, 1), \n+                                      pos=(0, 0, 0), \n+                                      scale=(1, 1, 1), \n+                                      text=\"You died\", \n+                                      text_font=self.Font,\n+                                      text_scale=0.3, \n+                                      text_pos=(0, .75), \n+                                      text_fg=(1, 0, 0, 1), \n+                                      text_align=TextNode.ACenter)\n+        self.btnMainMenu = DirectButton(\n+            parent=self.deathFrame,\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.4, 0.4, -0.08, 0.16),\n+            pos=LPoint3f(0, 0, -0.15),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Exit to Main Menu',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.075, 0.075),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=LoadMainMenu,\n+            extraArgs=[self],\n+        )\n+    def MouseIn(self):\n+        props = self.win.getProperties()\n+        # This is needed to for WebGL. If the window is not in focus, the mouse won't work, so we need to request focus\n+        if not self.inaMenu:\n+            if not props.getForeground() or not props.getCursorHidden() or props.getMouseMode() != WindowProperties.MConfined:\n+                self.win.requestProperties(WindowProperties(foreground=True, mouse_mode=WindowProperties.MConfined, cursor_hidden=True))\n+        \n+        # Create a CollisionRay for the mouse click\n+        ray_node = CollisionNode('click-ray')\n+        ray = CollisionRay()\n+        ray.setOrigin(0, 0, 0)  # Start at the camera\n+        ray.setDirection(0, 1, 0)  # Point forward\n+        ray_node.addSolid(ray)\n+\n+        # Attach the CollisionRay to the camera and set it to the right bitmasks\n+        self.ray_path = self.camera.attachNewNode(ray_node)\n+\n+        # Create a quene to store the collisions and add the CollisionRay to the CollisionTraverser\n+        self.collision_queue = CollisionHandlerQueue()\n+        self.cTrav.addCollider(self.ray_path, self.collision_queue)\n+        taskMgr.add(self.click, \"clickTask\")\n+\n+        #self.ballDown = True\n+    def MouseUp(self):\n+        taskMgr.remove(\"clickTask\")\n+        if hasattr(self, 'ray_path'):\n+            self.cTrav.removeCollider(self.ray_path)  # Remove collider from traverser\n+            self.ray_path.removeNode()  # Safely remove the ray\n+            self.collision_queue.clearEntries()\n+        #self.ballDown = False\n+    def SaveProgress(self, reset=False):\n+        if reset:\n+            self.save_file = open(\"save.txt\", \"w\")\n+            self.save_file.write('LPoint3f(0, 0, 114)\\n')\n+            self.save_file.write(str(0))\n+            self.save_file.close()\n+        else:\n+            self.save_file = open(\"save.txt\", \"w\")\n+            self.save_file.write(str(self.camera.getPos()) + '\\n')\n+            self.save_file.close()\n+    def CameraOperator(self):\n+        # When this function is called, we check if we are in a menu, if we are then we watch our new keys\n+        # This is critical for one we don't setup the camera again, and two if the player decides to change controls\n+        # And then we switch our bool to false, as we are no longer in a menu, enabling clicking to focus the mouse\n+        if self.inaMenu:\n+            self.cam_controller.rewatch(self.keys, mouse_sensitivity=self.mouse_sensitivity)\n+            self.inaMenu = False\n+        \n+        # If we are not in a menu, then we disable the camera controller\n+        # And set our bool to true, critical because our click function refocuses the window\n+        else:\n+            self.cam_controller.disable()   \n+            self.inaMenu = True\n+        # Using our boolean we pass an if statement to effectively switch when oue mouse focuses on clicks\n+    def TutorialMenu(self):\n+        self.clickSound.play()\n+        self.paused = True\n+        self.currentTime = 0\n+        self.tutorialMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        frameSize=(-1.25, 1.25, -0.9, 0.9),\n+                                        pos=(0, 0, 0)\n+        )\n+        self.tutorialLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        frameSize=(-.3, .3, -0.1, 0.1),\n+                                        pos=(-.8, 0, .65),\n+                                        parent=self.tutorialMainFrame,\n+                                        relief=None,\n+                                        text=\"Tutorial\",\n+                                        text_fg=(0, 0, 0, 1),\n+                                        text_pos=(0, 0),\n+                                        text_scale=0.2,\n+                                        text_font=self.Font,\n+                                        text_align=TextNode.ACenter\n+        )\n+        self.tutorialVideoControlFrame = DirectFrame(parent=self.tutorialMainFrame,\n+                                                    frameColor=(0.3, 0.3, 0.3, 1),\n+                                                    frameSize=(-1, 1, -0.1, 0.1),\n+                                                    pos=(0, 0, -.7)\n+        )\n+        self.tutorialVideo = self.loader.loadTexture(r\"assets/audio/tutorial.mp4\")\n+        self.cm = CardMaker(\"card\")\n+        self.cm.setFrame(-.8, .8, -0.55, 0.55)\n+        self.cm.setUvRange(self.tutorialVideo)\n+        self.card = self.render2d.attachNewNode(self.cm.generate())\n+        self.card.setTexture(self.tutorialVideo)\n+        self.card.setPos(-0, 0, 0)\n+        self.card.reparentTo(self.tutorialMainFrame)\n+        self.tutorialAudio = self.loader.loadSfx(r\"assets/audio/tutorial.mp4\")\n+        self.tutorialVideo.synchronizeTo(self.tutorialAudio)\n+\n+        def PlayblackSliderMethod(self):\n+            self.tutorialAudio.stop()\n+            self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n+            self.currentTime = self.videoPlaybackSlider['value']\n+            self.paused = True\n+        def PausePlayMethod(self):\n+            if self.paused == True:\n+                #When clicked from pause to play\n+                self.paused = False\n+                self.videoPauseButton['image'] = 'assets/images/playIcon.png'\n+            else:\n+                self.paused = True\n+                self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n+            if self.tutorialAudio.status() == self.tutorialAudio.PLAYING:\n+                self.currentTime = self.tutorialAudio.getTime()\n+                self.tutorialAudio.stop()\n+            else:\n+                self.tutorialAudio.setTime(self.currentTime)\n+                self.tutorialAudio.play()\n+        \n+        self.videoPlaybackSlider = DirectSlider(range=(0, self.tutorialVideo.getVideoLength()),\n+                                  value=0, \n+                                  command=PlayblackSliderMethod, \n+                                  frameSize=(-.75, .75, -0.1, 0.1),\n+                                  frameColor=(0.8, 0.8, 0.8, 1),\n+                                  thumb_frameSize=(-.015, .015, -.015, .015),\n+                                  thumb_frameColor=(1, 0, 0, 1),\n+                                  pos=LPoint3f(0, 0, 0),\n+                                  orientation='horizontal', \n+                                  parent=self.tutorialVideoControlFrame,\n+                                  thumb_relief=DGG.FLAT,\n+                                  extraArgs=[self]\n+                                  )\n+        self.videoPauseButton = DirectButton(parent=self.tutorialVideoControlFrame,\n+                                             frameColor=(0.8, 0.8, 0.8, 1),\n+                                             frameSize=(-.05, .05, -0.05, 0.05),\n+                                             pos=LPoint3f(-.9, 0, 0),\n+                                             relief=None,\n+                                             image = 'assets/images/pauseIcon.png',\n+                                             image_pos=(0, 0, 0),\n+                                             image_scale=(0.1, 0.1, 0.1),\n+                                             command=PausePlayMethod,\n+                                             extraArgs=[self]\n+                                             )\n+        self.videoPauseButton.setTransparency(TransparencyAttrib.MAlpha)\n+    def OptionMenu(self):\n+        self.clickSound.play()\n+        self.mouseSettingsOpen = False\n+        self.keyboardSettingsOpen = False\n+        self.audioSettingsOpen = False\n+        self.aboutSettingsOpen = False\n+        \n+        def clear_menu():\n+            if self.mouseSettingsOpen:\n+                self.sensitivityFrame.destroy()\n+                self.sensitivityLabel.destroy()\n+                self.sensitivitySlider.destroy()\n+                self.mouseSettingsOpen = False  \n+            if self.keyboardSettingsOpen:\n+                self.forwardFrame.destroy()\n+                self.backwardFrame.destroy()\n+                self.leftFrame.destroy()\n+                self.rightFrame.destroy()\n+                self.forwardLabel.destroy()\n+                self.backwardLabel.destroy()\n+                self.leftLabel.destroy()\n+                self.rightLabel.destroy()\n+                self.forwardEntry.destroy()\n+                self.backwardEntry.destroy()\n+                self.leftEntry.destroy()\n+                self.rightEntry.destroy()\n+                self.btnSave.destroy()\n+                self.disclamerLabel.destroy()\n+                self.keyboardSettingsOpen = False\n+#            if self.audioSettingsOpen:\n+\n+            if self.aboutSettingsOpen:\n+                self.aboutLabel.destroy()\n+                self.gameAboutLabel.destroy()\n+                self.aboutSettingsOpen = False\n+        self.optionMenuBg = OnscreenImage(image='assets/images/optionMenuBg.png', pos=(0, 0, 0), scale=(.75, .5, 1))\n+        self.optionMenuBg.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.scrolledFrame = DirectScrolledFrame(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-.2, .6, -.8, .7),\n+            pos=LPoint3f(-0.05, 0, 0),\n+            canvasSize=(-.4, .4, -1, 1),\n+            verticalScroll_relief=None,\n+            horizontalScroll_relief=None,\n+        )\n+        self.scrolledFrame.setManageScrollBars()\n+        self.scrolledFrame.verticalScroll['frameSize'] = (-.01, .01, -.01, .01)\n+        self.scrolledFrame.verticalScroll['frameColor'] = (0.4, 0.4, 0.4, 1)\n+        self.scrolledFrame.verticalScroll['thumb_relief'] = DGG.FLAT\n+        self.scrolledFrame.verticalScroll['decButton_relief'] = None\n+        self.scrolledFrame.verticalScroll['incButton_relief'] = None\n+        self.scrolledFrame.horizontalScroll['frameSize'] = None\n+\n+        def MouseSettingMethod(self):\n+            self.sensitivityFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .85),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.sensitivityLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Mouse Sensitivity\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.1, 0, .875), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT\n+                                                )\n+            def changesensitivity():\n+                self.mouse_sensitivity = self.sensitivitySlider['value'] * .2\n+                print(self.sensitivitySlider['value'])      \n+            self.sensitivitySlider = DirectSlider(range=(0,2), \n+                                  value=1, \n+                                  command=changesensitivity, \n+                                  frameSize=(-.25, .25, -0.05, 0.05),\n+                                  frameColor=(0.8, 0.8, 0.8, 1),\n+                                  thumb_frameSize=(-.01, .01, -.01, .01),\n+                                  thumb_frameColor=(0.4, 0.4, 0.4, 1),\n+                                  pos=LPoint3f(-.05, 0, .8),\n+                                  orientation='horizontal', \n+                                  parent=self.scrolledFrame.getCanvas(),\n+                                  thumb_relief=DGG.FLAT\n+                                  )\n+            clear_menu()\n+            self.mouseSettingsOpen = True\n+        def KeyboardSettingMethod(self):\n+            def ForwardKeyMethod(key, self):\n+                self.forwardKey = key\n+            def BackwardKeyMethod(key, self):\n+                self.backwardKey = key\n+            def LeftKeyMethod(key, self):\n+                self.leftKey = key\n+            def RightKeyMethod(key, self):\n+                self.rightKey = key\n+            def SaveMethod(self):\n+                if not hasattr(self, 'forwardKey'):\n+                    self.forwardKey = 'w'\n+                if not hasattr(self, 'backwardKey'):\n+                    self.backwardKey = 's'\n+                if not hasattr(self, 'leftKey'):\n+                    self.leftKey = 'a'\n+                if not hasattr(self, 'rightKey'):\n+                    self.rightKey = 'd'\n+                self.keys = {\n+                    self.forwardKey: \"forward\",\n+                    self.backwardKey: \"backward\",\n+                    self.leftKey: \"left\",\n+                    self.rightKey: \"right\",\n+                    'space': \"up\",\n+                    'e': \"down\"\n+                }\n+            self.forwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Forward\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.2, 0, .875), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.backwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Backward\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.19, 0, .625), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.leftLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Left\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.25, 0, .375), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.rightLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                text=\"Right\", \n+                                                text_scale=0.05, \n+                                                pos=LPoint3f(-.24, 0, .125), \n+                                                parent=self.scrolledFrame.getCanvas(), \n+                                                relief=DGG.FLAT,\n+                                                sortOrder=2\n+                                                )\n+            self.forwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .825),\n+                                                text_pos= (-0.1, -.015),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=ForwardKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='W'\n+                                                )\n+            self.backwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .575),\n+                                                text_pos= (-0.1, -.015),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=BackwardKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='S'\n+                                                )\n+            self.leftEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .325),\n+                                                text_pos= (-0.1, -.015),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=LeftKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='A'\n+                                                )\n+            self.rightEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n+                                                frameSize=(-.15, 0, -0.03, 0.03),\n+                                                pos=LPoint3f(-.15, 0, .075),\n+                                                text_pos= (-0.1, -.015),    \n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT,\n+                                                text_scale=0.05,\n+                                                sortOrder=2,\n+                                                command=RightKeyMethod,\n+                                                extraArgs=[self],\n+                                                initialText='D'\n+                                                )\n+            self.forwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .85),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.backwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .6),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.leftFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .35),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.rightFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                                frameSize=(-.3, .3, -0.1, 0.1),\n+                                                pos=LPoint3f(-.05, 0, .1),\n+                                                parent=self.scrolledFrame.getCanvas(),\n+                                                relief=DGG.FLAT\n+                                                )\n+            self.btnSave = DirectButton(\n+                frameColor=(0.2, 0.2, 0.2, 1),\n+                frameSize=(-0.09, 0.09, -0.025, 0.05),\n+                text='Save',\n+                text_scale=0.05,\n+                text_fg=(0.5, 0.5, 0.5, 1),\n+                pos=LPoint3f(-0.25, 0, -0.075),\n+                relief=1,\n+                parent=self.scrolledFrame.getCanvas(),\n+                command=SaveMethod,\n+                extraArgs=[self],\n+                sortOrder=2\n+            )\n+            self.disclamerLabel = DirectLabel(\n+                frameColor=(0.6, 0.6, 0.6, 1),\n+                text=\"*Press enter each key*\",\n+                text_scale=0.05,\n+                pos=LPoint3f(0, 0, -0.2),\n+                parent=self.scrolledFrame.getCanvas(),\n+                relief=None\n+            )\n+            clear_menu()\n+            self.keyboardSettingsOpen = True\n+        def AboutSettingMethod(self):\n+            self.aboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                        text=\"About\",\n+                                        text_scale=0.1,\n+                                        pos=LPoint3f(-0.025, 0, 0.85),\n+                                        parent=self.scrolledFrame.getCanvas(),\n+                                        relief=None\n+                                        )\n+            self.gameAboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n+                                            text= \"TSA Videogame Design 2025-2026 \\n '' is a  game developed by \\n  the team 1034-1 for the 2025-2026 \\n  \\\n+                                            Technology Student Association Competition for Video Game Design. \\n this is a  based on the theme of \\n\\\n+                                            We developed this game using \\n the Panda3D game engine \\n differing from Unity and Unreal as \\n it is a purely text edited engine\",\n+                                            text_scale=0.04,\n+                                            pos=LPoint3f(-0.04, 0, 0.3),\n+                                            parent=self.scrolledFrame.getCanvas(),\n+                                            relief=None\n+                                            )\n+            clear_menu()\n+            self.aboutSettingsOpen = True\n+        self.btnMouse = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.13),\n+            pos=LPoint3f(-0.37666, 0, 0.57666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/mouseIcon.png',\n+            image_scale = (.09, .09, .09),\n+            image_pos = (0, 0, 0.03),\n+            image_hpr = (0, 0, 0),\n+            command=MouseSettingMethod,\n+            extraArgs=[self],\n+        )\n+        self.btnMouse.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.btnKeyboard = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.376666, 0, 0.33666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/keyboardIcon.png',\n+            image_scale = (.09, .09, .09),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=KeyboardSettingMethod,\n+            extraArgs=[self],\n+        )\n+        self.btnKeyboard.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.btnAudioSet = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.37666, 0, 0.09666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/audioIcon.png',\n+            image_scale = (.07, .07, .07),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=self.playButtonMethod.set_result,\n+            extraArgs=[None],\n+        )\n+        self.btnAudioSet.setTransparency(TransparencyAttrib.MAlpha)\n+        \n+        self.btnAbout = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.37666, 0, -0.13666),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/aboutIcon.png',\n+            image_scale = (.07, .07, .07),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=AboutSettingMethod,\n+            extraArgs=[self],\n+        )\n+        self.btnAbout.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        def close_menu():\n+            self.scrolledFrame.destroy()\n+            self.optionMenuBg.destroy()\n+            self.btnAbout.destroy()\n+            self.btnAudioSet.destroy()\n+            self.btnKeyboard.destroy()\n+            self.btnMouse.destroy()\n+            self.btnExit.destroy()\n+            clear_menu()\n+\n+        self.btnExit = DirectButton(\n+            frameColor=(0.4, 0.4, 0.4, 1),\n+            frameSize=(-0.09, 0.09, -0.07, 0.14),\n+            pos=LPoint3f(-0.5, 0, 0.75),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=None,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/exitIcon.png',\n+            image_scale = (.07, .07, .07),\n+            image_pos = (0, 0, .03),\n+            image_hpr = (0, 0, 0),\n+            command=close_menu,\n+        )\n+        self.btnExit.setTransparency(TransparencyAttrib.MAlpha)\n+    def MainMenu(self):\n+        self.inaMenu = True\n+        self.mainMenuBackground = OnscreenImage(image='assets/images/mainMenuBackground.png', pos=(0, 0, 0), scale=(1.5, 1.5, 1.5))\n+        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.25, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n+        self.titleText.setFont(self.Font)\n+        self.btnPlay = DirectButton(\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.2, 0.2, -0.03, 0.06),\n+            pos=LPoint3f(0, 0, -0.1),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Play',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.05, 0.05),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=self.playButtonMethod.set_result,\n+            extraArgs=[None],\n+        )\n+\n+        self.btnOption= DirectButton(\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.3, 0.3, -0.03, 0.06),\n+            pos=LPoint3f(-1.2, 0, -0.87),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=None,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/optionIcon.png',\n+            image_scale = (.1, .1, .1),\n+            command=self.OptionMenu,\n+            extraArgs=[],\n+        )\n+        self.btnOption.setTransparency(TransparencyAttrib.MAlpha)\n+\n+        self.btnTutorial= DirectButton(\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.3, 0.3, -0.03, 0.06),\n+            pos=LPoint3f(1.2, 0, -0.87),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=None,\n+            scale=LVecBase3f(1, 1, 1),\n+            image= 'assets/images/tutorialIcon.png',\n+            image_scale = (.1, .1, .1),\n+            command=self.TutorialMenu,\n+            extraArgs=[],\n+        )\n+        self.btnTutorial.setTransparency(TransparencyAttrib.MAlpha)\n+    def PauseMenu(self):\n+        self.clickSound.play()\n+        self.CameraOperator()\n+        def LoadMainMenu(self):\n+            #Keep AI here, dont remove .setup and reenter waves\n+            self.clickSound.play()\n+            taskMgr.remove('Update')\n+            self.SaveProgress()\n+            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n+            self.cam_controller.setup(keys=self.keys)\n+            self.cam_controller.disable()\n+            self.HealthBar.destroy()\n+            self.playButtonMethod = AsyncFuture()\n+            self.MainMenu()\n+            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n+            for child in children_to_remove:\n+                if '__Actor_modelRoot' in child.getName():\n+                    child.cleanup()\n+                else:    \n+                    child.removeNode()\n+            self.pauseFrame.destroy()\n+            self.btnMainMenu.destroy()\n+            self.btnResume.destroy()\n+            taskMgr.add(self.loadScene())\n+        def Resume(self):\n+            self.clickSound.play()\n+            self.pauseFrame.destroy()\n+            self.btnMainMenu.destroy()\n+            self.btnResume.destroy()\n+            self.CameraOperator()\n+        self.pauseFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n+                                    frameSize=(-.5, .5, -0.3, 0.35),\n+                                    pos=LPoint3f(0, 0, 0),\n+                                    hpr=LVecBase3f(0, 0, 0),\n+                                    relief=DGG.FLAT,\n+                                    scale=LVecBase3f(1, 1, 1))\n+        self.btnMainMenu = DirectButton(\n+            parent=self.pauseFrame,\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.4, 0.4, -0.08, 0.16),\n+            pos=LPoint3f(0, 0, -0.15),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Save & Exit',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.1, 0.1),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=LoadMainMenu,\n+            extraArgs=[self],\n+        )\n+        self.btnResume = DirectButton(\n+            parent=self.pauseFrame,\n+            frameColor=(0.15, 0.15, 0.15, 1),\n+            frameSize=(-0.4, 0.4, -0.08, 0.16),\n+            pos=LPoint3f(0, 0, 0.15),\n+            hpr=LVecBase3f(0, 0, 0),\n+            relief=1,\n+            scale=LVecBase3f(1, 1, 1),\n+            text='Resume',\n+            text_align=TextNode.A_center,\n+            text_scale=(0.1, 0.1),\n+            text_pos=(0, 0),\n+            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+            text_bg=LVecBase4f(0, 0, 0, 0),\n+            command=Resume,\n+            extraArgs=[self],\n+        )\n+    # This function is called when the mouse is clicked, calling a function based on what is clicked in game\n+    async def click(self, task):\n+        # Perform collision traversal\n+        self.cTrav.traverse(self.render)\n+        #print(self.ball.getPos())\n+        try:\n+            # Process collisions\n+            num_collisions = self.collision_queue.getNumEntries()\n+\n+            if num_collisions > 1:\n+                self.collision_queue.sortEntries()\n+                entry = self.collision_queue.getEntry(1)  # Get the closest collision\n+                hit_node = entry.getIntoNode()\n+                # Check if the hit node is the model that is supposed to be clicked using something like this:\n+#                for enemy in list(self.enemy.EnemyDict['collision'].values()):\n+#                    if hit_node.getName() == enemy.getName():\n+#                        self.enemyController.EnemyHit(enemy)\n+#                        await Task.pause(.2)\n+        except AssertionError as e:\n+            print(\"AssertionError occurred during collision processing.\")\n+            print(e)\n+        except KeyError as e:\n+            print(\"KeyError occurred during collision processing.\")\n+            pass\n+        return Task.cont\n+    def shader(self, nodes = None, EnterNode = None):\n+        self.currentModels = []\n+        if not hasattr(self, 'Shader_setup'):\n+            self.Shader_setup = None\n+            print(PandaSystem.getPlatform())\n+            if PandaSystem.getPlatform() == 'win_amd64' or PandaSystem.getPlatform() == 'osx_aarch64':\n+                shaders = [f\"{os.path.dirname(__file__)}/assets/shaders/Shader.vert\", f\"{os.path.dirname(__file__)}/assets/shaders/Shader.frag\"]\n+                patchedShaders = []\n+                for file in shaders:    \n+                    with open(file, 'r') as file:\n+                        code = file.read()\n+                        code = code.replace(\"#version 300 es\", \"#version 330\")\n+                        code = \"\\n\".join(\n+                            line for line in code.splitlines()\n+                            if not line.strip().startswith(\"precision\")\n+                        )\n+                        patchedShaders.append(code)\n+                self.Shader = Shader.make(Shader.SL_GLSL, patchedShaders[0], patchedShaders[1])\n+            else:\n+                self.Shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/Shader.vert\", \"assets/shaders/Shader.frag\")\n+            shadow_buffer = self.win.make_texture_buffer(\"ShadowBuffer\", 1024, 1024)\n+            shadow_buffer.set_sort(-100)\n+            shadow_buffer.set_clear_color((1, 1, 1, 1))\n+            self.shadow_map = shadow_buffer.get_texture()\n+            self.shadow_map.set_minfilter(SamplerState.FT_shadow)\n+            self.shadow_map.set_magfilter(SamplerState.FT_shadow)\n+\n+            self.shadow_cam = self.make_camera(shadow_buffer, lens=OrthographicLens())\n+            self.shadow_cam.reparent_to(self.sunLightNP)\n+\n+            shadow_scene = self.render.copy_to(NodePath(\"shadow_scene\"))\n+            shadow_scene.set_shader(Shader.load(Shader.SL_GLSL, \"assets/shaders/shadow_depth.vert\", \"assets/shaders/shadow_depth.frag\"))\n+            self.shadow_cam.node().set_scene(shadow_scene)\n+        if EnterNode == None:\n+            for node in nodes:\n+                self.currentModels.append(node)\n+                node.setShader(self.Shader)\n+                node.setShaderInput(\"shadowMap\", self.shadow_map)\n+                node.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n+                node.setShaderInput(\"diffuseTex\", node.find_texture(\"*\"))\n+                node.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n+                node.setShaderInput(\"light0_color\", Vec3(.5, .75, 0.85))\n+                node.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n+                node.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n+                node.setShaderInput(\"material_shininess\", 10.0)\n+                node.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n+                node.setShaderInput(\"cameraPos\", self.camera.getPos(self.render))\n+\n+        else:\n+            self.currentModels.append(EnterNode)\n+            EnterNode.setShader(self.Shader)\n+            EnterNode.setShaderInput(\"shadowMap\", self.shadow_map)\n+            EnterNode.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n+            EnterNode.setShaderInput(\"diffuseTex\", EnterNode.find_texture(\"*\"))\n+            EnterNode.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n+            EnterNode.setShaderInput(\"light0_color\", Vec3(.75, .75, 0.5))\n+            EnterNode.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n+            EnterNode.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n+            EnterNode.setShaderInput(\"material_shininess\", 15.0)\n+            EnterNode.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n+    # This function loads the models in the background, reducing lag and improving performance\n+    async def loadScene(self):\n+\n+        # in case of death, we need to reload the bool\n+        if hasattr(self, '_player_died'):\n+            delattr(self, '_player_died')  # Remove self._player_died\n+        \n+        if hasattr(self, '_player_won'):\n+            delattr(self, '_player_won')  # Remove self._player_won\n+            \n+        with open(f'{os.path.dirname(__file__)}/save.txt', 'r') as f:\n+            line = f.readline()\n+            line = line.replace('LPoint3f(', '').replace(')', '')\n+            x, y, z = map(float, line.split(','))\n+        \n+\n+        self.camera.setPos(x, y, z)\n+\n+        # Load the models in the background, each time suspending this\n+        # method until they are done\n+        self.worldCollisionModel = await self.loader.loadModel(\"assets/models/worldTriangles.bam\", blocking=False)\n+        self.worldVisibleModel = await self.loader.loadModel(\"assets/models/worldVisible.bam\", blocking=False)\n+\n+        # Create a background for the world\n+        \n+        self.world_bg = await self.loader.loadModel(\"assets/models/skybox.bam\",blocking=False)\n+        self.world_bg.reparent_to(self.render)\n+        self.world_bg.set_scale(2500)\n+\n+        world_bg_texture = self.loader.loadTexture(\"assets/images/world_bg.png\")\n+        world_bg_texture.set_minfilter(SamplerState.FT_linear)\n+        world_bg_texture.set_magfilter(SamplerState.FT_linear)\n+        world_bg_texture.set_wrap_u(SamplerState.WM_repeat)\n+        world_bg_texture.set_wrap_v(SamplerState.WM_mirror)\n+        world_bg_texture.set_anisotropic_degree(200)\n+        self.world_bg.set_texture(world_bg_texture)\n+        world_bg_shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/world_bg.vert.glsl\", \"assets/shaders/world_bg.frag.glsl\")\n+        self.world_bg.set_shader(world_bg_shader) \n+        \n+        # Create a collision node for the world\n+        self.world_collision_node = self.worldCollisionModel.find(\"**/+CollisionNode\")\n+        self.worldCollisionModel.hide()\n+        self.cTrav.addCollider(self.world_collision_node, self.pusher)\n+        self.pusher.addCollider(self.world_collision_node, self.worldCollisionModel)\n+\n+        # Set up Lighting System\n+        self.sunLight = DirectionalLight('directionalLight')\n+        self.sunLight.setShadowCaster(True, 16384, 16384)\n+        self.sunLightNP = self.render.attachNewNode(self.sunLight)\n+        self.sunLightNP.setHpr(45, 45, 0)\n+        self.sunLight.setColor((1.5, 1.5, 1.5, 1))\n+        \n+        self.sunModel = await self.loader.loadModel(\"assets/models/sun.bam\", blocking=False)\n+        self.sunModel.setPos(150, -150, 200)\n+\n+        print(self.sunModel)\n+        ambientLight = AmbientLight('ambientLight')\n+        ambientLight.setColor((0.1, 0.1, 0.1, 1))\n+        ambientLightNP = self.render.attachNewNode(ambientLight)\n+        \n+        # Set the shaders\n+        ''' Most of the time this is very custom. Though there is a pipeline that can be used\n+            Most of this stuff can be recycled\n+        '''\n+        self.shader([self.sunModel, self.worldVisibleModel])\n+        \n+        # Wait for the player to start the game\n+        await self.playButtonMethod\n+        self.clickSound.play()\n+\n+        # Remove the main menu\n+        self.titleText.destroy()\n+        self.btnPlay.destroy()\n+        self.mainMenuBackground.destroy()\n+        self.btnOption.destroy()\n+        self.btnTutorial.destroy()\n+\n+        # Create a loading screen\n+        print(\"Loading Screen\")\n+        Loading_text = OnscreenText(\"Loading\", scale=2, parent=self.a2dTopCenter, pos=(0, 0), fg=(1, 1, 1, 1), align=TextNode.ACenter)\n+\n+        self.HealthBar = DirectWaitBar(text=\"Hull\", value=100, pos=(-.85, -15, -.7))\n+        self.HealthBar['barColor'] = (0, 2, 0, 2)\n+        self.HealthBar['text_scale'] = .05\n+        self.HealthBar['frameSize'] = (-.35, .35, -.035, .02)\n+        self.HealthBar['barRelief']= DGG.SUNKEN\n+\n+        self.HullBar = DirectWaitBar(text=\"Fuel\", value=100, pos=(-.85, -1, -.8))\n+        self.HullBar['barColor'] = (2, .5, 0, 2)\n+        self.HullBar['text_scale'] = .05\n+        self.HullBar['frameSize'] = (-.35, .35, -.035, .02)\n+        self.HullBar['barRelief']= DGG.SUNKEN\n+\n+        # Reparent the models to the render, making the world, and set the lights\n+        self.worldCollisionModel.reparentTo(self.render)\n+        self.worldVisibleModel.reparentTo(self.render)\n+        self.render.setLight(self.sunLightNP)\n+        self.render.setLight(ambientLightNP)\n+        self.sunModel.reparentTo(self.render)\n+        \n+        # Add HUD\n+        self.PlayerHUD()\n+        \n+        # Add a Pause Menu\n+        pausetext = OnscreenText(\"To Pause press P\", pos=(-1.14, 0.95), scale=0.05, fg=(0, 0, 0, 1), align=TextNode.ACenter)\n+        self.accept('p', self.PauseMenu)\n+\n+        # initialize the camera controller\n+        self.CameraOperator()\n+        \n+        \n+        \n+#        self.researchLocationEffect.start(parent=self.render, renderParent=self.render)\n+#        self.researchLocationEffect.setPos(0, 0, 250)\n+\n+        #self.ball = self.loader.loadModel(\"assets/models/sun.bam\")\n+        #self.ball.reparentTo(self.render)\n+        #self.ballDown = False\n+        # Start the update cycle\n+        taskMgr.add(self.Update, \"Update\")        \n+        self.accept('mouse1-up', self.MouseUp)\n+        Loading_text.destroy() \n+\n+    # The Update cycle, this function should be used to update positions and anything that needs to be updated\n+    def Update(self, task):\n+        camera_forward = self.camera.getQuat(self.render).getForward()\n+        camera_up = self.camera.getQuat(self.render).getUp()\n+        camera_right = self.camera.getQuat(self.render).getRight()\n+        camera_position = self.camera.getPos(self.render)\n+\n+        self.dayNightCycle()\n+#            ak47_position = (\n+#                camera_position +\n+#                camera_forward * 2.67 -  # Forward by 1.0 units\n+#                camera_up * 1 +       # Downward by 0.5 units\n+#                camera_right * 0.8      # Rightward by 0.3 units\n+#            )\n+#            self.ak47.setPos(ak47_position)\n+#            self.ak47.setHpr(self.camera.getH(), 0, 90)\n+        \n+        self.worldCollisionModel.setPos(0, 0, 0)\n+        \n+        self.HealthBar['value'] = self.PlayerHealth\n+\n+        if self.PlayerHealth < 0 and not hasattr(self, '_player_died'):\n+            self._player_died = None\n+            self.Death()\n+        \n+        if not True:\n+            self._player_won = None\n+            self.CameraOperator()\n+            def LoadMainMenu(self):\n+                self.clickSound.play()\n+                taskMgr.remove('Update')\n+                self.SaveProgress(reset=True)\n+                self.HealthBar.destroy()\n+                self.playButtonMethod = AsyncFuture()\n+                self.MainMenu()\n+                self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n+                self.cam_controller.setup(keys=self.keys)\n+                self.cam_controller.disable()\n+                self.currentwave = 0\n+                children_to_remove = [child for child in self.render.getChildren() if child not in self.camera]\n+                for child in children_to_remove:\n+                    if '__Actor_modelRoot' in child.getChildren():\n+                        child.cleanup()\n+                    else:    \n+                        child.removeNode()\n+                self.winFrame.destroy()\n+                self.btnMainMenu.destroy()\n+                taskMgr.add(self.loadScene())\n+            self.winFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n+                                        frameSize=(-1.4, 1.4, -1., 1), \n+                                        pos=(0, 0, 0), \n+                                        scale=(1, 1, 1), \n+                                        text=\"You Won!\", \n+                                        text_font=self.Font,\n+                                        text_scale=0.5, \n+                                        text_pos=(0, .25), \n+                                        text_fg=(0, 0, 1, 1), \n+                                        text_align=TextNode.ACenter)\n+            self.btnMainMenu = DirectButton(\n+                parent=self.winFrame,\n+                frameColor=(0.15, 0.15, 0.15, 1),\n+                frameSize=(-0.4, 0.4, -0.08, 0.16),\n+                pos=LPoint3f(0, 0, -0.15),\n+                hpr=LVecBase3f(0, 0, 0),\n+                relief=1,\n+                scale=LVecBase3f(1, 1, 1),\n+                text='Exit to Main Menu',\n+                text_align=TextNode.A_center,\n+                text_scale=(0.075, 0.075),\n+                text_pos=(0, 0),\n+                text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n+                text_bg=LVecBase4f(0, 0, 0, 0),\n+                command=LoadMainMenu,\n+                extraArgs=[self],\n+            )\n+        if not self.ballDown:\n+            pos = self.camera.getPos(self.render)\n+            forward = self.camera.getQuat(self.render).getForward()\n+            self.ball.setPos(pos + forward * 50)\n+\n+        return Task.cont\n+    def __init__(self, Plot: 'Plot'):\n+        super().__init__()\n+        \n+        self.currentwave = 0\n+\n+        # Defining the Traverser, the task that checks for collisions, and the pusher, the task that pushes objects when it collides\n+        # The Traverser reports to the pusher, we also need to tell Panda3d which objects respond to collisions\n+        self.cTrav = CollisionTraverser()\n+        self.pusher = CollisionHandlerPusher()\n+\n+        # Camera setup\n+        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5\n+                                                        ,mouse_sensitivity=self.mouse_sensitivity\n+                                                        ,lockPitch=False)\n+        self.cam_controller.setup(keys=self.keys)\n+        self.cam_controller.disable()\n+        camera_collision_node = CollisionNode('camera')\n+        camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n+        camera_collision_node_path = self.camera.attachNewNode(camera_collision_node)\n+        camera_collision_node_path.setCollideMask(BitMask32.bit(2))\n+  \n+        # Add the collision nodes to the traverser. This is how we tell Panda3d which objects respond to collisions  \n+        self.cTrav.addCollider(camera_collision_node_path, self.pusher) \n+        self.pusher.addCollider(camera_collision_node_path, self.camera)\n+\n+        #   We load the tasks in the background to reduce lag\n+        self.playButtonMethod = AsyncFuture()\n+        taskMgr.add(self.loadScene())\n+        \n+        #  Tell Panda3d to listen for mouse clicks\n+        self.accept('mouse1', self.MouseIn)\n+        self.Font = self.loader.loadFont('assets/fonts/propaganda.ttf')\n+        self.Font.setPixelsPerUnit(120)\n+\n+        self.clickSound = self.loader.loadSfx('assets/audio/click.ogg')\n+\n+        self.enableParticles()\n+\n+#        self.messenger.toggleVerbose()\n+        self.accept('x', self.exportScene)\n+\n+        self.Plot = Plot(self)\n+\n+        # Open the main menu\n+        self.MainMenu()\n+\n+class Plot():\n+    async def plotLine(self, task):\n+        print('loading plot line')\n+        self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n+        self.researchNode.setPosHpr(0, 0, 250, 0, 90, 0)\n+        self.researchCollisionNode = self.researchNode.find(\"**/+CollisionNode\")\n+        self.researchNode.reparentTo(self.gameInstance.render)\n+        self.gameInstance.cTrav.addCollider(self.researchCollisionNode, self.gameInstance.pusher)\n+        self.gameInstance.pusher.addCollider(self.researchCollisionNode, self.researchNode)\n+        self.researchLocationEffect = ParticleEffect()\n+        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n+        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n+        self.researchLocationEffect.clearShader()\n+        self.researchLocationEffect.start(self.researchNode, self.researchNode)\n+        await self.plotAsync\n+        print('very cool')\n+    async def conditionBasedAdvancer(self, task):\n+        for i in range(self.eventCounter):\n+            if self.plotCondition[i]:\n+                self.eventAdvanceFunc['finish']()\n+                await self.advanceAsync\n+    def __init__(self, gameInstance):\n+        self.gameInstance = gameInstance\n+        self.plotAsync = AsyncFuture()\n+        self.advanceAsync = AsyncFuture()\n+        self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n+        self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n+        self.plotCondition = [True if hasattr(self.gameInstance, 'collision_queue') and self.gameInstance.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == gameInstance.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n+        self.eventCounter = len(self.plotCondition)\n+        self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n+        print('Initializing plot line')\n+        taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n+        taskMgr.add(self.plotLine, \"PlotLine\")\n+\n+game = Game(Plot)\n+base.run()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1763583853930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1353,12 +1353,12 @@\n                 text_bg=LVecBase4f(0, 0, 0, 0),\n                 command=LoadMainMenu,\n                 extraArgs=[self],\n             )\n-        if not self.ballDown:\n-            pos = self.camera.getPos(self.render)\n-            forward = self.camera.getQuat(self.render).getForward()\n-            self.ball.setPos(pos + forward * 50)\n+        #if not self.ballDown:\n+        #    pos = self.camera.getPos(self.render)\n+        #    forward = self.camera.getQuat(self.render).getForward()\n+        #    self.ball.setPos(pos + forward * 50)\n \n         return Task.cont\n     def __init__(self, Plot: 'Plot'):\n         super().__init__()\n@@ -1440,1449 +1440,5 @@\n         taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n         taskMgr.add(self.plotLine, \"PlotLine\")\n \n game = Game(Plot)\n-base.run()\n-# /// script\n-# dependencies = [\n-#    \"panda3d\",\n-# ]\n-# ///\n-\n-'''\n-Game made by: Adeel Siddiqi and\n-This is\n-A game made for TSA Videogame design 2025-2026 \n-'''\n-__author__ = 'Adeel Siddiqi'\n-\n-import os\n-import random\n-from direct.actor.Actor import Actor\n-from direct.showbase.ShowBase import ShowBase\n-from direct.task import Task\n-from direct.showbase.DirectObject import DirectObject\n-from direct.controls.InputState import InputState\n-from direct.particles.ParticleEffect import ParticleEffect\n-import direct.gui.DirectGuiGlobals as DGG\n-from panda3d.ai import AIWorld, AICharacter\n-from panda3d.core import (\n-    PandaSystem,\n-    FrameBufferProperties, \n-    WindowProperties, \n-    GraphicsOutput,\n-    StringStream,\n-    AsyncFuture,\n-    LVecBase3f,\n-    LVecBase4f,\n-    LPoint3f, \n-    NodePath,\n-    TextNode, \n-    CollisionTraverser, \n-    CollisionNode, \n-    CollisionHandlerPusher, \n-    CollisionSphere, \n-    CollisionBox,\n-    LVector3, \n-    CollisionRay, \n-    BitMask32, \n-    CollisionHandlerQueue,\n-    loadPrcFileData,\n-    CollisionTraverser,\n-    BitMask32,\n-    TransparencyAttrib,\n-    CardMaker,\n-    SamplerState,\n-    VirtualFileSystem,\n-    Filename,\n-    DirectionalLight,\n-    AmbientLight,\n-    Camera,\n-    OrthographicLens,\n-    Texture,\n-    Vec3,\n-    Vec4,\n-    Shader,\n-    CollisionHandlerEvent\n-)\n-from direct.gui.DirectGui import (\n-    OnscreenImage,\n-    OnscreenText, \n-    DirectButton,\n-    DirectSlider,\n-    DirectScrolledFrame,\n-    DirectLabel,\n-    DirectFrame,\n-    DirectEntry,\n-    DirectWaitBar\n-)\n-loadPrcFileData('', 'gl-version 4 1')\n-'''\n-The camera controller is a class that handles the movement and rotation of the camera in the game.\n-This is the core of the camera, and it is responsible for handling the input from the user and updating the camera accordingly.\n-The default values are set to 9 for velocity and 0.2 for mouse sensitivity, and the initial position of the camera is set to (-0.5, -12, 7.7).\n-The default view is First Person. I will add a third person view later\n-'''\n-class CameraControllerBehaviour(DirectObject):\n-    _instances = 0\n-    def __init__(self, camera, velocity=9, gravity=-2, mouse_sensitivity=0.2, initial_pos=(0, 0, 0), lockPitch = False, showbase=None):\n-        self._camera = camera\n-        self._velocity = velocity\n-        self._mouse_sensitivity = mouse_sensitivity\n-        self._keys = None\n-        self._input_state = InputState()\n-        self._lockPitch = lockPitch\n-        self._heading = 0.0\n-        self._pitch = 0.0\n-        self._yaw = 0.0\n-        self._roll = 0.0\n-        self._prev_mouse = None\n-        self._showbase = base if showbase is None else showbase\n-        self._gravity = LVector3(0, 0, gravity)  # Set gravity vector pointing downward\n-        self._instance = CameraControllerBehaviour._instances\n-        CameraControllerBehaviour._instances += 1\n-        self._camera.setPos(*initial_pos)\n-        # Set the initial position of the camera\n-\n-    def setup(self, keys={\n-        'w':\"forward\", \n-        's':\"backward\",\n-        'a':\"left\",\n-        'd':\"right\",\n-        'space':\"up\",\n-        'e':\"down\"\n-    }):\n-        self._keys = keys\n-        for key in self._keys:\n-            self._input_state.watchWithModifiers(self._keys[key], key)\n-\n-        self._showbase.disableMouse()\n-\n-        props = WindowProperties()\n-        props.setMouseMode(WindowProperties.MConfined)\n-        props.setCursorHidden(True)\n-\n-        self._showbase.win.requestProperties(props)\n-        \n-        self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n-    \n-    def rewatch(self, keys=None, mouse_sensitivity=.2):\n-        if keys is not None:\n-            self._keys = keys\n-        for key in self._keys:\n-            self._mouse_sensitivity = mouse_sensitivity\n-            self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n-            self._input_state.watchWithModifiers(self._keys[key], key)\n-    \n-    def destroy(self):\n-        self.disable()\n-        self._input_state.delete()\n-\n-        del self\n-\n-    @property\n-    def velocity(self):\n-        return self._velocity\n-\n-    @velocity.setter\n-    def velocity(self, velocity):\n-        self._velocity = velocity\n-    \n-    @property\n-    def mouse_sensitivity(self):\n-        return self._mouse_sensitivity\n-\n-    @mouse_sensitivity.setter\n-    def mouse_sensitivity(self, sensitivity):\n-        self._mouse_sensitivity = sensitivity\n-\n-    def disable(self):\n-        self._showbase.taskMgr.remove(\"UpdateCameraTask\" + str(self._instance))\n-\n-        props = WindowProperties()\n-        props.setCursorHidden(False)\n-\n-        self._showbase.win.requestProperties(props)\n-                \n-    def update(self, task):\n-        dt = globalClock.getDt()\n-        \n-        # Get mouse movement for rotation\n-        md = self._showbase.win.getPointer(0)\n-        x = md.getX()\n-        y = md.getY()\n-        #center_x = self._showbase.win.getXSize() // 2\n-        #center_y = self._showbase.win.getYSize() // 2\n-\n-        if self._prev_mouse is not None:\n-            prev_x, prev_y = self._prev_mouse\n-            self._yaw = self._yaw - (x - prev_x) * self._mouse_sensitivity\n-            self._pitch = self._pitch - (y - prev_y) * self._mouse_sensitivity\n-        self._prev_mouse = (x, y)\n-\n-        # Clamp or lock the pitch to prevent camera flipping over\n-        self._pitch = 0 if self._lockPitch else max(-89, min(89, self._pitch))\n-        \n-        # Set the camera's orientation\n-        self._showbase.camera.setHpr(self._yaw, self._pitch, self._roll)\n-        \n-        # Access the camera's lens and set the focal length\n-        lens = self._showbase.cam.node().getLens()\n-        lens.setFocalLength(0.25)\n-        \n-        # Calculate the position increment\n-        pos_increment = self._velocity * dt\n-        \n-        # Handle keyboard input for movement\n-        if  self._input_state.isSet('forward'):\n-            self._showbase.camera.setY(self._showbase.camera, pos_increment)\n-\n-        if  self._input_state.isSet('backward'):\n-            self._showbase.camera.setY(self._showbase.camera, -pos_increment)\n-\n-        if  self._input_state.isSet('left'):\n-            self._showbase.camera.setX(self._showbase.camera, -pos_increment)\n-\n-        if  self._input_state.isSet('right'):\n-            self._showbase.camera.setX(self._showbase.camera, pos_increment)\n-\n-        if  self._input_state.isSet('up'):\n-            self._showbase.camera.setZ(self._showbase.camera, pos_increment)\n-\n-        if  self._input_state.isSet('down'):\n-            self._showbase.camera.setZ(self._showbase.camera, -pos_increment)\n-        \n-        self.cam_pos = self._showbase.camera.getPos(self._showbase.render)\n-        # Apply gravity to the camera's position\n-        (self.cam_pos) += self._gravity * min(dt, 1/64.0)\n-        \n-        # Update the camera's position\n-        self._showbase.camera.setPos(self.cam_pos)\n-\n-        return Task.cont\n-\n-class EnemyController():\n-    def __init__(self, showbase=None):\n-        self.showbase = base if showbase is None else showbase\n-        self.EnemyModelDict = {}\n-        self.EnemyAIDotDict = {}\n-        self.EnemyCollisionDict = {}\n-        self.EnemyAICharDict = {}\n-        self.EnemyAIBehaviourDict = {}\n-        self.EnemyHealthDict = {}\n-        self.EnemyAnimControlDict = {}\n-        self.EnemyDict = {'model':self.EnemyModelDict,\n-                          'ai_dot':self.EnemyAIDotDict,\n-                          'collision':self.EnemyCollisionDict,\n-                          'ai_char':self.EnemyAICharDict,\n-                          'ai_behaviour':self.EnemyAIBehaviourDict,\n-                          'health':self.EnemyHealthDict,\n-                          }\n-        self.EnemyAIWorld = AIWorld(self.showbase.render)\n-        self.EnemyCollisionHandler = CollisionHandlerEvent()\n-        self.EnemyCollisionHandler.addInPattern('into-camera')\n-        self.showbase.accept(\"into-camera\",self.DamagePlayer)\n-\n-        #Because it will spam message in update\n-        self.Messagesent = False\n-        self.Run = True\n-        self._gravity = LVector3(0, 0, -2)\n-        self.EnemyCount = 0\n-        self.waveCount = 1\n-        self.Font = self.showbase.loader.loadFont('assets/fonts/propaganda.ttf')\n-    async def setup(self, modelpath, extraAnims, num, height, health, waves= 5, changePerWave=1):\n-        self.waveMethod = AsyncFuture()\n-        self.num = num\n-        self.Run = True\n-        # Creating the wave count\n-        self.WaveCounttext = OnscreenText(text=\"Wave: 1\", pos=(0,0.9), scale=0.1)\n-        self.WaveCounttext.setFont(self.Font)\n-        for i in range(waves):\n-            for j in range(self.num):\n-                if self.waveCount > i:\n-                    continue    \n-                if self.Run == False:\n-                    print('Break')\n-                    break\n-                # Set up models and make them loop animations\n-                self.EnemyModelDict['enemy' + str(j)] = Actor(modelpath, extraAnims if extraAnims is not None else None)\n-                self.EnemyModelDict['enemy' + str(j)].loop(self.EnemyModelDict['enemy' + str(j)].getAnimNames()[0])\n-                self.EnemyModelDict['enemy' + str(j)].reparentTo(self.showbase.render)\n-                self.EnemyModelDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n-                \n-                # Set up shaders, pretty custom\n-                game.shader(EnterNode=self.EnemyModelDict['enemy' + str(j)])\n-\n-                # We need to use a place holder model because the model will point at the user, so we just set position of the actual model\n-                self.EnemyAIDotDict['enemy' + str(j)] = self.showbase.loader.loadModel(\"assets/models/aidotupdater.bam\")\n-                self.EnemyAIDotDict['enemy' + str(j)].reparentTo(self.showbase.render)\n-                self.EnemyAIDotDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n-                \n-                # Collision\n-                self.EnemyCollisionDict['enemy' + str(j)] = CollisionNode('enemy' + str(j))\n-                self.EnemyCollisionDict['enemy' + str(j)].addSolid(CollisionBox(LPoint3f(2, 0, 9), 4,3,12))\n-                self.EnemyColliderPath = self.EnemyModelDict['enemy' + str(j)].attachNewNode(self.EnemyCollisionDict['enemy' + str(j)])\n-\n-                # AI\n-                self.EnemyAICharDict['enemy' + str(j)] = AICharacter('enemy' + str(j), self.EnemyAIDotDict['enemy' + str(j)], 100, .05, 5)\n-                self.EnemyAIWorld.addAiChar(self.EnemyAICharDict['enemy' + str(j)])\n-                self.EnemyAIBehaviourDict['enemy' + str(j)] = self.EnemyAICharDict['enemy' + str(j)].getAiBehaviors()\n-                self.EnemyAIBehaviourDict['enemy' + str(j)].pursue(self.showbase.camera)\n-                self.EnemyAIBehaviourDict['enemy' + str(j)].arrival(1)\n-                self.EnemyHealthDict['enemy' + str(j)] = health\n-\n-                # Add collisions\n-                self.showbase.cTrav.addCollider(self.EnemyColliderPath, self.EnemyCollisionHandler)\n-                game.pusher.addCollider(self.EnemyColliderPath, self.EnemyModelDict['enemy' + str(j)])\n-\n-                print(\"Enemy \" + str(j) + \" spawned\")\n-            if self.waveCount > i:\n-                continue\n-            else:\n-                await self.waveMethod\n-                print(\"Wave \" + str(i+2) + \" done\")\n-                self.waveMethod = AsyncFuture()\n-                self.WaveCounttext.setText(\"Wave: \" + str(i+2))\n-                self.waveCount += 1\n-                self.Messagesent = False\n-                self.num += changePerWave\n-        print('Done')\n-    def DamagePlayer(self, collision='nothing'):\n-        for i in range(len(self.EnemyDict['model'])+1):\n-            if 'enemy' + str(i) in str(collision) and 'camera' in str(collision):\n-                Game.PlayerHealth -= 1\n-    def EnemyHit(self, enemy):\n-        self.EnemyDict['health'][enemy.getName()] -= 1\n-        AnimControl = self.EnemyDict['model'][enemy.getName()].getAnimControl('hit')\n-        if AnimControl.isPlaying():\n-            return None\n-        else:\n-            AnimControl.setPlayRate(.5)\n-            self.EnemyDict['ai_behaviour'][enemy.getName()].pauseAi('all')\n-            self.EnemyDict['model'][enemy.getName()].play('hit')\n-    def MainUpdate(self):\n-        self.EnemyAIWorld.update()\n-        for enemy, aidot in zip(self.EnemyDict['model'].values(), self.EnemyDict['ai_dot'].values()):\n-            if not enemy.isEmpty() and not aidot.isEmpty():\n-                dt = globalClock.getDt()\n-                aidotpos = aidot.getPos()\n-                (aidotpos) += self._gravity * min(dt, 1/64.0)\n-                aidot.setPos(aidotpos)\n-                enemy.setH((aidot.getH())-180)\n-                enemy.setPos(aidotpos)\n-        for key in list(self.EnemyDict['health'].keys()):\n-            if self.EnemyDict['health'][key] <= 0:\n-                self.EnemyDict['model'][key].cleanup()\n-                self.EnemyDict['ai_dot'][key].removeNode()\n-                self.EnemyAIWorld.removeAiChar(key)\n-                self.EnemyDict['ai_behaviour'][key].removeAi(key)\n-                del self.EnemyDict['model'][key]\n-                del self.EnemyDict['ai_dot'][key]\n-                del self.EnemyDict['collision'][key]\n-                del self.EnemyDict['ai_char'][key]\n-                del self.EnemyDict['ai_behaviour'][key]\n-                del self.EnemyDict['health'][key]\n-                self.EnemyCount += 1\n-        \n-        if self.EnemyDict['model'] == {} and not self.Messagesent:\n-            self.Messagesent = True\n-            self.waveMethod.set_result(None)\n-        \n-        for enemy in list(self.EnemyDict['model'].values()):\n-            key = list(self.EnemyDict['model'].keys())[list(self.EnemyDict['model'].values()).index(enemy)]\n-            if not enemy.getAnimControl('hit').isPlaying() and self.EnemyDict['ai_behaviour'][key].behaviorStatus('pursue') == 'paused':\n-                self.EnemyDict['ai_behaviour'][key].resumeAi('all')\n-                enemy.loop('Walk')\n-    def destroy(self, KeepAI=False):\n-        self.Run = False\n-        self.WaveCounttext.destroy()\n-        if KeepAI:\n-            for enemy in list(self.EnemyDict['model'].keys()):\n-                self.EnemyAIWorld.removeAiChar(enemy)\n-                self.EnemyDict['ai_behaviour'][enemy].removeAi(enemy)\n-        self.EnemyDict['model'] = {}\n-        self.EnemyDict['ai_dot'] = {}\n-        self.EnemyDict['collision'] = {}\n-        self.EnemyDict['ai_char'] = {}\n-        self.EnemyDict['ai_behaviour'] = {}\n-        self.EnemyDict['health'] = {}\n-\n-class Game(ShowBase):\n-    vfs = VirtualFileSystem.getGlobalPtr()\n-    inaMenu = True\n-    mouse_sensitivity = 0.5\n-    PlayerHealth = 100\n-    sunDirection = -.2\n-    cycleOscillation = {'dawnOrDusk' : 'down', 'notQiyamah': .45}\n-    keys = {'w':\"forward\",\n-            's':\"backward\",\n-            'a':\"left\",\n-            'd':\"right\",\n-#            'space':\"up\",\n-#            'e':\"down\"\n-            }\n-    def textTypewriteAnimation(self, textPos, text, interval=0.05):\n-        textSplit = list(text)\n-        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,0,0,1), align=TextNode.ALeft, font=self.loader.loadFont('assets/fonts/Micro5-Regular.ttf'))\n-        def cleanup(task):\n-            textNode.destroy()\n-        async def typewrite():\n-            for char in textSplit:\n-                textNode.setText(textNode.getText() + char)\n-                await Task.pause(interval)\n-            await Task.pause(1)\n-            return Task.done\n-        taskMgr.add(typewrite(), 'typewriteTask', uponDeath=cleanup)\n-    def dayNightCycle(self):\n-        steps = {'sunSpeed': 0.0005, 'rotationSpeed': 0.000375}\n-        self.cycleOscillation['notQiyamah'] -= steps['rotationSpeed']\n-        if self.cycleOscillation['dawnOrDusk'] == 'down':\n-            self.sunDirection += steps['sunSpeed']\n-            if self.sunDirection >= .3:\n-                self.cycleOscillation['dawnOrDusk'] = 'up'\n-                print(self.cycleOscillation['notQiyamah'])\n-                self.cycleOscillation['notQiyamah'] = 0.45\n-                steps['rotationSpeed'] = 0.000375\n-                print('switch up')\n-        elif self.cycleOscillation['dawnOrDusk'] == 'up':\n-            self.sunDirection -= steps['sunSpeed']\n-            if self.sunDirection <= -.3:\n-                self.cycleOscillation['dawnOrDusk'] = 'down'\n-                steps['rotationSpeed'] = 0.00017\n-                print(self.cycleOscillation['notQiyamah'])\n-                print('switch down')\n-        for models in self.currentModels:\n-            models.setShaderInput('light0_direction', (self.cycleOscillation['notQiyamah'], self.sunDirection, 0))\n-    def PlayerHUD(self):\n-        self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        frameSize=(-1.25, 1.25, -0.15, 0.15),\n-                                        pos=(0, 0, -.75))\n-        self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n-                                             frameSize=(-.125, .125, -0.125, 0.125),\n-                                             pos=(0, 0, -.75))\n-    def exportScene(self):\n-        file_name = input(\"Enter file name: \")\n-        ss = StringStream()\n-        self.render.ls(out=ss)\n-        with open(f\"scene_graph-{file_name}.txt\", \"w\", encoding=\"utf-8\") as f:\n-            f.write(ss.get_data().decode(\"utf-8\"))\n-    def Death(self):\n-        self.CameraOperator()\n-        def LoadMainMenu(self):\n-            # remove task, reset\n-            self.deathFrame.destroy()\n-            self.btnMainMenu.destroy()\n-            self.PlayerHealth = 100\n-            self.clickSound.play()\n-            taskMgr.remove('Update')\n-            self.SaveProgress(reset=True)\n-            self.HealthBar.destroy()\n-            self.playButtonMethod = AsyncFuture()\n-            self.MainMenu()\n-            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n-            self.cam_controller.setup(keys=self.keys)\n-            self.cam_controller.disable()\n-            self.currentwave = 0\n-            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n-            for child in children_to_remove:\n-                if '__Actor_modelRoot' in child.getChildren():\n-                    child.cleanup()\n-                else:    \n-                    child.removeNode()\n-            taskMgr.add(self.loadScene())\n-        self.deathFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n-                                      frameSize=(-1.4, 1.4, -1, 1), \n-                                      pos=(0, 0, 0), \n-                                      scale=(1, 1, 1), \n-                                      text=\"You died\", \n-                                      text_font=self.Font,\n-                                      text_scale=0.3, \n-                                      text_pos=(0, .75), \n-                                      text_fg=(1, 0, 0, 1), \n-                                      text_align=TextNode.ACenter)\n-        self.btnMainMenu = DirectButton(\n-            parent=self.deathFrame,\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.4, 0.4, -0.08, 0.16),\n-            pos=LPoint3f(0, 0, -0.15),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Exit to Main Menu',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.075, 0.075),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=LoadMainMenu,\n-            extraArgs=[self],\n-        )\n-    def MouseIn(self):\n-        props = self.win.getProperties()\n-        # This is needed to for WebGL. If the window is not in focus, the mouse won't work, so we need to request focus\n-        if not self.inaMenu:\n-            if not props.getForeground() or not props.getCursorHidden() or props.getMouseMode() != WindowProperties.MConfined:\n-                self.win.requestProperties(WindowProperties(foreground=True, mouse_mode=WindowProperties.MConfined, cursor_hidden=True))\n-        \n-        # Create a CollisionRay for the mouse click\n-        ray_node = CollisionNode('click-ray')\n-        ray = CollisionRay()\n-        ray.setOrigin(0, 0, 0)  # Start at the camera\n-        ray.setDirection(0, 1, 0)  # Point forward\n-        ray_node.addSolid(ray)\n-\n-        # Attach the CollisionRay to the camera and set it to the right bitmasks\n-        self.ray_path = self.camera.attachNewNode(ray_node)\n-\n-        # Create a quene to store the collisions and add the CollisionRay to the CollisionTraverser\n-        self.collision_queue = CollisionHandlerQueue()\n-        self.cTrav.addCollider(self.ray_path, self.collision_queue)\n-        taskMgr.add(self.click, \"clickTask\")\n-\n-        self.ballDown = True\n-    def MouseUp(self):\n-        taskMgr.remove(\"clickTask\")\n-        if hasattr(self, 'ray_path'):\n-            self.cTrav.removeCollider(self.ray_path)  # Remove collider from traverser\n-            self.ray_path.removeNode()  # Safely remove the ray\n-            self.collision_queue.clearEntries()\n-        self.ballDown = False\n-    def SaveProgress(self, reset=False):\n-        if reset:\n-            self.save_file = open(\"save.txt\", \"w\")\n-            self.save_file.write('LPoint3f(0, 0, 114)\\n')\n-            self.save_file.write(str(0))\n-            self.save_file.close()\n-        else:\n-            self.save_file = open(\"save.txt\", \"w\")\n-            self.save_file.write(str(self.camera.getPos()) + '\\n')\n-            self.save_file.close()\n-    def CameraOperator(self):\n-        # When this function is called, we check if we are in a menu, if we are then we watch our new keys\n-        # This is critical for one we don't setup the camera again, and two if the player decides to change controls\n-        # And then we switch our bool to false, as we are no longer in a menu, enabling clicking to focus the mouse\n-        if self.inaMenu:\n-            self.cam_controller.rewatch(self.keys, mouse_sensitivity=self.mouse_sensitivity)\n-            self.inaMenu = False\n-        \n-        # If we are not in a menu, then we disable the camera controller\n-        # And set our bool to true, critical because our click function refocuses the window\n-        else:\n-            self.cam_controller.disable()   \n-            self.inaMenu = True\n-        # Using our boolean we pass an if statement to effectively switch when oue mouse focuses on clicks\n-    def TutorialMenu(self):\n-        self.clickSound.play()\n-        self.paused = True\n-        self.currentTime = 0\n-        self.tutorialMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        frameSize=(-1.25, 1.25, -0.9, 0.9),\n-                                        pos=(0, 0, 0)\n-        )\n-        self.tutorialLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        frameSize=(-.3, .3, -0.1, 0.1),\n-                                        pos=(-.8, 0, .65),\n-                                        parent=self.tutorialMainFrame,\n-                                        relief=None,\n-                                        text=\"Tutorial\",\n-                                        text_fg=(0, 0, 0, 1),\n-                                        text_pos=(0, 0),\n-                                        text_scale=0.2,\n-                                        text_font=self.Font,\n-                                        text_align=TextNode.ACenter\n-        )\n-        self.tutorialVideoControlFrame = DirectFrame(parent=self.tutorialMainFrame,\n-                                                    frameColor=(0.3, 0.3, 0.3, 1),\n-                                                    frameSize=(-1, 1, -0.1, 0.1),\n-                                                    pos=(0, 0, -.7)\n-        )\n-        self.tutorialVideo = self.loader.loadTexture(r\"assets/audio/tutorial.mp4\")\n-        self.cm = CardMaker(\"card\")\n-        self.cm.setFrame(-.8, .8, -0.55, 0.55)\n-        self.cm.setUvRange(self.tutorialVideo)\n-        self.card = self.render2d.attachNewNode(self.cm.generate())\n-        self.card.setTexture(self.tutorialVideo)\n-        self.card.setPos(-0, 0, 0)\n-        self.card.reparentTo(self.tutorialMainFrame)\n-        self.tutorialAudio = self.loader.loadSfx(r\"assets/audio/tutorial.mp4\")\n-        self.tutorialVideo.synchronizeTo(self.tutorialAudio)\n-\n-        def PlayblackSliderMethod(self):\n-            self.tutorialAudio.stop()\n-            self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n-            self.currentTime = self.videoPlaybackSlider['value']\n-            self.paused = True\n-        def PausePlayMethod(self):\n-            if self.paused == True:\n-                #When clicked from pause to play\n-                self.paused = False\n-                self.videoPauseButton['image'] = 'assets/images/playIcon.png'\n-            else:\n-                self.paused = True\n-                self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n-            if self.tutorialAudio.status() == self.tutorialAudio.PLAYING:\n-                self.currentTime = self.tutorialAudio.getTime()\n-                self.tutorialAudio.stop()\n-            else:\n-                self.tutorialAudio.setTime(self.currentTime)\n-                self.tutorialAudio.play()\n-        \n-        self.videoPlaybackSlider = DirectSlider(range=(0, self.tutorialVideo.getVideoLength()),\n-                                  value=0, \n-                                  command=PlayblackSliderMethod, \n-                                  frameSize=(-.75, .75, -0.1, 0.1),\n-                                  frameColor=(0.8, 0.8, 0.8, 1),\n-                                  thumb_frameSize=(-.015, .015, -.015, .015),\n-                                  thumb_frameColor=(1, 0, 0, 1),\n-                                  pos=LPoint3f(0, 0, 0),\n-                                  orientation='horizontal', \n-                                  parent=self.tutorialVideoControlFrame,\n-                                  thumb_relief=DGG.FLAT,\n-                                  extraArgs=[self]\n-                                  )\n-        self.videoPauseButton = DirectButton(parent=self.tutorialVideoControlFrame,\n-                                             frameColor=(0.8, 0.8, 0.8, 1),\n-                                             frameSize=(-.05, .05, -0.05, 0.05),\n-                                             pos=LPoint3f(-.9, 0, 0),\n-                                             relief=None,\n-                                             image = 'assets/images/pauseIcon.png',\n-                                             image_pos=(0, 0, 0),\n-                                             image_scale=(0.1, 0.1, 0.1),\n-                                             command=PausePlayMethod,\n-                                             extraArgs=[self]\n-                                             )\n-        self.videoPauseButton.setTransparency(TransparencyAttrib.MAlpha)\n-    def OptionMenu(self):\n-        self.clickSound.play()\n-        self.mouseSettingsOpen = False\n-        self.keyboardSettingsOpen = False\n-        self.audioSettingsOpen = False\n-        self.aboutSettingsOpen = False\n-        \n-        def clear_menu():\n-            if self.mouseSettingsOpen:\n-                self.sensitivityFrame.destroy()\n-                self.sensitivityLabel.destroy()\n-                self.sensitivitySlider.destroy()\n-                self.mouseSettingsOpen = False  \n-            if self.keyboardSettingsOpen:\n-                self.forwardFrame.destroy()\n-                self.backwardFrame.destroy()\n-                self.leftFrame.destroy()\n-                self.rightFrame.destroy()\n-                self.forwardLabel.destroy()\n-                self.backwardLabel.destroy()\n-                self.leftLabel.destroy()\n-                self.rightLabel.destroy()\n-                self.forwardEntry.destroy()\n-                self.backwardEntry.destroy()\n-                self.leftEntry.destroy()\n-                self.rightEntry.destroy()\n-                self.btnSave.destroy()\n-                self.disclamerLabel.destroy()\n-                self.keyboardSettingsOpen = False\n-#            if self.audioSettingsOpen:\n-\n-            if self.aboutSettingsOpen:\n-                self.aboutLabel.destroy()\n-                self.gameAboutLabel.destroy()\n-                self.aboutSettingsOpen = False\n-        self.optionMenuBg = OnscreenImage(image='assets/images/optionMenuBg.png', pos=(0, 0, 0), scale=(.75, .5, 1))\n-        self.optionMenuBg.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.scrolledFrame = DirectScrolledFrame(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-.2, .6, -.8, .7),\n-            pos=LPoint3f(-0.05, 0, 0),\n-            canvasSize=(-.4, .4, -1, 1),\n-            verticalScroll_relief=None,\n-            horizontalScroll_relief=None,\n-        )\n-        self.scrolledFrame.setManageScrollBars()\n-        self.scrolledFrame.verticalScroll['frameSize'] = (-.01, .01, -.01, .01)\n-        self.scrolledFrame.verticalScroll['frameColor'] = (0.4, 0.4, 0.4, 1)\n-        self.scrolledFrame.verticalScroll['thumb_relief'] = DGG.FLAT\n-        self.scrolledFrame.verticalScroll['decButton_relief'] = None\n-        self.scrolledFrame.verticalScroll['incButton_relief'] = None\n-        self.scrolledFrame.horizontalScroll['frameSize'] = None\n-\n-        def MouseSettingMethod(self):\n-            self.sensitivityFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .85),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.sensitivityLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Mouse Sensitivity\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.1, 0, .875), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT\n-                                                )\n-            def changesensitivity():\n-                self.mouse_sensitivity = self.sensitivitySlider['value'] * .2\n-                print(self.sensitivitySlider['value'])      \n-            self.sensitivitySlider = DirectSlider(range=(0,2), \n-                                  value=1, \n-                                  command=changesensitivity, \n-                                  frameSize=(-.25, .25, -0.05, 0.05),\n-                                  frameColor=(0.8, 0.8, 0.8, 1),\n-                                  thumb_frameSize=(-.01, .01, -.01, .01),\n-                                  thumb_frameColor=(0.4, 0.4, 0.4, 1),\n-                                  pos=LPoint3f(-.05, 0, .8),\n-                                  orientation='horizontal', \n-                                  parent=self.scrolledFrame.getCanvas(),\n-                                  thumb_relief=DGG.FLAT\n-                                  )\n-            clear_menu()\n-            self.mouseSettingsOpen = True\n-        def KeyboardSettingMethod(self):\n-            def ForwardKeyMethod(key, self):\n-                self.forwardKey = key\n-            def BackwardKeyMethod(key, self):\n-                self.backwardKey = key\n-            def LeftKeyMethod(key, self):\n-                self.leftKey = key\n-            def RightKeyMethod(key, self):\n-                self.rightKey = key\n-            def SaveMethod(self):\n-                if not hasattr(self, 'forwardKey'):\n-                    self.forwardKey = 'w'\n-                if not hasattr(self, 'backwardKey'):\n-                    self.backwardKey = 's'\n-                if not hasattr(self, 'leftKey'):\n-                    self.leftKey = 'a'\n-                if not hasattr(self, 'rightKey'):\n-                    self.rightKey = 'd'\n-                self.keys = {\n-                    self.forwardKey: \"forward\",\n-                    self.backwardKey: \"backward\",\n-                    self.leftKey: \"left\",\n-                    self.rightKey: \"right\",\n-                    'space': \"up\",\n-                    'e': \"down\"\n-                }\n-            self.forwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Forward\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.2, 0, .875), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.backwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Backward\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.19, 0, .625), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.leftLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Left\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.25, 0, .375), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.rightLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                text=\"Right\", \n-                                                text_scale=0.05, \n-                                                pos=LPoint3f(-.24, 0, .125), \n-                                                parent=self.scrolledFrame.getCanvas(), \n-                                                relief=DGG.FLAT,\n-                                                sortOrder=2\n-                                                )\n-            self.forwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .825),\n-                                                text_pos= (-0.1, -.015),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=ForwardKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='W'\n-                                                )\n-            self.backwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .575),\n-                                                text_pos= (-0.1, -.015),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=BackwardKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='S'\n-                                                )\n-            self.leftEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .325),\n-                                                text_pos= (-0.1, -.015),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=LeftKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='A'\n-                                                )\n-            self.rightEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n-                                                frameSize=(-.15, 0, -0.03, 0.03),\n-                                                pos=LPoint3f(-.15, 0, .075),\n-                                                text_pos= (-0.1, -.015),    \n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT,\n-                                                text_scale=0.05,\n-                                                sortOrder=2,\n-                                                command=RightKeyMethod,\n-                                                extraArgs=[self],\n-                                                initialText='D'\n-                                                )\n-            self.forwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .85),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.backwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .6),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.leftFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .35),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.rightFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                                frameSize=(-.3, .3, -0.1, 0.1),\n-                                                pos=LPoint3f(-.05, 0, .1),\n-                                                parent=self.scrolledFrame.getCanvas(),\n-                                                relief=DGG.FLAT\n-                                                )\n-            self.btnSave = DirectButton(\n-                frameColor=(0.2, 0.2, 0.2, 1),\n-                frameSize=(-0.09, 0.09, -0.025, 0.05),\n-                text='Save',\n-                text_scale=0.05,\n-                text_fg=(0.5, 0.5, 0.5, 1),\n-                pos=LPoint3f(-0.25, 0, -0.075),\n-                relief=1,\n-                parent=self.scrolledFrame.getCanvas(),\n-                command=SaveMethod,\n-                extraArgs=[self],\n-                sortOrder=2\n-            )\n-            self.disclamerLabel = DirectLabel(\n-                frameColor=(0.6, 0.6, 0.6, 1),\n-                text=\"*Press enter each key*\",\n-                text_scale=0.05,\n-                pos=LPoint3f(0, 0, -0.2),\n-                parent=self.scrolledFrame.getCanvas(),\n-                relief=None\n-            )\n-            clear_menu()\n-            self.keyboardSettingsOpen = True\n-        def AboutSettingMethod(self):\n-            self.aboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                        text=\"About\",\n-                                        text_scale=0.1,\n-                                        pos=LPoint3f(-0.025, 0, 0.85),\n-                                        parent=self.scrolledFrame.getCanvas(),\n-                                        relief=None\n-                                        )\n-            self.gameAboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n-                                            text= \"TSA Videogame Design 2025-2026 \\n '' is a  game developed by \\n  the team 1034-1 for the 2025-2026 \\n  \\\n-                                            Technology Student Association Competition for Video Game Design. \\n this is a  based on the theme of \\n\\\n-                                            We developed this game using \\n the Panda3D game engine \\n differing from Unity and Unreal as \\n it is a purely text edited engine\",\n-                                            text_scale=0.04,\n-                                            pos=LPoint3f(-0.04, 0, 0.3),\n-                                            parent=self.scrolledFrame.getCanvas(),\n-                                            relief=None\n-                                            )\n-            clear_menu()\n-            self.aboutSettingsOpen = True\n-        self.btnMouse = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.13),\n-            pos=LPoint3f(-0.37666, 0, 0.57666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/mouseIcon.png',\n-            image_scale = (.09, .09, .09),\n-            image_pos = (0, 0, 0.03),\n-            image_hpr = (0, 0, 0),\n-            command=MouseSettingMethod,\n-            extraArgs=[self],\n-        )\n-        self.btnMouse.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.btnKeyboard = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.376666, 0, 0.33666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/keyboardIcon.png',\n-            image_scale = (.09, .09, .09),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=KeyboardSettingMethod,\n-            extraArgs=[self],\n-        )\n-        self.btnKeyboard.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.btnAudioSet = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.37666, 0, 0.09666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/audioIcon.png',\n-            image_scale = (.07, .07, .07),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=self.playButtonMethod.set_result,\n-            extraArgs=[None],\n-        )\n-        self.btnAudioSet.setTransparency(TransparencyAttrib.MAlpha)\n-        \n-        self.btnAbout = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.37666, 0, -0.13666),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/aboutIcon.png',\n-            image_scale = (.07, .07, .07),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=AboutSettingMethod,\n-            extraArgs=[self],\n-        )\n-        self.btnAbout.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        def close_menu():\n-            self.scrolledFrame.destroy()\n-            self.optionMenuBg.destroy()\n-            self.btnAbout.destroy()\n-            self.btnAudioSet.destroy()\n-            self.btnKeyboard.destroy()\n-            self.btnMouse.destroy()\n-            self.btnExit.destroy()\n-            clear_menu()\n-\n-        self.btnExit = DirectButton(\n-            frameColor=(0.4, 0.4, 0.4, 1),\n-            frameSize=(-0.09, 0.09, -0.07, 0.14),\n-            pos=LPoint3f(-0.5, 0, 0.75),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=None,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/exitIcon.png',\n-            image_scale = (.07, .07, .07),\n-            image_pos = (0, 0, .03),\n-            image_hpr = (0, 0, 0),\n-            command=close_menu,\n-        )\n-        self.btnExit.setTransparency(TransparencyAttrib.MAlpha)\n-    def MainMenu(self):\n-        self.inaMenu = True\n-        self.mainMenuBackground = OnscreenImage(image='assets/images/mainMenuBackground.png', pos=(0, 0, 0), scale=(1.5, 1.5, 1.5))\n-        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.25, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n-        self.titleText.setFont(self.Font)\n-        self.btnPlay = DirectButton(\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.2, 0.2, -0.03, 0.06),\n-            pos=LPoint3f(0, 0, -0.1),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Play',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.05, 0.05),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=self.playButtonMethod.set_result,\n-            extraArgs=[None],\n-        )\n-\n-        self.btnOption= DirectButton(\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.3, 0.3, -0.03, 0.06),\n-            pos=LPoint3f(-1.2, 0, -0.87),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=None,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/optionIcon.png',\n-            image_scale = (.1, .1, .1),\n-            command=self.OptionMenu,\n-            extraArgs=[],\n-        )\n-        self.btnOption.setTransparency(TransparencyAttrib.MAlpha)\n-\n-        self.btnTutorial= DirectButton(\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.3, 0.3, -0.03, 0.06),\n-            pos=LPoint3f(1.2, 0, -0.87),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=None,\n-            scale=LVecBase3f(1, 1, 1),\n-            image= 'assets/images/tutorialIcon.png',\n-            image_scale = (.1, .1, .1),\n-            command=self.TutorialMenu,\n-            extraArgs=[],\n-        )\n-        self.btnTutorial.setTransparency(TransparencyAttrib.MAlpha)\n-    def PauseMenu(self):\n-        self.clickSound.play()\n-        self.CameraOperator()\n-        def LoadMainMenu(self):\n-            #Keep AI here, dont remove .setup and reenter waves\n-            self.clickSound.play()\n-            taskMgr.remove('Update')\n-            self.SaveProgress()\n-            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n-            self.cam_controller.setup(keys=self.keys)\n-            self.cam_controller.disable()\n-            self.HealthBar.destroy()\n-            self.playButtonMethod = AsyncFuture()\n-            self.MainMenu()\n-            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n-            for child in children_to_remove:\n-                if '__Actor_modelRoot' in child.getName():\n-                    child.cleanup()\n-                else:    \n-                    child.removeNode()\n-            self.pauseFrame.destroy()\n-            self.btnMainMenu.destroy()\n-            self.btnResume.destroy()\n-            taskMgr.add(self.loadScene())\n-        def Resume(self):\n-            self.clickSound.play()\n-            self.pauseFrame.destroy()\n-            self.btnMainMenu.destroy()\n-            self.btnResume.destroy()\n-            self.CameraOperator()\n-        self.pauseFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n-                                    frameSize=(-.5, .5, -0.3, 0.35),\n-                                    pos=LPoint3f(0, 0, 0),\n-                                    hpr=LVecBase3f(0, 0, 0),\n-                                    relief=DGG.FLAT,\n-                                    scale=LVecBase3f(1, 1, 1))\n-        self.btnMainMenu = DirectButton(\n-            parent=self.pauseFrame,\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.4, 0.4, -0.08, 0.16),\n-            pos=LPoint3f(0, 0, -0.15),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Save & Exit',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.1, 0.1),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=LoadMainMenu,\n-            extraArgs=[self],\n-        )\n-        self.btnResume = DirectButton(\n-            parent=self.pauseFrame,\n-            frameColor=(0.15, 0.15, 0.15, 1),\n-            frameSize=(-0.4, 0.4, -0.08, 0.16),\n-            pos=LPoint3f(0, 0, 0.15),\n-            hpr=LVecBase3f(0, 0, 0),\n-            relief=1,\n-            scale=LVecBase3f(1, 1, 1),\n-            text='Resume',\n-            text_align=TextNode.A_center,\n-            text_scale=(0.1, 0.1),\n-            text_pos=(0, 0),\n-            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-            text_bg=LVecBase4f(0, 0, 0, 0),\n-            command=Resume,\n-            extraArgs=[self],\n-        )\n-    # This function is called when the mouse is clicked, calling a function based on what is clicked in game\n-    async def click(self, task):\n-        # Perform collision traversal\n-        self.cTrav.traverse(self.render)\n-        print(self.ball.getPos())\n-        try:\n-            # Process collisions\n-            num_collisions = self.collision_queue.getNumEntries()\n-\n-            if num_collisions > 1:\n-                self.collision_queue.sortEntries()\n-                entry = self.collision_queue.getEntry(1)  # Get the closest collision\n-                hit_node = entry.getIntoNode()\n-                # Check if the hit node is the model that is supposed to be clicked using something like this:\n-#                for enemy in list(self.enemy.EnemyDict['collision'].values()):\n-#                    if hit_node.getName() == enemy.getName():\n-#                        self.enemyController.EnemyHit(enemy)\n-#                        await Task.pause(.2)\n-        except AssertionError as e:\n-            print(\"AssertionError occurred during collision processing.\")\n-            print(e)\n-        except KeyError as e:\n-            print(\"KeyError occurred during collision processing.\")\n-            pass\n-        return Task.cont\n-    def shader(self, nodes = None, EnterNode = None):\n-        self.currentModels = []\n-        if not hasattr(self, 'Shader_setup'):\n-            self.Shader_setup = None\n-            print(PandaSystem.getPlatform())\n-            if PandaSystem.getPlatform() == 'win_amd64' or PandaSystem.getPlatform() == 'osx_aarch64':\n-                shaders = [f\"{os.path.dirname(__file__)}/assets/shaders/Shader.vert\", f\"{os.path.dirname(__file__)}/assets/shaders/Shader.frag\"]\n-                patchedShaders = []\n-                for file in shaders:    \n-                    with open(file, 'r') as file:\n-                        code = file.read()\n-                        code = code.replace(\"#version 300 es\", \"#version 330\")\n-                        code = \"\\n\".join(\n-                            line for line in code.splitlines()\n-                            if not line.strip().startswith(\"precision\")\n-                        )\n-                        patchedShaders.append(code)\n-                self.Shader = Shader.make(Shader.SL_GLSL, patchedShaders[0], patchedShaders[1])\n-            else:\n-                self.Shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/Shader.vert\", \"assets/shaders/Shader.frag\")\n-            shadow_buffer = self.win.make_texture_buffer(\"ShadowBuffer\", 1024, 1024)\n-            shadow_buffer.set_sort(-100)\n-            shadow_buffer.set_clear_color((1, 1, 1, 1))\n-            self.shadow_map = shadow_buffer.get_texture()\n-            self.shadow_map.set_minfilter(SamplerState.FT_shadow)\n-            self.shadow_map.set_magfilter(SamplerState.FT_shadow)\n-\n-            self.shadow_cam = self.make_camera(shadow_buffer, lens=OrthographicLens())\n-            self.shadow_cam.reparent_to(self.sunLightNP)\n-\n-            shadow_scene = self.render.copy_to(NodePath(\"shadow_scene\"))\n-            shadow_scene.set_shader(Shader.load(Shader.SL_GLSL, \"assets/shaders/shadow_depth.vert\", \"assets/shaders/shadow_depth.frag\"))\n-            self.shadow_cam.node().set_scene(shadow_scene)\n-        if EnterNode == None:\n-            for node in nodes:\n-                self.currentModels.append(node)\n-                node.setShader(self.Shader)\n-                node.setShaderInput(\"shadowMap\", self.shadow_map)\n-                node.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n-                node.setShaderInput(\"diffuseTex\", node.find_texture(\"*\"))\n-                node.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n-                node.setShaderInput(\"light0_color\", Vec3(.5, .75, 0.85))\n-                node.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n-                node.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n-                node.setShaderInput(\"material_shininess\", 10.0)\n-                node.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n-                node.setShaderInput(\"cameraPos\", self.camera.getPos(self.render))\n-\n-        else:\n-            self.currentModels.append(EnterNode)\n-            EnterNode.setShader(self.Shader)\n-            EnterNode.setShaderInput(\"shadowMap\", self.shadow_map)\n-            EnterNode.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n-            EnterNode.setShaderInput(\"diffuseTex\", EnterNode.find_texture(\"*\"))\n-            EnterNode.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n-            EnterNode.setShaderInput(\"light0_color\", Vec3(.75, .75, 0.5))\n-            EnterNode.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n-            EnterNode.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n-            EnterNode.setShaderInput(\"material_shininess\", 15.0)\n-            EnterNode.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n-    # This function loads the models in the background, reducing lag and improving performance\n-    async def loadScene(self):\n-\n-        # in case of death, we need to reload the bool\n-        if hasattr(self, '_player_died'):\n-            delattr(self, '_player_died')  # Remove self._player_died\n-        \n-        if hasattr(self, '_player_won'):\n-            delattr(self, '_player_won')  # Remove self._player_won\n-            \n-        with open(f'{os.path.dirname(__file__)}/save.txt', 'r') as f:\n-            line = f.readline()\n-            line = line.replace('LPoint3f(', '').replace(')', '')\n-            x, y, z = map(float, line.split(','))\n-        \n-\n-        self.camera.setPos(x, y, z)\n-\n-        # Load the models in the background, each time suspending this\n-        # method until they are done\n-        self.worldCollisionModel = await self.loader.loadModel(\"assets/models/worldTriangles.bam\", blocking=False)\n-        self.worldVisibleModel = await self.loader.loadModel(\"assets/models/worldVisible.bam\", blocking=False)\n-\n-        # Create a background for the world\n-        \n-        self.world_bg = await self.loader.loadModel(\"assets/models/skybox.bam\",blocking=False)\n-        self.world_bg.reparent_to(self.render)\n-        self.world_bg.set_scale(2500)\n-\n-        world_bg_texture = self.loader.loadTexture(\"assets/images/world_bg.png\")\n-        world_bg_texture.set_minfilter(SamplerState.FT_linear)\n-        world_bg_texture.set_magfilter(SamplerState.FT_linear)\n-        world_bg_texture.set_wrap_u(SamplerState.WM_repeat)\n-        world_bg_texture.set_wrap_v(SamplerState.WM_mirror)\n-        world_bg_texture.set_anisotropic_degree(200)\n-        self.world_bg.set_texture(world_bg_texture)\n-        world_bg_shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/world_bg.vert.glsl\", \"assets/shaders/world_bg.frag.glsl\")\n-        self.world_bg.set_shader(world_bg_shader) \n-        \n-        # Create a collision node for the world\n-        self.world_collision_node = self.worldCollisionModel.find(\"**/+CollisionNode\")\n-        self.worldCollisionModel.hide()\n-        self.cTrav.addCollider(self.world_collision_node, self.pusher)\n-        self.pusher.addCollider(self.world_collision_node, self.worldCollisionModel)\n-\n-        # Set up Lighting System\n-        self.sunLight = DirectionalLight('directionalLight')\n-        self.sunLight.setShadowCaster(True, 16384, 16384)\n-        self.sunLightNP = self.render.attachNewNode(self.sunLight)\n-        self.sunLightNP.setHpr(45, 45, 0)\n-        self.sunLight.setColor((1.5, 1.5, 1.5, 1))\n-        \n-        self.sunModel = await self.loader.loadModel(\"assets/models/sun.bam\", blocking=False)\n-        self.sunModel.setPos(150, -150, 200)\n-\n-        print(self.sunModel)\n-        ambientLight = AmbientLight('ambientLight')\n-        ambientLight.setColor((0.1, 0.1, 0.1, 1))\n-        ambientLightNP = self.render.attachNewNode(ambientLight)\n-        \n-        # Set the shaders\n-        ''' Most of the time this is very custom. Though there is a pipeline that can be used\n-            Most of this stuff can be recycled\n-        '''\n-        self.shader([self.sunModel, self.worldVisibleModel])\n-        \n-        # Wait for the player to start the game\n-        await self.playButtonMethod\n-        self.clickSound.play()\n-\n-        # Remove the main menu\n-        self.titleText.destroy()\n-        self.btnPlay.destroy()\n-        self.mainMenuBackground.destroy()\n-        self.btnOption.destroy()\n-        self.btnTutorial.destroy()\n-\n-        # Create a loading screen\n-        print(\"Loading Screen\")\n-        Loading_text = OnscreenText(\"Loading\", scale=2, parent=self.a2dTopCenter, pos=(0, 0), fg=(1, 1, 1, 1), align=TextNode.ACenter)\n-\n-        self.HealthBar = DirectWaitBar(text=\"Hull\", value=100, pos=(-.85, -15, -.7))\n-        self.HealthBar['barColor'] = (0, 2, 0, 2)\n-        self.HealthBar['text_scale'] = .05\n-        self.HealthBar['frameSize'] = (-.35, .35, -.035, .02)\n-        self.HealthBar['barRelief']= DGG.SUNKEN\n-\n-        self.HullBar = DirectWaitBar(text=\"Fuel\", value=100, pos=(-.85, -1, -.8))\n-        self.HullBar['barColor'] = (2, .5, 0, 2)\n-        self.HullBar['text_scale'] = .05\n-        self.HullBar['frameSize'] = (-.35, .35, -.035, .02)\n-        self.HullBar['barRelief']= DGG.SUNKEN\n-\n-        # Reparent the models to the render, making the world, and set the lights\n-        self.worldCollisionModel.reparentTo(self.render)\n-        self.worldVisibleModel.reparentTo(self.render)\n-        self.render.setLight(self.sunLightNP)\n-        self.render.setLight(ambientLightNP)\n-        self.sunModel.reparentTo(self.render)\n-        \n-        # Add HUD\n-        self.PlayerHUD()\n-        \n-        # Add a Pause Menu\n-        pausetext = OnscreenText(\"To Pause press P\", pos=(-1.14, 0.95), scale=0.05, fg=(0, 0, 0, 1), align=TextNode.ACenter)\n-        self.accept('p', self.PauseMenu)\n-\n-        # initialize the camera controller\n-        self.CameraOperator()\n-        \n-        \n-        \n-#        self.researchLocationEffect.start(parent=self.render, renderParent=self.render)\n-#        self.researchLocationEffect.setPos(0, 0, 250)\n-\n-        self.ball = self.loader.loadModel(\"assets/models/sun.bam\")\n-        self.ball.reparentTo(self.render)\n-        self.ballDown = False\n-        # Start the update cycle\n-        taskMgr.add(self.Update, \"Update\")        \n-        self.accept('mouse1-up', self.MouseUp)\n-        Loading_text.destroy() \n-\n-    # The Update cycle, this function should be used to update positions and anything that needs to be updated\n-    def Update(self, task):\n-        camera_forward = self.camera.getQuat(self.render).getForward()\n-        camera_up = self.camera.getQuat(self.render).getUp()\n-        camera_right = self.camera.getQuat(self.render).getRight()\n-        camera_position = self.camera.getPos(self.render)\n-\n-        self.dayNightCycle()\n-#            ak47_position = (\n-#                camera_position +\n-#                camera_forward * 2.67 -  # Forward by 1.0 units\n-#                camera_up * 1 +       # Downward by 0.5 units\n-#                camera_right * 0.8      # Rightward by 0.3 units\n-#            )\n-#            self.ak47.setPos(ak47_position)\n-#            self.ak47.setHpr(self.camera.getH(), 0, 90)\n-        \n-        self.worldCollisionModel.setPos(0, 0, 0)\n-        \n-        self.HealthBar['value'] = self.PlayerHealth\n-\n-        if self.PlayerHealth < 0 and not hasattr(self, '_player_died'):\n-            self._player_died = None\n-            self.Death()\n-        \n-        if not True:\n-            self._player_won = None\n-            self.CameraOperator()\n-            def LoadMainMenu(self):\n-                self.clickSound.play()\n-                taskMgr.remove('Update')\n-                self.SaveProgress(reset=True)\n-                self.HealthBar.destroy()\n-                self.playButtonMethod = AsyncFuture()\n-                self.MainMenu()\n-                self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n-                self.cam_controller.setup(keys=self.keys)\n-                self.cam_controller.disable()\n-                self.currentwave = 0\n-                children_to_remove = [child for child in self.render.getChildren() if child not in self.camera]\n-                for child in children_to_remove:\n-                    if '__Actor_modelRoot' in child.getChildren():\n-                        child.cleanup()\n-                    else:    \n-                        child.removeNode()\n-                self.winFrame.destroy()\n-                self.btnMainMenu.destroy()\n-                taskMgr.add(self.loadScene())\n-            self.winFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n-                                        frameSize=(-1.4, 1.4, -1., 1), \n-                                        pos=(0, 0, 0), \n-                                        scale=(1, 1, 1), \n-                                        text=\"You Won!\", \n-                                        text_font=self.Font,\n-                                        text_scale=0.5, \n-                                        text_pos=(0, .25), \n-                                        text_fg=(0, 0, 1, 1), \n-                                        text_align=TextNode.ACenter)\n-            self.btnMainMenu = DirectButton(\n-                parent=self.winFrame,\n-                frameColor=(0.15, 0.15, 0.15, 1),\n-                frameSize=(-0.4, 0.4, -0.08, 0.16),\n-                pos=LPoint3f(0, 0, -0.15),\n-                hpr=LVecBase3f(0, 0, 0),\n-                relief=1,\n-                scale=LVecBase3f(1, 1, 1),\n-                text='Exit to Main Menu',\n-                text_align=TextNode.A_center,\n-                text_scale=(0.075, 0.075),\n-                text_pos=(0, 0),\n-                text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n-                text_bg=LVecBase4f(0, 0, 0, 0),\n-                command=LoadMainMenu,\n-                extraArgs=[self],\n-            )\n-        if not self.ballDown:\n-            pos = self.camera.getPos(self.render)\n-            forward = self.camera.getQuat(self.render).getForward()\n-            self.ball.setPos(pos + forward * 50)\n-\n-        return Task.cont\n-    def __init__(self, Plot: 'Plot'):\n-        super().__init__()\n-        \n-        self.currentwave = 0\n-\n-        # Defining the Traverser, the task that checks for collisions, and the pusher, the task that pushes objects when it collides\n-        # The Traverser reports to the pusher, we also need to tell Panda3d which objects respond to collisions\n-        self.cTrav = CollisionTraverser()\n-        self.pusher = CollisionHandlerPusher()\n-\n-        # Camera setup\n-        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, gravity=-5\n-                                                        ,mouse_sensitivity=self.mouse_sensitivity\n-                                                        ,lockPitch=False)\n-        self.cam_controller.setup(keys=self.keys)\n-        self.cam_controller.disable()\n-        camera_collision_node = CollisionNode('camera')\n-        camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n-        camera_collision_node_path = self.camera.attachNewNode(camera_collision_node)\n-        camera_collision_node_path.setCollideMask(BitMask32.bit(2))\n-  \n-        # Add the collision nodes to the traverser. This is how we tell Panda3d which objects respond to collisions  \n-        self.cTrav.addCollider(camera_collision_node_path, self.pusher) \n-        self.pusher.addCollider(camera_collision_node_path, self.camera)\n-\n-        #   We load the tasks in the background to reduce lag\n-        self.playButtonMethod = AsyncFuture()\n-        taskMgr.add(self.loadScene())\n-        \n-        #  Tell Panda3d to listen for mouse clicks\n-        self.accept('mouse1', self.MouseIn)\n-        self.Font = self.loader.loadFont('assets/fonts/propaganda.ttf')\n-        self.Font.setPixelsPerUnit(120)\n-\n-        self.clickSound = self.loader.loadSfx('assets/audio/click.ogg')\n-\n-        self.enableParticles()\n-\n-#        self.messenger.toggleVerbose()\n-        self.accept('x', self.exportScene)\n-\n-        self.Plot = Plot(self)\n-\n-        # Open the main menu\n-        self.MainMenu()\n-\n-class Plot():\n-    async def plotLine(self, task):\n-        print('loading plot line')\n-        self.researchNode = self.gameInstance.loader.loadModel(\"assets/models/researchModel.bam\")\n-        self.researchNode.setPosHpr(0, 0, 250, 0, 90, 0)\n-        self.researchCollisionNode = self.researchNode.find(\"**/+CollisionNode\")\n-        self.researchNode.reparentTo(self.gameInstance.render)\n-        self.gameInstance.cTrav.addCollider(self.researchCollisionNode, self.gameInstance.pusher)\n-        self.gameInstance.pusher.addCollider(self.researchCollisionNode, self.researchNode)\n-        self.researchLocationEffect = ParticleEffect()\n-        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n-        self.researchLocationEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/researchParticles.ptf\")\n-        self.researchLocationEffect.clearShader()\n-        self.researchLocationEffect.start(self.researchNode, self.researchNode)\n-        await self.plotAsync\n-        print('very cool')\n-    async def conditionBasedAdvancer(self, task):\n-        for i in range(self.eventCounter):\n-            if self.plotCondition[i]:\n-                self.eventAdvanceFunc['finish']()\n-                await self.advanceAsync\n-    def __init__(self, gameInstance):\n-        self.gameInstance = gameInstance\n-        self.plotAsync = AsyncFuture()\n-        self.advanceAsync = AsyncFuture()\n-        self.eventAdvanceFunc = {'finish': lambda: self.plotAsync.set_result(None), 'reset': lambda: self.plotAsync == AsyncFuture()}\n-        self.eventDoneFunc = {'finish': lambda: self.advanceAsync.set_result(None), 'reset': lambda: self.advanceAsync == AsyncFuture()}\n-        self.plotCondition = [True if hasattr(self.gameInstance, 'collision_queue') and self.gameInstance.collision_queue.getNumEntries() > 1 and self.researchNode.getName() == gameInstance.collision_queue.sortEntries().getEntry(1).getIntoNode().getName() else False]\n-        self.eventCounter = len(self.plotCondition)\n-        self.plotEvents = {\"researchGoalAchieved\": self.plotCondition[0]}\n-        print('Initializing plot line')\n-        taskMgr.add(self.conditionBasedAdvancer, \"ConditionBasedAdvancer\") \n-        taskMgr.add(self.plotLine, \"PlotLine\")\n-\n-game = Game(Plot)\n base.run()\n\\ No newline at end of file\n"
                }
            ],
            "date": 1762870163588,
            "name": "Commit-0",
            "content": "# /// script\n# dependencies = [\n#    \"panda3d\",\n# ]\n# ///\n\n'''\nGame made by: Adeel Siddiqi and\nThis is\nA game made for TSA Videogame design 2025-2026 \n'''\n__author__ = 'Adeel Siddiqi'\n\nimport os\nimport random\nfrom direct.actor.Actor import Actor\nfrom direct.showbase.ShowBase import ShowBase\nfrom direct.task import Task\nfrom direct.showbase.DirectObject import DirectObject\nfrom direct.controls.InputState import InputState\nfrom direct.particles.ParticleEffect import ParticleEffect\nimport direct.gui.DirectGuiGlobals as DGG\nfrom panda3d.ai import AIWorld, AICharacter\nfrom panda3d.core import (\n    PandaSystem,\n    FrameBufferProperties, \n    WindowProperties, \n    GraphicsOutput,\n    StringStream,\n    AsyncFuture,\n    LVecBase3f,\n    LVecBase4f,\n    LPoint3f, \n    NodePath,\n    TextNode, \n    CollisionTraverser, \n    CollisionNode, \n    CollisionHandlerPusher, \n    CollisionSphere, \n    CollisionBox,\n    LVector3, \n    CollisionRay, \n    BitMask32, \n    CollisionHandlerQueue,\n    loadPrcFileData,\n    CollisionTraverser,\n    BitMask32,\n    TransparencyAttrib,\n    CardMaker,\n    SamplerState,\n    VirtualFileSystem,\n    Filename,\n    DirectionalLight,\n    AmbientLight,\n    Camera,\n    OrthographicLens,\n    Texture,\n    Vec3,\n    Vec4,\n    Shader,\n    CollisionHandlerEvent\n)\nfrom direct.gui.DirectGui import (\n    OnscreenImage,\n    OnscreenText, \n    DirectButton,\n    DirectSlider,\n    DirectScrolledFrame,\n    DirectLabel,\n    DirectFrame,\n    DirectEntry,\n    DirectWaitBar\n)\n\nloadPrcFileData('', 'gl-version 4 1')\n'''\nThe camera controller is a class that handles the movement and rotation of the camera in the game.\nThis is the core of the camera, and it is responsible for handling the input from the user and updating the camera accordingly.\nThe default values are set to 9 for velocity and 0.2 for mouse sensitivity, and the initial position of the camera is set to (-0.5, -12, 7.7).\nThe default view is First Person. I will add a third person view later\n'''\nclass CameraControllerBehaviour(DirectObject):\n    _instances = 0\n    def __init__(self, camera, velocity=9, mouse_sensitivity=0.2, initial_pos=(0, 0, 114), showbase=None):\n        self._camera = camera\n        self._velocity = velocity\n        self._mouse_sensitivity = mouse_sensitivity\n        self._keys = None\n        self._input_state = InputState()\n        self._heading = 0.0\n        self._pitch = 0.0\n        self._yaw = 0.0\n        self._roll = 0.0\n        self._prev_mouse = None\n        self._showbase = base if showbase is None else showbase\n        self._gravity = LVector3(0, 0, -2)  # Set gravity vector pointing downward\n        self._instance = CameraControllerBehaviour._instances\n        CameraControllerBehaviour._instances += 1\n        self._camera.setPos(*initial_pos)\n        # Set the initial position of the camera\n\n    def setup(self, keys={\n        'w':\"forward\", \n        's':\"backward\",\n        'a':\"left\",\n        'd':\"right\",\n        'space':\"up\",\n        'e':\"down\"\n    }):\n        self._keys = keys\n        for key in self._keys:\n            self._input_state.watchWithModifiers(self._keys[key], key)\n\n        self._showbase.disableMouse()\n\n        props = WindowProperties()\n        props.setMouseMode(WindowProperties.MConfined)\n        props.setCursorHidden(True)\n\n        self._showbase.win.requestProperties(props)\n        \n        self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n    \n    def rewatch(self, keys=None, mouse_sensitivity=.2):\n        if keys is not None:\n            self._keys = keys\n        for key in self._keys:\n            self._mouse_sensitivity = mouse_sensitivity\n            self._showbase.taskMgr.add(self.update, \"UpdateCameraTask\" + str(self._instance))\n            self._input_state.watchWithModifiers(self._keys[key], key)\n    \n    def destroy(self):\n        self.disable()\n        self._input_state.delete()\n\n        del self\n\n    @property\n    def velocity(self):\n        return self._velocity\n\n    @velocity.setter\n    def velocity(self, velocity):\n        self._velocity = velocity\n    \n    @property\n    def mouse_sensitivity(self):\n        return self._mouse_sensitivity\n\n    @mouse_sensitivity.setter\n    def mouse_sensitivity(self, sensitivity):\n        self._mouse_sensitivity = sensitivity\n\n    def disable(self):\n        self._showbase.taskMgr.remove(\"UpdateCameraTask\" + str(self._instance))\n\n        props = WindowProperties()\n        props.setCursorHidden(False)\n\n        self._showbase.win.requestProperties(props)\n                \n    def update(self, task):\n        dt = globalClock.getDt()\n        \n        # Get mouse movement for rotation\n        md = self._showbase.win.getPointer(0)\n        x = md.getX()\n        y = md.getY()\n        #center_x = self._showbase.win.getXSize() // 2\n        #center_y = self._showbase.win.getYSize() // 2\n\n        if self._prev_mouse is not None:\n            prev_x, prev_y = self._prev_mouse\n            self._yaw = self._yaw - (x - prev_x) * self._mouse_sensitivity\n            self._pitch = self._pitch - (y - prev_y) * self._mouse_sensitivity\n        self._prev_mouse = (x, y)\n\n        # Clamp the pitch to prevent camera flipping over\n        self._pitch = max(-89, min(89, self._pitch))\n        \n        # Set the camera's orientation\n        self._showbase.camera.setHpr(self._yaw, self._pitch, self._roll)\n        \n        # Access the camera's lens and set the focal length\n        lens = self._showbase.cam.node().getLens()\n        lens.setFocalLength(0.25)\n        \n        # Calculate the position increment\n        pos_increment = self._velocity * dt\n        \n        # Handle keyboard input for movement\n        if  self._input_state.isSet('forward'):\n            self._showbase.camera.setY(self._showbase.camera, pos_increment)\n\n        if  self._input_state.isSet('backward'):\n            self._showbase.camera.setY(self._showbase.camera, -pos_increment)\n\n        if  self._input_state.isSet('left'):\n            self._showbase.camera.setX(self._showbase.camera, -pos_increment)\n\n        if  self._input_state.isSet('right'):\n            self._showbase.camera.setX(self._showbase.camera, pos_increment)\n\n        if  self._input_state.isSet('up'):\n            self._showbase.camera.setZ(self._showbase.camera, pos_increment)\n\n        if  self._input_state.isSet('down'):\n            self._showbase.camera.setZ(self._showbase.camera, -pos_increment)\n        \n        self.cam_pos = self._showbase.camera.getPos(self._showbase.render)\n        # Apply gravity to the camera's position\n        (self.cam_pos) += self._gravity * min(dt, 1/64.0)\n        \n        # Update the camera's position\n        self._showbase.camera.setPos(self.cam_pos)\n\n        return Task.cont\n\nclass EnemyController():\n    def __init__(self, showbase=None):\n        self.showbase = base if showbase is None else showbase\n        self.EnemyModelDict = {}\n        self.EnemyAIDotDict = {}\n        self.EnemyCollisionDict = {}\n        self.EnemyAICharDict = {}\n        self.EnemyAIBehaviourDict = {}\n        self.EnemyHealthDict = {}\n        self.EnemyAnimControlDict = {}\n        self.EnemyDict = {'model':self.EnemyModelDict,\n                          'ai_dot':self.EnemyAIDotDict,\n                          'collision':self.EnemyCollisionDict,\n                          'ai_char':self.EnemyAICharDict,\n                          'ai_behaviour':self.EnemyAIBehaviourDict,\n                          'health':self.EnemyHealthDict,\n                          }\n        self.EnemyAIWorld = AIWorld(self.showbase.render)\n        self.EnemyCollisionHandler = CollisionHandlerEvent()\n        self.EnemyCollisionHandler.addInPattern('into-camera')\n        self.showbase.accept(\"into-camera\",self.DamagePlayer)\n\n        #Because it will spam message in update\n        self.Messagesent = False\n        self.Run = True\n        self._gravity = LVector3(0, 0, -2)\n        self.EnemyCount = 0\n        self.waveCount = 1\n        self.Font = self.showbase.loader.loadFont('assets/fonts/dimitri.ttf')\n    async def setup(self, modelpath, extraAnims, num, height, health, waves= 5, changePerWave=1):\n        self.waveMethod = AsyncFuture()\n        self.num = num\n        self.Run = True\n        # Creating the wave count\n        self.WaveCounttext = OnscreenText(text=\"Wave: 1\", pos=(0,0.9), scale=0.1)\n        self.WaveCounttext.setFont(self.Font)\n        for i in range(waves):\n            for j in range(self.num):\n                if self.waveCount > i:\n                    continue    \n                if self.Run == False:\n                    print('Break')\n                    break\n                # Set up models and make them loop animations\n                self.EnemyModelDict['enemy' + str(j)] = Actor(modelpath, extraAnims if extraAnims is not None else None)\n                self.EnemyModelDict['enemy' + str(j)].loop(self.EnemyModelDict['enemy' + str(j)].getAnimNames()[0])\n                self.EnemyModelDict['enemy' + str(j)].reparentTo(self.showbase.render)\n                self.EnemyModelDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n                \n                # Set up shaders, pretty custom\n                game.shader(EnterNode=self.EnemyModelDict['enemy' + str(j)])\n\n                # We need to use a place holder model because the model will point at the user, so we just set position of the actual model\n                self.EnemyAIDotDict['enemy' + str(j)] = self.showbase.loader.loadModel(\"assets/models/aidotupdater.bam\")\n                self.EnemyAIDotDict['enemy' + str(j)].reparentTo(self.showbase.render)\n                self.EnemyAIDotDict['enemy' + str(j)].setPos(random.randint(-100, 100), random.randint(-100, 100), height)\n                \n                # Collision\n                self.EnemyCollisionDict['enemy' + str(j)] = CollisionNode('enemy' + str(j))\n                self.EnemyCollisionDict['enemy' + str(j)].addSolid(CollisionBox(LPoint3f(2, 0, 9), 4,3,12))\n                self.EnemyColliderPath = self.EnemyModelDict['enemy' + str(j)].attachNewNode(self.EnemyCollisionDict['enemy' + str(j)])\n\n                # AI\n                self.EnemyAICharDict['enemy' + str(j)] = AICharacter('enemy' + str(j), self.EnemyAIDotDict['enemy' + str(j)], 100, .05, 5)\n                self.EnemyAIWorld.addAiChar(self.EnemyAICharDict['enemy' + str(j)])\n                self.EnemyAIBehaviourDict['enemy' + str(j)] = self.EnemyAICharDict['enemy' + str(j)].getAiBehaviors()\n                self.EnemyAIBehaviourDict['enemy' + str(j)].pursue(self.showbase.camera)\n                self.EnemyAIBehaviourDict['enemy' + str(j)].arrival(1)\n                self.EnemyHealthDict['enemy' + str(j)] = health\n\n                # Add collisions\n                self.showbase.cTrav.addCollider(self.EnemyColliderPath, self.EnemyCollisionHandler)\n                game.pusher.addCollider(self.EnemyColliderPath, self.EnemyModelDict['enemy' + str(j)])\n\n                print(\"Enemy \" + str(j) + \" spawned\")\n            if self.waveCount > i:\n                continue\n            else:\n                await self.waveMethod\n                print(\"Wave \" + str(i+2) + \" done\")\n                self.waveMethod = AsyncFuture()\n                self.WaveCounttext.setText(\"Wave: \" + str(i+2))\n                self.waveCount += 1\n                self.Messagesent = False\n                self.num += changePerWave\n        print('Done')\n    def DamagePlayer(self, collision='nothing'):\n        for i in range(len(self.EnemyDict['model'])+1):\n            if 'enemy' + str(i) in str(collision) and 'camera' in str(collision):\n                Game.PlayerHealth -= 1\n    def EnemyHit(self, enemy):\n        self.EnemyDict['health'][enemy.getName()] -= 1\n        AnimControl = self.EnemyDict['model'][enemy.getName()].getAnimControl('hit')\n        if AnimControl.isPlaying():\n            return None\n        else:\n            AnimControl.setPlayRate(.5)\n            self.EnemyDict['ai_behaviour'][enemy.getName()].pauseAi('all')\n            self.EnemyDict['model'][enemy.getName()].play('hit')\n    def MainUpdate(self):\n        self.EnemyAIWorld.update()\n        for enemy, aidot in zip(self.EnemyDict['model'].values(), self.EnemyDict['ai_dot'].values()):\n            if not enemy.isEmpty() and not aidot.isEmpty():\n                dt = globalClock.getDt()\n                aidotpos = aidot.getPos()\n                (aidotpos) += self._gravity * min(dt, 1/64.0)\n                aidot.setPos(aidotpos)\n                enemy.setH((aidot.getH())-180)\n                enemy.setPos(aidotpos)\n        for key in list(self.EnemyDict['health'].keys()):\n            if self.EnemyDict['health'][key] <= 0:\n                self.EnemyDict['model'][key].cleanup()\n                self.EnemyDict['ai_dot'][key].removeNode()\n                self.EnemyAIWorld.removeAiChar(key)\n                self.EnemyDict['ai_behaviour'][key].removeAi(key)\n                del self.EnemyDict['model'][key]\n                del self.EnemyDict['ai_dot'][key]\n                del self.EnemyDict['collision'][key]\n                del self.EnemyDict['ai_char'][key]\n                del self.EnemyDict['ai_behaviour'][key]\n                del self.EnemyDict['health'][key]\n                self.EnemyCount += 1\n        \n        if self.EnemyDict['model'] == {} and not self.Messagesent:\n            self.Messagesent = True\n            self.waveMethod.set_result(None)\n        \n        for enemy in list(self.EnemyDict['model'].values()):\n            key = list(self.EnemyDict['model'].keys())[list(self.EnemyDict['model'].values()).index(enemy)]\n            if not enemy.getAnimControl('hit').isPlaying() and self.EnemyDict['ai_behaviour'][key].behaviorStatus('pursue') == 'paused':\n                self.EnemyDict['ai_behaviour'][key].resumeAi('all')\n                enemy.loop('Walk')\n    def destroy(self, KeepAI=False):\n        self.Run = False\n        self.WaveCounttext.destroy()\n        if KeepAI:\n            for enemy in list(self.EnemyDict['model'].keys()):\n                self.EnemyAIWorld.removeAiChar(enemy)\n                self.EnemyDict['ai_behaviour'][enemy].removeAi(enemy)\n        self.EnemyDict['model'] = {}\n        self.EnemyDict['ai_dot'] = {}\n        self.EnemyDict['collision'] = {}\n        self.EnemyDict['ai_char'] = {}\n        self.EnemyDict['ai_behaviour'] = {}\n        self.EnemyDict['health'] = {}\nclass Game(ShowBase):\n    vfs = VirtualFileSystem.getGlobalPtr()\n    inaMenu = True\n    mouse_sensitivity = 0.5\n    PlayerHealth = 100\n    sunDirection = -.2\n    cycleOscillation = {'dawnOrDusk' : 'down', 'notQiyamah': .45}\n    keys = {'w':\"forward\",\n            's':\"backward\",\n            'a':\"left\",\n            'd':\"right\",\n            'space':\"up\",\n            'e':\"down\"}\n    def textTypewriteAnimation(self, textPos, text, interval=0.05):\n        textSplit = list(text)\n        textNode = OnscreenText(text='', pos=textPos, scale=0.07, fg=(1,1,1,1), align=TextNode.ACenter)\n        def cleanup():\n            textNode.destroy()\n        async def typewrite():\n            for char in textSplit:\n                textNode.setText(textNode.getText() + char)\n                await Task.pause(interval)\n            return Task.Done\n        taskMgr.add(typewrite(), 'typewriteTask', uponDeath=cleanup)\n    def dayNightCycle(self):\n        steps = {'sunSpeed': 0.0005, 'rotationSpeed': 0.000375}\n        self.cycleOscillation['notQiyamah'] -= steps['rotationSpeed']\n        if self.cycleOscillation['dawnOrDusk'] == 'down':\n            self.sunDirection += steps['sunSpeed']\n            if self.sunDirection >= .3:\n                self.cycleOscillation['dawnOrDusk'] = 'up'\n                print(self.cycleOscillation['notQiyamah'])\n                self.cycleOscillation['notQiyamah'] = 0.45\n                steps['rotationSpeed'] = 0.000375\n                print('switch up')\n        elif self.cycleOscillation['dawnOrDusk'] == 'up':\n            self.sunDirection -= steps['sunSpeed']\n            if self.sunDirection <= -.3:\n                self.cycleOscillation['dawnOrDusk'] = 'down'\n                steps['rotationSpeed'] = 0.00017\n                print(self.cycleOscillation['notQiyamah'])\n                print('switch down')\n        for models in self.currentModels:\n            models.setShaderInput('light0_direction', (self.cycleOscillation['notQiyamah'], self.sunDirection, 0))\n    def PlayerHUD(self):\n        self.HUDMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                        frameSize=(-1.25, 1.25, -0.15, 0.15),\n                                        pos=(0, 0, -.75))\n        self.rover2PersonFrame = DirectFrame(frameColor=(0.2, 0.2, 0.2, 1),\n                                             frameSize=(-.5, .5, -0.1, 0.1),\n                                             pos=(0, 0, -.8))\n    def exportScene(self):\n        file_name = input(\"Enter file name: \")\n        ss = StringStream()\n        self.render.ls(out=ss)\n        with open(f\"scene_graph-{file_name}.txt\", \"w\", encoding=\"utf-8\") as f:\n            f.write(ss.get_data().decode(\"utf-8\"))\n    def Death(self):\n        self.CameraOperator()\n        def LoadMainMenu(self):\n            # remove task, reset\n            self.deathFrame.destroy()\n            self.btnMainMenu.destroy()\n            self.PlayerHealth = 100\n            self.clickSound.play()\n            taskMgr.remove('Update')\n            self.SaveProgress(reset=True)\n            self.HealthBar.destroy()\n            self.playButtonMethod = AsyncFuture()\n            self.MainMenu()\n            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n            self.cam_controller.setup(keys=self.keys)\n            self.cam_controller.disable()\n            self.currentwave = 0\n            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n            for child in children_to_remove:\n                if '__Actor_modelRoot' in child.getChildren():\n                    child.cleanup()\n                else:    \n                    child.removeNode()\n            taskMgr.add(self.loadScene())\n        self.deathFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n                                      frameSize=(-1.4, 1.4, -1, 1), \n                                      pos=(0, 0, 0), \n                                      scale=(1, 1, 1), \n                                      text=\"You died\", \n                                      text_font=self.Font,\n                                      text_scale=0.3, \n                                      text_pos=(0, .75), \n                                      text_fg=(1, 0, 0, 1), \n                                      text_align=TextNode.ACenter)\n        self.btnMainMenu = DirectButton(\n            parent=self.deathFrame,\n            frameColor=(0.15, 0.15, 0.15, 1),\n            frameSize=(-0.4, 0.4, -0.08, 0.16),\n            pos=LPoint3f(0, 0, -0.15),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            text='Exit to Main Menu',\n            text_align=TextNode.A_center,\n            text_scale=(0.075, 0.075),\n            text_pos=(0, 0),\n            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n            text_bg=LVecBase4f(0, 0, 0, 0),\n            command=LoadMainMenu,\n            extraArgs=[self],\n        )\n    def MouseIn(self):\n#           if not self.inaMenu:\n#            self.particleEffect.start(self.ak47, self.ak47)\n        props = self.win.getProperties()\n        # This is needed to for WebGL. If the window is not in focus, the mouse won't work, so we need to request focus\n        if not self.inaMenu:\n            if not props.getForeground() or not props.getCursorHidden() or props.getMouseMode() != WindowProperties.MConfined:\n                self.win.requestProperties(WindowProperties(foreground=True, mouse_mode=WindowProperties.MConfined, cursor_hidden=True))\n        \n        # Create a CollisionRay for the mouse click\n        ray_node = CollisionNode('click-ray')\n        ray = CollisionRay()\n        ray.setOrigin(0, 0, 0)  # Start at the camera\n        ray.setDirection(0, 1, 0)  # Point forward\n        ray_node.addSolid(ray)\n\n        # Attach the CollisionRay to the camera and set it to the right bitmasks\n        self.ray_path = self.camera.attachNewNode(ray_node)\n\n        # Create a quene to store the collisions and add the CollisionRay to the CollisionTraverser\n        self.collision_queue = CollisionHandlerQueue()\n        self.cTrav.addCollider(self.ray_path, self.collision_queue)\n        taskMgr.add(self.click, \"clickTask\")\n    def MouseUp(self):\n        self.particleEffect.disable()\n        if hasattr(self, 'ray_path'):\n            self.cTrav.removeCollider(self.ray_path)  # Remove collider from traverser\n            self.ray_path.removeNode()  # Safely remove the ray\n            self.collision_queue.clearEntries()\n    def SaveProgress(self, reset=False):\n        if reset:\n            self.save_file = open(\"save.txt\", \"w\")\n            self.save_file.write('LPoint3f(0, 0, 114)\\n')\n            self.save_file.write(str(0))\n            self.save_file.close()\n        else:\n            self.save_file = open(\"save.txt\", \"w\")\n            self.save_file.write(str(self.camera.getPos()) + '\\n')\n            self.save_file.close()\n    def CameraOperator(self):\n        # When this function is called, we check if we are in a menu, if we are then we watch our new keys\n        # This is critical for one we don't setup the camera again, and two if the player decides to change controls\n        # And then we switch our bool to false, as we are no longer in a menu, enabling clicking to focus the mouse\n        if self.inaMenu:\n            self.cam_controller.rewatch(self.keys, mouse_sensitivity=self.mouse_sensitivity)\n            self.inaMenu = False\n        \n        # If we are not in a menu, then we disable the camera controller\n        # And set our bool to true, critical because our click function refocuses the window\n        else:\n            self.cam_controller.disable()   \n            self.inaMenu = True\n        # Using our boolean we pass an if statement to effectively switch when oue mouse focuses on clicks\n    def TutorialMenu(self):\n        self.clickSound.play()\n        self.paused = True\n        self.currentTime = 0\n        self.tutorialMainFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                        frameSize=(-1.25, 1.25, -0.9, 0.9),\n                                        pos=(0, 0, 0)\n        )\n        self.tutorialLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                        frameSize=(-.3, .3, -0.1, 0.1),\n                                        pos=(-.8, 0, .65),\n                                        parent=self.tutorialMainFrame,\n                                        relief=None,\n                                        text=\"Tutorial\",\n                                        text_fg=(0, 0, 0, 1),\n                                        text_pos=(0, 0),\n                                        text_scale=0.2,\n                                        text_font=self.Font,\n                                        text_align=TextNode.ACenter\n        )\n        self.tutorialVideoControlFrame = DirectFrame(parent=self.tutorialMainFrame,\n                                                    frameColor=(0.3, 0.3, 0.3, 1),\n                                                    frameSize=(-1, 1, -0.1, 0.1),\n                                                    pos=(0, 0, -.7)\n        )\n        self.tutorialVideo = self.loader.loadTexture(r\"assets/audio/tutorial.mp4\")\n        self.cm = CardMaker(\"card\")\n        self.cm.setFrame(-.8, .8, -0.55, 0.55)\n        self.cm.setUvRange(self.tutorialVideo)\n        self.card = self.render2d.attachNewNode(self.cm.generate())\n        self.card.setTexture(self.tutorialVideo)\n        self.card.setPos(-0, 0, 0)\n        self.card.reparentTo(self.tutorialMainFrame)\n        self.tutorialAudio = self.loader.loadSfx(r\"assets/audio/tutorial.mp4\")\n        self.tutorialVideo.synchronizeTo(self.tutorialAudio)\n\n        def PlayblackSliderMethod(self):\n            self.tutorialAudio.stop()\n            self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n            self.currentTime = self.videoPlaybackSlider['value']\n            self.paused = True\n        def PausePlayMethod(self):\n            if self.paused == True:\n                #When clicked from pause to play\n                self.paused = False\n                self.videoPauseButton['image'] = 'assets/images/playIcon.png'\n            else:\n                self.paused = True\n                self.videoPauseButton['image'] = 'assets/images/pauseIcon.png'\n            if self.tutorialAudio.status() == self.tutorialAudio.PLAYING:\n                self.currentTime = self.tutorialAudio.getTime()\n                self.tutorialAudio.stop()\n            else:\n                self.tutorialAudio.setTime(self.currentTime)\n                self.tutorialAudio.play()\n        \n        self.videoPlaybackSlider = DirectSlider(range=(0, self.tutorialVideo.getVideoLength()),\n                                  value=0, \n                                  command=PlayblackSliderMethod, \n                                  frameSize=(-.75, .75, -0.1, 0.1),\n                                  frameColor=(0.8, 0.8, 0.8, 1),\n                                  thumb_frameSize=(-.015, .015, -.015, .015),\n                                  thumb_frameColor=(1, 0, 0, 1),\n                                  pos=LPoint3f(0, 0, 0),\n                                  orientation='horizontal', \n                                  parent=self.tutorialVideoControlFrame,\n                                  thumb_relief=DGG.FLAT,\n                                  extraArgs=[self]\n                                  )\n        self.videoPauseButton = DirectButton(parent=self.tutorialVideoControlFrame,\n                                             frameColor=(0.8, 0.8, 0.8, 1),\n                                             frameSize=(-.05, .05, -0.05, 0.05),\n                                             pos=LPoint3f(-.9, 0, 0),\n                                             relief=None,\n                                             image = 'assets/images/pauseIcon.png',\n                                             image_pos=(0, 0, 0),\n                                             image_scale=(0.1, 0.1, 0.1),\n                                             command=PausePlayMethod,\n                                             extraArgs=[self]\n                                             )\n        self.videoPauseButton.setTransparency(TransparencyAttrib.MAlpha)\n    def OptionMenu(self):\n        self.clickSound.play()\n        self.mouseSettingsOpen = False\n        self.keyboardSettingsOpen = False\n        self.audioSettingsOpen = False\n        self.aboutSettingsOpen = False\n        \n        def clear_menu():\n            if self.mouseSettingsOpen:\n                self.sensitivityFrame.destroy()\n                self.sensitivityLabel.destroy()\n                self.sensitivitySlider.destroy()\n                self.mouseSettingsOpen = False  \n            if self.keyboardSettingsOpen:\n                self.forwardFrame.destroy()\n                self.backwardFrame.destroy()\n                self.leftFrame.destroy()\n                self.rightFrame.destroy()\n                self.forwardLabel.destroy()\n                self.backwardLabel.destroy()\n                self.leftLabel.destroy()\n                self.rightLabel.destroy()\n                self.forwardEntry.destroy()\n                self.backwardEntry.destroy()\n                self.leftEntry.destroy()\n                self.rightEntry.destroy()\n                self.btnSave.destroy()\n                self.disclamerLabel.destroy()\n                self.keyboardSettingsOpen = False\n#            if self.audioSettingsOpen:\n\n            if self.aboutSettingsOpen:\n                self.aboutLabel.destroy()\n                self.gameAboutLabel.destroy()\n                self.aboutSettingsOpen = False\n        self.optionMenuBg = OnscreenImage(image='assets/images/optionMenuBg.png', pos=(0, 0, 0), scale=(.75, .5, 1))\n        self.optionMenuBg.setTransparency(TransparencyAttrib.MAlpha)\n\n        self.scrolledFrame = DirectScrolledFrame(\n            frameColor=(0.4, 0.4, 0.4, 1),\n            frameSize=(-.2, .6, -.8, .7),\n            pos=LPoint3f(-0.05, 0, 0),\n            canvasSize=(-.4, .4, -1, 1),\n            verticalScroll_relief=None,\n            horizontalScroll_relief=None,\n        )\n        self.scrolledFrame.setManageScrollBars()\n        self.scrolledFrame.verticalScroll['frameSize'] = (-.01, .01, -.01, .01)\n        self.scrolledFrame.verticalScroll['frameColor'] = (0.4, 0.4, 0.4, 1)\n        self.scrolledFrame.verticalScroll['thumb_relief'] = DGG.FLAT\n        self.scrolledFrame.verticalScroll['decButton_relief'] = None\n        self.scrolledFrame.verticalScroll['incButton_relief'] = None\n        self.scrolledFrame.horizontalScroll['frameSize'] = None\n\n        def MouseSettingMethod(self):\n            self.sensitivityFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                                frameSize=(-.3, .3, -0.1, 0.1),\n                                                pos=LPoint3f(-.05, 0, .85),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT\n                                                )\n            self.sensitivityLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                                text=\"Mouse Sensitivity\", \n                                                text_scale=0.05, \n                                                pos=LPoint3f(-.1, 0, .875), \n                                                parent=self.scrolledFrame.getCanvas(), \n                                                relief=DGG.FLAT\n                                                )\n            def changesensitivity():\n                self.mouse_sensitivity = self.sensitivitySlider['value'] * .2\n                print(self.sensitivitySlider['value'])      \n            self.sensitivitySlider = DirectSlider(range=(0,2), \n                                  value=1, \n                                  command=changesensitivity, \n                                  frameSize=(-.25, .25, -0.05, 0.05),\n                                  frameColor=(0.8, 0.8, 0.8, 1),\n                                  thumb_frameSize=(-.01, .01, -.01, .01),\n                                  thumb_frameColor=(0.4, 0.4, 0.4, 1),\n                                  pos=LPoint3f(-.05, 0, .8),\n                                  orientation='horizontal', \n                                  parent=self.scrolledFrame.getCanvas(),\n                                  thumb_relief=DGG.FLAT\n                                  )\n            clear_menu()\n            self.mouseSettingsOpen = True\n        def KeyboardSettingMethod(self):\n            def ForwardKeyMethod(key, self):\n                self.forwardKey = key\n            def BackwardKeyMethod(key, self):\n                self.backwardKey = key\n            def LeftKeyMethod(key, self):\n                self.leftKey = key\n            def RightKeyMethod(key, self):\n                self.rightKey = key\n            def SaveMethod(self):\n                if not hasattr(self, 'forwardKey'):\n                    self.forwardKey = 'w'\n                if not hasattr(self, 'backwardKey'):\n                    self.backwardKey = 's'\n                if not hasattr(self, 'leftKey'):\n                    self.leftKey = 'a'\n                if not hasattr(self, 'rightKey'):\n                    self.rightKey = 'd'\n                self.keys = {\n                    self.forwardKey: \"forward\",\n                    self.backwardKey: \"backward\",\n                    self.leftKey: \"left\",\n                    self.rightKey: \"right\",\n                    'space': \"up\",\n                    'e': \"down\"\n                }\n            self.forwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                                text=\"Forward\", \n                                                text_scale=0.05, \n                                                pos=LPoint3f(-.2, 0, .875), \n                                                parent=self.scrolledFrame.getCanvas(), \n                                                relief=DGG.FLAT,\n                                                sortOrder=2\n                                                )\n            self.backwardLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                                text=\"Backward\", \n                                                text_scale=0.05, \n                                                pos=LPoint3f(-.19, 0, .625), \n                                                parent=self.scrolledFrame.getCanvas(), \n                                                relief=DGG.FLAT,\n                                                sortOrder=2\n                                                )\n            self.leftLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                                text=\"Left\", \n                                                text_scale=0.05, \n                                                pos=LPoint3f(-.25, 0, .375), \n                                                parent=self.scrolledFrame.getCanvas(), \n                                                relief=DGG.FLAT,\n                                                sortOrder=2\n                                                )\n            self.rightLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                                text=\"Right\", \n                                                text_scale=0.05, \n                                                pos=LPoint3f(-.24, 0, .125), \n                                                parent=self.scrolledFrame.getCanvas(), \n                                                relief=DGG.FLAT,\n                                                sortOrder=2\n                                                )\n            self.forwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n                                                frameSize=(-.15, 0, -0.03, 0.03),\n                                                pos=LPoint3f(-.15, 0, .825),\n                                                text_pos= (-0.1, -.015),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT,\n                                                text_scale=0.05,\n                                                sortOrder=2,\n                                                command=ForwardKeyMethod,\n                                                extraArgs=[self],\n                                                initialText='W'\n                                                )\n            self.backwardEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n                                                frameSize=(-.15, 0, -0.03, 0.03),\n                                                pos=LPoint3f(-.15, 0, .575),\n                                                text_pos= (-0.1, -.015),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT,\n                                                text_scale=0.05,\n                                                sortOrder=2,\n                                                command=BackwardKeyMethod,\n                                                extraArgs=[self],\n                                                initialText='S'\n                                                )\n            self.leftEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n                                                frameSize=(-.15, 0, -0.03, 0.03),\n                                                pos=LPoint3f(-.15, 0, .325),\n                                                text_pos= (-0.1, -.015),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT,\n                                                text_scale=0.05,\n                                                sortOrder=2,\n                                                command=LeftKeyMethod,\n                                                extraArgs=[self],\n                                                initialText='A'\n                                                )\n            self.rightEntry = DirectEntry(frameColor=(1, 1, 1, 1),\n                                                frameSize=(-.15, 0, -0.03, 0.03),\n                                                pos=LPoint3f(-.15, 0, .075),\n                                                text_pos= (-0.1, -.015),    \n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT,\n                                                text_scale=0.05,\n                                                sortOrder=2,\n                                                command=RightKeyMethod,\n                                                extraArgs=[self],\n                                                initialText='D'\n                                                )\n            self.forwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                                frameSize=(-.3, .3, -0.1, 0.1),\n                                                pos=LPoint3f(-.05, 0, .85),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT\n                                                )\n            self.backwardFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                                frameSize=(-.3, .3, -0.1, 0.1),\n                                                pos=LPoint3f(-.05, 0, .6),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT\n                                                )\n            self.leftFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                                frameSize=(-.3, .3, -0.1, 0.1),\n                                                pos=LPoint3f(-.05, 0, .35),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT\n                                                )\n            self.rightFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                                frameSize=(-.3, .3, -0.1, 0.1),\n                                                pos=LPoint3f(-.05, 0, .1),\n                                                parent=self.scrolledFrame.getCanvas(),\n                                                relief=DGG.FLAT\n                                                )\n            self.btnSave = DirectButton(\n                frameColor=(0.2, 0.2, 0.2, 1),\n                frameSize=(-0.09, 0.09, -0.025, 0.05),\n                text='Save',\n                text_scale=0.05,\n                text_fg=(0.5, 0.5, 0.5, 1),\n                pos=LPoint3f(-0.25, 0, -0.075),\n                relief=1,\n                parent=self.scrolledFrame.getCanvas(),\n                command=SaveMethod,\n                extraArgs=[self],\n                sortOrder=2\n            )\n            self.disclamerLabel = DirectLabel(\n                frameColor=(0.6, 0.6, 0.6, 1),\n                text=\"*Press enter each key*\",\n                text_scale=0.05,\n                pos=LPoint3f(0, 0, -0.2),\n                parent=self.scrolledFrame.getCanvas(),\n                relief=None\n            )\n            clear_menu()\n            self.keyboardSettingsOpen = True\n        def AboutSettingMethod(self):\n            self.aboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                        text=\"About\",\n                                        text_scale=0.1,\n                                        pos=LPoint3f(-0.025, 0, 0.85),\n                                        parent=self.scrolledFrame.getCanvas(),\n                                        relief=None\n                                        )\n            self.gameAboutLabel = DirectLabel(frameColor=(0.6, 0.6, 0.6, 1),\n                                            text= \"TSA Videogame Design 2025-2026 \\n '' is a  game developed by \\n  the team 1034-1 for the 2025-2026 \\n  \\\n                                            Technology Student Association Competition for Video Game Design. \\n this is a  based on the theme of \\n\\\n                                            We developed this game using \\n the Panda3D game engine \\n differing from Unity and Unreal as \\n it is a purely text edited engine\",\n                                            text_scale=0.04,\n                                            pos=LPoint3f(-0.04, 0, 0.3),\n                                            parent=self.scrolledFrame.getCanvas(),\n                                            relief=None\n                                            )\n            clear_menu()\n            self.aboutSettingsOpen = True\n        self.btnMouse = DirectButton(\n            frameColor=(0.4, 0.4, 0.4, 1),\n            frameSize=(-0.09, 0.09, -0.07, 0.13),\n            pos=LPoint3f(-0.37666, 0, 0.57666),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            image= 'assets/images/mouseIcon.png',\n            image_scale = (.09, .09, .09),\n            image_pos = (0, 0, 0.03),\n            image_hpr = (0, 0, 0),\n            command=MouseSettingMethod,\n            extraArgs=[self],\n        )\n        self.btnMouse.setTransparency(TransparencyAttrib.MAlpha)\n\n        self.btnKeyboard = DirectButton(\n            frameColor=(0.4, 0.4, 0.4, 1),\n            frameSize=(-0.09, 0.09, -0.07, 0.14),\n            pos=LPoint3f(-0.376666, 0, 0.33666),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            image= 'assets/images/keyboardIcon.png',\n            image_scale = (.09, .09, .09),\n            image_pos = (0, 0, .03),\n            image_hpr = (0, 0, 0),\n            command=KeyboardSettingMethod,\n            extraArgs=[self],\n        )\n        self.btnKeyboard.setTransparency(TransparencyAttrib.MAlpha)\n\n        self.btnAudioSet = DirectButton(\n            frameColor=(0.4, 0.4, 0.4, 1),\n            frameSize=(-0.09, 0.09, -0.07, 0.14),\n            pos=LPoint3f(-0.37666, 0, 0.09666),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            image= 'assets/images/audioIcon.png',\n            image_scale = (.07, .07, .07),\n            image_pos = (0, 0, .03),\n            image_hpr = (0, 0, 0),\n            command=self.playButtonMethod.set_result,\n            extraArgs=[None],\n        )\n        self.btnAudioSet.setTransparency(TransparencyAttrib.MAlpha)\n        \n        self.btnAbout = DirectButton(\n            frameColor=(0.4, 0.4, 0.4, 1),\n            frameSize=(-0.09, 0.09, -0.07, 0.14),\n            pos=LPoint3f(-0.37666, 0, -0.13666),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            image= 'assets/images/aboutIcon.png',\n            image_scale = (.07, .07, .07),\n            image_pos = (0, 0, .03),\n            image_hpr = (0, 0, 0),\n            command=AboutSettingMethod,\n            extraArgs=[self],\n        )\n        self.btnAbout.setTransparency(TransparencyAttrib.MAlpha)\n\n        def close_menu():\n            self.scrolledFrame.destroy()\n            self.optionMenuBg.destroy()\n            self.btnAbout.destroy()\n            self.btnAudioSet.destroy()\n            self.btnKeyboard.destroy()\n            self.btnMouse.destroy()\n            self.btnExit.destroy()\n            clear_menu()\n\n        self.btnExit = DirectButton(\n            frameColor=(0.4, 0.4, 0.4, 1),\n            frameSize=(-0.09, 0.09, -0.07, 0.14),\n            pos=LPoint3f(-0.5, 0, 0.75),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=None,\n            scale=LVecBase3f(1, 1, 1),\n            image= 'assets/images/exitIcon.png',\n            image_scale = (.07, .07, .07),\n            image_pos = (0, 0, .03),\n            image_hpr = (0, 0, 0),\n            command=close_menu,\n        )\n        self.btnExit.setTransparency(TransparencyAttrib.MAlpha)\n    def MainMenu(self):\n        self.inaMenu = True\n        self.mainMenuBackground = OnscreenImage(image='assets/images/mainMenuBackground.png', pos=(0, 0, 0), scale=(1.5, 1.5, 1.5))\n        self.titleText = OnscreenText(text=\"TSA Video Game\", pos=(0, .4), scale=0.3, fg=(1, 1, 1, 1), align=TextNode.ACenter)\n        self.titleText.setFont(self.Font)\n        self.btnPlay = DirectButton(\n            frameColor=(0.15, 0.15, 0.15, 1),\n            frameSize=(-0.2, 0.2, -0.03, 0.06),\n            pos=LPoint3f(0, 0, -0.1),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            text='Play',\n            text_align=TextNode.A_center,\n            text_scale=(0.05, 0.05),\n            text_pos=(0, 0),\n            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n            text_bg=LVecBase4f(0, 0, 0, 0),\n            command=self.playButtonMethod.set_result,\n            extraArgs=[None],\n        )\n\n        self.btnOption= DirectButton(\n            frameColor=(0.15, 0.15, 0.15, 1),\n            frameSize=(-0.3, 0.3, -0.03, 0.06),\n            pos=LPoint3f(-1.2, 0, -0.87),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=None,\n            scale=LVecBase3f(1, 1, 1),\n            image= 'assets/images/optionIcon.png',\n            image_scale = (.1, .1, .1),\n            command=self.OptionMenu,\n            extraArgs=[],\n        )\n        self.btnOption.setTransparency(TransparencyAttrib.MAlpha)\n\n        self.btnTutorial= DirectButton(\n            frameColor=(0.15, 0.15, 0.15, 1),\n            frameSize=(-0.3, 0.3, -0.03, 0.06),\n            pos=LPoint3f(1.2, 0, -0.87),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=None,\n            scale=LVecBase3f(1, 1, 1),\n            image= 'assets/images/tutorialIcon.png',\n            image_scale = (.1, .1, .1),\n            command=self.TutorialMenu,\n            extraArgs=[],\n        )\n        self.btnTutorial.setTransparency(TransparencyAttrib.MAlpha)\n    def PauseMenu(self):\n        self.clickSound.play()\n        self.CameraOperator()\n        def LoadMainMenu(self):\n            #Keep AI here, dont remove .setup and reenter waves\n            self.clickSound.play()\n            taskMgr.remove('Update')\n            self.SaveProgress()\n            self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n            self.cam_controller.setup(keys=self.keys)\n            self.cam_controller.disable()\n            self.HealthBar.destroy()\n            self.playButtonMethod = AsyncFuture()\n            self.MainMenu()\n            children_to_remove = [child for child in self.render.getChildren() if child != self.camera]\n            for child in children_to_remove:\n                if '__Actor_modelRoot' in child.getName():\n                    child.cleanup()\n                else:    \n                    child.removeNode()\n            self.pauseFrame.destroy()\n            self.btnMainMenu.destroy()\n            self.btnResume.destroy()\n            taskMgr.add(self.loadScene())\n        def Resume(self):\n            self.clickSound.play()\n            self.pauseFrame.destroy()\n            self.btnMainMenu.destroy()\n            self.btnResume.destroy()\n            self.CameraOperator()\n        self.pauseFrame = DirectFrame(frameColor=(0.6, 0.6, 0.6, 1),\n                                    frameSize=(-.5, .5, -0.3, 0.35),\n                                    pos=LPoint3f(0, 0, 0),\n                                    hpr=LVecBase3f(0, 0, 0),\n                                    relief=DGG.FLAT,\n                                    scale=LVecBase3f(1, 1, 1))\n        self.btnMainMenu = DirectButton(\n            parent=self.pauseFrame,\n            frameColor=(0.15, 0.15, 0.15, 1),\n            frameSize=(-0.4, 0.4, -0.08, 0.16),\n            pos=LPoint3f(0, 0, -0.15),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            text='Save & Exit',\n            text_align=TextNode.A_center,\n            text_scale=(0.1, 0.1),\n            text_pos=(0, 0),\n            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n            text_bg=LVecBase4f(0, 0, 0, 0),\n            command=LoadMainMenu,\n            extraArgs=[self],\n        )\n        self.btnResume = DirectButton(\n            parent=self.pauseFrame,\n            frameColor=(0.15, 0.15, 0.15, 1),\n            frameSize=(-0.4, 0.4, -0.08, 0.16),\n            pos=LPoint3f(0, 0, 0.15),\n            hpr=LVecBase3f(0, 0, 0),\n            relief=1,\n            scale=LVecBase3f(1, 1, 1),\n            text='Resume',\n            text_align=TextNode.A_center,\n            text_scale=(0.1, 0.1),\n            text_pos=(0, 0),\n            text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n            text_bg=LVecBase4f(0, 0, 0, 0),\n            command=Resume,\n            extraArgs=[self],\n        )\n    # This function is called when the mouse is clicked, calling a function based on what is clicked in game\n    async def click(self, task):\n        # Perform collision traversal\n        self.cTrav.traverse(self.render)\n        \n        try:\n            # Process collisions\n            num_collisions = self.collision_queue.getNumEntries()\n\n            if num_collisions > 1:\n                self.collision_queue.sortEntries()\n                entry = self.collision_queue.getEntry(1)  # Get the closest collision\n                hit_node = entry.getIntoNode()\n                # Check if the hit node is the model that is supposed to be clicked using something like this:\n#                for enemy in list(self.enemy.EnemyDict['collision'].values()):\n#                    if hit_node.getName() == enemy.getName():\n#                        self.enemyController.EnemyHit(enemy)\n#                        await Task.pause(.2)\n        except AssertionError as e:\n            print(\"AssertionError occurred during collision processing.\")\n            print(e)\n        except KeyError as e:\n            print(\"KeyError occurred during collision processing.\")\n            pass\n        return Task.cont\n    \n    def shader(self, nodes = None, EnterNode = None):\n        self.currentModels = []\n        if not hasattr(self, 'Shader_setup'):\n            self.Shader_setup = None\n            print(PandaSystem.getPlatform())\n            if PandaSystem.getPlatform() == 'win_amd64' or PandaSystem.getPlatform() == 'osx_aarch64':\n                shaders = [f\"{os.path.dirname(__file__)}/assets/shaders/Shader.vert\", f\"{os.path.dirname(__file__)}/assets/shaders/Shader.frag\"]\n                patchedShaders = []\n                for file in shaders:    \n                    with open(file, 'r') as file:\n                        code = file.read()\n                        code = code.replace(\"#version 300 es\", \"#version 330\")\n                        code = \"\\n\".join(\n                            line for line in code.splitlines()\n                            if not line.strip().startswith(\"precision\")\n                        )\n                        patchedShaders.append(code)\n                self.Shader = Shader.make(Shader.SL_GLSL, patchedShaders[0], patchedShaders[1])\n            else:\n                self.Shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/Shader.vert\", \"assets/shaders/Shader.frag\")\n            shadow_buffer = self.win.make_texture_buffer(\"ShadowBuffer\", 1024, 1024)\n            shadow_buffer.set_sort(-100)\n            shadow_buffer.set_clear_color((1, 1, 1, 1))\n            self.shadow_map = shadow_buffer.get_texture()\n            self.shadow_map.set_minfilter(SamplerState.FT_shadow)\n            self.shadow_map.set_magfilter(SamplerState.FT_shadow)\n\n            self.shadow_cam = self.make_camera(shadow_buffer, lens=OrthographicLens())\n            self.shadow_cam.reparent_to(self.sunLightNP)\n\n            shadow_scene = self.render.copy_to(NodePath(\"shadow_scene\"))\n            shadow_scene.set_shader(Shader.load(Shader.SL_GLSL, \"assets/shaders/shadow_depth.vert\", \"assets/shaders/shadow_depth.frag\"))\n            self.shadow_cam.node().set_scene(shadow_scene)\n        if EnterNode == None:\n            for node in nodes:\n                self.currentModels.append(node)\n                node.setShader(self.Shader)\n                node.setShaderInput(\"shadowMap\", self.shadow_map)\n                node.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n                node.setShaderInput(\"diffuseTex\", node.find_texture(\"*\"))\n                node.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n                node.setShaderInput(\"light0_color\", Vec3(.5, .75, 0.85))\n                node.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n                node.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n                node.setShaderInput(\"material_shininess\", 10.0)\n                node.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n                node.setShaderInput(\"cameraPos\", self.camera.getPos(self.render))\n\n        else:\n            self.currentModels.append(EnterNode)\n            EnterNode.setShader(self.Shader)\n            EnterNode.setShaderInput(\"shadowMap\", self.shadow_map)\n            EnterNode.setShaderInput(\"shadowViewMatrix\", self.shadow_cam.get_mat(self.render))\n            EnterNode.setShaderInput(\"diffuseTex\", EnterNode.find_texture(\"*\"))\n            EnterNode.setShaderInput(\"light0_direction\", Vec3(.45, 1, 0))\n            EnterNode.setShaderInput(\"light0_color\", Vec3(.75, .75, 0.5))\n            EnterNode.setShaderInput(\"material_diffuse\", Vec4(0.2, 0.2, 0.2, 1.0))\n            EnterNode.setShaderInput(\"material_specular\", Vec4(0.2, 0.2, 0.2, 1))\n            EnterNode.setShaderInput(\"material_shininess\", 15.0)\n            EnterNode.setShaderInput(\"ambient_color\", Vec3(0.5, 0.5, 0.5))\n    # This function loads the models in the background, reducing lag and improving performance\n    async def loadScene(self):\n\n        # in case of death, we need to reload the bool\n        if hasattr(self, '_player_died'):\n            delattr(self, '_player_died')  # Remove self._player_died\n        \n        if hasattr(self, '_player_won'):\n            delattr(self, '_player_won')  # Remove self._player_won\n            \n        with open(f'{os.path.dirname(__file__)}/save.txt', 'r') as f:\n            line = f.readline()\n            line = line.replace('LPoint3f(', '').replace(')', '')\n            x, y, z = map(float, line.split(','))\n        \n\n        self.camera.setPos(x, y, z)\n\n        # Load the models in the background, each time suspending this\n        # method until they are done\n        self.worldCollisionModel = await self.loader.loadModel(\"assets/models/worldTriangles.bam\", blocking=False)\n        self.worldVisibleModel = await self.loader.loadModel(\"assets/models/worldVisible.bam\", blocking=False)\n\n        # Create a background for the world\n        \n        self.world_bg = await self.loader.loadModel(\"assets/models/skybox.bam\",blocking=False)\n        self.world_bg.reparent_to(self.render)\n        self.world_bg.set_scale(2500)\n\n        world_bg_texture = self.loader.loadTexture(\"assets/images/world_bg.png\")\n        world_bg_texture.set_minfilter(SamplerState.FT_linear)\n        world_bg_texture.set_magfilter(SamplerState.FT_linear)\n        world_bg_texture.set_wrap_u(SamplerState.WM_repeat)\n        world_bg_texture.set_wrap_v(SamplerState.WM_mirror)\n        world_bg_texture.set_anisotropic_degree(200)\n        self.world_bg.set_texture(world_bg_texture)\n        world_bg_shader = Shader.load(Shader.SL_GLSL, \"assets/shaders/world_bg.vert.glsl\", \"assets/shaders/world_bg.frag.glsl\")\n        self.world_bg.set_shader(world_bg_shader) \n        \n        # Create a collision node for the world\n        self.world_collision_node = self.worldCollisionModel.find(\"**/+CollisionNode\")\n        self.worldCollisionModel.hide()\n        self.cTrav.addCollider(self.world_collision_node, self.pusher)\n        self.pusher.addCollider(self.world_collision_node, self.worldCollisionModel)\n\n        # Set up Lighting System\n        self.sunLight = DirectionalLight('directionalLight')\n        self.sunLight.setShadowCaster(True, 16384, 16384)\n        self.sunLightNP = self.render.attachNewNode(self.sunLight)\n        self.sunLightNP.setHpr(45, 45, 0)\n        self.sunLight.setColor((1.5, 1.5, 1.5, 1))\n        \n        self.sunModel = await self.loader.loadModel(\"assets/models/sun.bam\", blocking=False)\n        self.sunModel.setPos(150, -150, 200)\n\n        print(self.sunModel)\n        ambientLight = AmbientLight('ambientLight')\n        ambientLight.setColor((0.1, 0.1, 0.1, 1))\n        ambientLightNP = self.render.attachNewNode(ambientLight)\n        \n        # Set the shaders\n        ''' Most of the time this is very custom. Though there is a pipeline that can be used\n            Most of this stuff can be recycled\n        '''\n        self.shader([self.sunModel, self.worldVisibleModel])\n        \n        # Wait for the player to start the game\n        await self.playButtonMethod\n        self.clickSound.play()\n\n        # Remove the main menu\n        self.titleText.destroy()\n        self.btnPlay.destroy()\n        self.mainMenuBackground.destroy()\n        self.btnOption.destroy()\n        self.btnTutorial.destroy()\n\n        # Create a loading screen\n        Loading_text = OnscreenText(\"Loading\")\n\n        self.HealthBar = DirectWaitBar(text=\"Hull\", value=100, pos=(-.85, -15, -.7))\n        self.HealthBar['barColor'] = (0, 2, 0, 2)\n        self.HealthBar['text_scale'] = .05\n        self.HealthBar['frameSize'] = (-.35, .35, -.035, .02)\n        self.HealthBar['barRelief']= DGG.SUNKEN\n\n        self.HullBar = DirectWaitBar(text=\"Fuel\", value=100, pos=(-.85, -1, -.8))\n        self.HullBar['barColor'] = (2, .5, 0, 2)\n        self.HullBar['text_scale'] = .05\n        self.HullBar['frameSize'] = (-.35, .35, -.035, .02)\n        self.HullBar['barRelief']= DGG.SUNKEN\n\n        # Reparent the models to the render, making the world, and set the lights\n        self.worldCollisionModel.reparentTo(self.render)\n        self.worldVisibleModel.reparentTo(self.render)\n        self.render.setLight(self.sunLightNP)\n        self.render.setLight(ambientLightNP)\n        self.sunModel.reparentTo(self.render)\n        \n        # Add HUD\n        self.PlayerHUD()\n        \n        # Add a Pause Menu\n        pausetext = OnscreenText(\"To Pause press P\", pos=(-1.14, 0.95), scale=0.05, fg=(0, 0, 0, 1), align=TextNode.ACenter)\n        self.accept('p', self.PauseMenu)\n\n        # initialize the camera controller\n        self.CameraOperator()\n        \n        self.particleEffect = ParticleEffect()\n        os.chdir(os.path.abspath(os.path.dirname(__file__)))\n        self.particleEffect.loadConfig(f\"{Filename.fromOsSpecific(os.path.dirname(__file__))}/assets/particles/gunfiring.ptf\")\n        self.particleEffect.clearShader()\n        # Start the update cycle\n        taskMgr.add(self.Update, \"Update\")        \n        self.accept('mouse1-up', self.MouseUp)\n        Loading_text.destroy() \n\n        self.textTypewriteAnimation((0,0), 'hello')\n    # The Update cycle, this function should be used to update positions and anything that needs to be updated\n    def Update(self, task):\n        camera_forward = self.camera.getQuat(self.render).getForward()\n        camera_up = self.camera.getQuat(self.render).getUp()\n        camera_right = self.camera.getQuat(self.render).getRight()\n        camera_position = self.camera.getPos(self.render)\n\n        self.dayNightCycle()\n#            ak47_position = (\n#                camera_position +\n#                camera_forward * 2.67 -  # Forward by 1.0 units\n#                camera_up * 1 +       # Downward by 0.5 units\n#                camera_right * 0.8      # Rightward by 0.3 units\n#            )\n#            self.ak47.setPos(ak47_position)\n#            self.ak47.setHpr(self.camera.getH(), 0, 90)\n        \n        self.worldCollisionModel.setPos(0, 0, 0)\n        \n        self.HealthBar['value'] = self.PlayerHealth\n\n        if self.PlayerHealth < 0 and not hasattr(self, '_player_died'):\n            self._player_died = None\n            self.Death()\n        \n        if not True:\n            self._player_won = None\n            self.CameraOperator()\n            def LoadMainMenu(self):\n                self.clickSound.play()\n                taskMgr.remove('Update')\n                self.SaveProgress(reset=True)\n                self.HealthBar.destroy()\n                self.playButtonMethod = AsyncFuture()\n                self.MainMenu()\n                self.cam_controller = CameraControllerBehaviour(self.camera, velocity=3, mouse_sensitivity=self.mouse_sensitivity)\n                self.cam_controller.setup(keys=self.keys)\n                self.cam_controller.disable()\n                self.currentwave = 0\n                children_to_remove = [child for child in self.render.getChildren() if child not in self.camera]\n                for child in children_to_remove:\n                    if '__Actor_modelRoot' in child.getChildren():\n                        child.cleanup()\n                    else:    \n                        child.removeNode()\n                self.winFrame.destroy()\n                self.btnMainMenu.destroy()\n                taskMgr.add(self.loadScene())\n            self.winFrame = DirectFrame(frameColor=(0, 0, 0, 1), \n                                        frameSize=(-1.4, 1.4, -1., 1), \n                                        pos=(0, 0, 0), \n                                        scale=(1, 1, 1), \n                                        text=\"You Won!\", \n                                        text_font=self.Font,\n                                        text_scale=0.5, \n                                        text_pos=(0, .25), \n                                        text_fg=(0, 0, 1, 1), \n                                        text_align=TextNode.ACenter)\n            self.btnMainMenu = DirectButton(\n                parent=self.winFrame,\n                frameColor=(0.15, 0.15, 0.15, 1),\n                frameSize=(-0.4, 0.4, -0.08, 0.16),\n                pos=LPoint3f(0, 0, -0.15),\n                hpr=LVecBase3f(0, 0, 0),\n                relief=1,\n                scale=LVecBase3f(1, 1, 1),\n                text='Exit to Main Menu',\n                text_align=TextNode.A_center,\n                text_scale=(0.075, 0.075),\n                text_pos=(0, 0),\n                text_fg=LVecBase4f(0.8, 0.8, 0.8, 1),\n                text_bg=LVecBase4f(0, 0, 0, 0),\n                command=LoadMainMenu,\n                extraArgs=[self],\n            )\n        return Task.cont\n    def __init__(self):\n        super().__init__()\n\n        self.currentwave = 0\n\n        # Defining the Traverser, the task that checks for collisions, and the pusher, the task that pushes objects when it collides\n        # The Traverser reports to the pusher, we also need to tell Panda3d which objects respond to collisions\n        self.cTrav = CollisionTraverser()\n        self.pusher = CollisionHandlerPusher()\n\n        # Camera setup\n        self.cam_controller = CameraControllerBehaviour(self.camera, velocity=10, mouse_sensitivity=self.mouse_sensitivity)\n        self.cam_controller.setup(keys=self.keys)\n        self.cam_controller.disable()\n        camera_collision_node = CollisionNode('camera')\n        camera_collision_node.addSolid(CollisionBox(LPoint3f(0, 0, 0), 1, 1, 20))\n        camera_collision_node_path = self.camera.attachNewNode(camera_collision_node)\n        camera_collision_node_path.setCollideMask(BitMask32.bit(2))\n  \n        # Add the collision nodes to the traverser. This is how we tell Panda3d which objects respond to collisions  \n        self.cTrav.addCollider(camera_collision_node_path, self.pusher) \n        self.pusher.addCollider(camera_collision_node_path, self.camera)\n\n        #   We load the tasks in the background to reduce lag\n        self.playButtonMethod = AsyncFuture()\n        taskMgr.add(self.loadScene())\n        \n        #  Tell Panda3d to listen for mouse clicks\n        self.accept('mouse1', self.MouseIn)\n        self.Font = self.loader.loadFont('assets/fonts/dimitri.ttf')\n        self.Font.setPixelsPerUnit(120)\n\n        self.clickSound = self.loader.loadSfx('assets/audio/click.wav')\n\n        self.enableParticles()\n\n#        self.messenger.toggleVerbose()\n        self.accept('x', self.exportScene)\n\n        # Open the main menu\n        self.MainMenu()\ngame = Game()\nbase.run()"
        }
    ]
}